" 
" GENERAL NATIVE VIM SETTINGS
" 
    filetype plugin indent off
    syn on
    filetype on
    set nu
    set nosol
    set wrap
    set linebreak
    set breakindent
    set ruler
    set hidden
    set showtabline=2  " always show tabline
    set noshowmode
    set nobackup
    set nowritebackup
    set updatetime=1000
    set shortmess+=c
    set diffopt=context:15
    set diffopt+=iblank
    set diffopt+=iwhite
    set diffopt+=internal
    set diffopt+=algorithm:minimal
    set diffopt+=indent-heuristic
    set diffopt+=filler
    set diffopt+=vertical
    set signcolumn=yes
    set termguicolors  " Increases the saturation
    set previewheight=5

    " different cursors in different modes
        let &t_SI = "\<Esc>[6 q"
        let &t_SR = "\<Esc>[4 q"
        let &t_EI = "\<Esc>[2 q"
        set timeoutlen=1000 ttimeoutlen=0

    set ve=block
    set hlsearch
    set incsearch

    set smartindent
    set autoindent

    set wildmenu
    set showcmd
    set scrolloff=5
    " set relativenumber
    set conceallevel=2
    set mouse=a

    set formatoptions=cro
    set clipboard=unnamedplus

    set swapfile
    set dir=/tmp
    set modeline

    " to refresh file on git checkout
        set autoread

    set tabstop=4 shiftwidth=4 expandtab

    " Considering '-' as part of a word
        set iskeyword+=-

    " Disable freaking sql completion
        let g:omni_sql_no_default_maps = 1

    " change the leader key to <space>
        let g:mapleader = "\<Space>"

    " Don't conceal markdown
        let g:vim_markdown_conceal_code_blocks=0
        let g:vim_markdown_conceal=0


" 
" LOOKS AND FEEL
" 
    " General
        colorscheme gruvbox
        set fillchars=stl:\ ,stlnc:=,vert:│,fold:\ ,diff:-
        set listchars=tab:.\ , list

    " Folding
        set foldlevelstart=99
        set foldmethod=expr
        set foldexpr=FoldLevel(v:lnum)
        set foldtext=NeatFoldText()

    " GruvBox config
        let g:gruvbox_italic = 1
        let g:gruvbox_undercurl = 1
        let g:gruvbox_termcolors = 256
        let g:gruvbox_contrast_dark = "medium"
        let g:gruvbox_italicize_strings = 1
        let g:gruvbox_invert_selection = 0
        let g:gruvbox_invert_signs = 0  " for GitGutter signs
        let g:gruvbox_guisp_fallback = 'bg'

    " GVim
        set guioptions-=m  "remove menu bar
        set guioptions-=T  "remove toolbar
        set guioptions-=r  "remove right-hand scroll bar
        set guioptions-=L  "remove left-hand scroll bar
        set background=dark

    " language specific
        " python
            " let g:python_highlight_all
            let g:python_highlight_builtin_funcs=1
            let g:python_highlight_builtin_objs=1
            let g:python_highlight_builtins=1
            let g:python_highlight_doctests=1
            let g:python_highlight_exceptions=1
            let g:python_highlight_file_headers_as_comments=1
            let g:python_highlight_indent_errors=0
            let g:python_highlight_space_errors=0
            let g:python_highlight_string_format=1
            let g:python_highlight_string_formatting=1
            let g:python_highlight_string_templates=1
            let g:python_print_as_function=1
            let g:python_slow_sync=0
            let g:python_version_2=0

" 
" FUNCTIONS
" 
    function! ComparePositions(p1, p2)
        let linediff = a:p2[0] - a:p1[0]
        let coldiff = a:p2[1] - a:p1[1]
        return linediff + (!linediff) * coldiff
    endfunction

    function! CursorOnMatch(searchPattern)
        " checks whether a cursor is on a match or not
        let position = getcurpos()[1:2]
        let curpos = getpos('.')
        call setpos('.', [0] + position + [0])

        let pos = searchpos(a:searchPattern, 'ec')

        if pos == [0,0] || ComparePositions(position, pos) < 0
            call setpos('.', curpos)
            return 0
        endif


        let pos = searchpos(a:searchPattern, 'bnc')

        if pos == [0,0] || ComparePositions(pos, position) < 0
            call setpos('.', curpos)
            return 0
        endif

        call setpos('.', curpos)
        return 1
    endfunction

    function! EOL()
        call setpos('.', [0, line('.'), col('$'), 0, col('$')])
    endfunction

    let g:mappings = {}
    function! UpdateMappings()
        " Put mappings into place after they have been added by AddMapping

        if ! exists('g:mappings') | let g:mappings = {} | endif
        for mode in keys(g:mappings)
            for cmd in keys(g:mappings[mode])
                " Destroying existing mappings
                let old_map = maparg(cmd, mode)
                if old_map != ''
                    sil!exe mode[0]."unmap ".cmd
                    sil!exe mode[0]."unmap <buffer> ".cmd
                endif

                let escaped_cmd = substitute(cmd, '<', '</', 'g')
                " Setting up new mapping
                if match(mode, '^i') >= 0
                    exe mode."map <silent> ".cmd." <C-r>=ExeMap('".mode."', '".escaped_cmd."')<CR>"
                else
                    exe mode."map <silent> ".cmd." <CMD>call ExeMap('".mode."', '".escaped_cmd."')<CR>"
                endif
            endfor
        endfor
    endfunction
    function! AddMapping(mode, cmd, code)
        " To add 2 different mappings to a given keystroke

        if ! exists('g:mappings')               | let g:mappings = {}                | endif
        if ! has_key(g:mappings, a:mode)        | let g:mappings[a:mode] = {}        | endif
        if ! has_key(g:mappings[a:mode], a:cmd) | let g:mappings[a:mode][a:cmd] = [] | endif
        call add(g:mappings[a:mode][a:cmd], a:code)
    endfunction
    function! ExeMap(mode, cmd, ...)
        " Executes a mapping command
        if ! has_key(g:mappings, a:mode)
            return ''
        endif
        let cmd = substitute(a:cmd, "</", "<", "g")
        if ! has_key(g:mappings[a:mode], cmd)
            return ''
        endif
        let codes = g:mappings[a:mode][cmd]
        if match(a:mode, '^i') >= 0
            " insert mode

            let cnt_per_cmd = get(a:, 2, 0)

            if len(codes) <= cnt_per_cmd
                return RepairSpecial(cmd)
            endif

            let cara = eval(codes[cnt_per_cmd])
            let cara = substitute(cara, " ", "<SPACE>", "g")

            if cara == cmd
                let cnt_per_cmd += 1
            else
                let cnt_per_cmd = 0
            endif

            let cnt_total = get(a:, 1, 0)
            if cnt_total < 10
                let res = ExeMap(a:mode, substitute(cara, '<', '</', 'g'), cnt_total+1, cnt_per_cmd)
                if res != ''
                    return RepairSpecial(res)
                endif
            endif
            return RepairSpecial(cara)
        else
            for code in codes
                exe code
            endfor
            return ''
        endif
    endfunction
    function! RepairSpecial(str)
        let str = substitute(a:str, '<', '\\<', 'g')
        let str = substitute(str, '"', '\\"', 'g')
        return eval('"'.str.'"')
    endfunction

    function! RestrictSearch(flag)
        " Restricts the current search to only the n following / preceeding
        " lines
        let cursearch = @/
        let save = winsaveview()

        " let cara = matchstr( a:line, '\S\ze\s' )
        let start = matchstr(cursearch, '\\%>\zs\d\+\zel')
        let end = matchstr(cursearch, '\\%<\zs\d\+\zel')
        let search = substitute(cursearch, '\\%[<>]\d\+l', '', 'g')

        if a:flag == 0
            let @/ = search
            return
        endif

        if a:flag < 0
            if !end
                let end = line('.') + 1
            endif
            if start
                call setpos('.', [0, start + 1, 0, 0])
            endif
            call search(search, 'bW')
            let start = line('.') - 1
        else
            if !start
                let start = line('.') - 1
            endif
            if end
                call setpos('.', [0, end, 0, 0])
            endif
            call search(search, 'W')
            let end = line('.') + 1
        endif

        call winrestview(save)

        let @/ = '\%>'.start.'l\%<'.end.'l'.search
        " call histadd('/', @/)
    endfunction

    function! Now()
        " Gives Epoch time in ms
        let time = system('date +%s%N')
        let time = time[:len(time) - 8]
        return time
    endfunction
    function! TimeStart()
        " Starts a timer
        let g:time = Now()
    endfunction
    function! TimeShow(...)
        " Shows the time since the last timer reset, and resets the timer
        let time = Now() - g:time
        if a:0 >= 1
            echom a:1 . ' - ' . string(time)
        else
            echom string(time)
        endif
        call TimeStart()
    endfunction

    function! AlignFromTo(cara, range, offsets, align_cara, jump)
        let linenr = a:range[0]
        let biggestCol = 0
        let caralen = len(a:cara)
        while linenr <= a:range[1] && linenr != 0
            let line = getline(linenr)

            let jumpcnt = 0
            let col = match(line, a:cara)

            while jumpcnt < a:jump && col >= 1
                let col = match(line, a:cara, col + 1)
                let jumpcnt = jumpcnt + 1
            endwhile

            if col < 0
                let linenr = nextnonblank(linenr + 1)
                continue
            endif

            " removing whitespaces on each side of the cara
            while line[col + caralen] == ' '
                let line = line[:col + caralen - 1] . line[col + caralen + 1:]
            endwhile
            while col > 1 && line[col - 1] == ' '
                let line = line[:col - 2] . line[col:]
                let col = col - 1
            endwhile

            call setline(linenr, line)

            if col > biggestCol
                let biggestCol = col
            endif
            let linenr = nextnonblank(linenr + 1)
        endwhile

        if biggestCol == 0 | return 0 | endif

        let linenr = a:range[0]
        while linenr <= a:range[1] && linenr != 0
            let line = getline(linenr)

            let col = match(line, a:cara)

            let jumpcnt = 0
            while jumpcnt < a:jump && col >= 1
                let col = match(line, a:cara, col + 1)
                let jumpcnt = jumpcnt + 1
            endwhile

            if col < 0
                let linenr = nextnonblank(linenr + 1)
                continue
            endif

            let diff = biggestCol - col

            if a:offsets[1]
                let line = line[:col + caralen - 1] . repeat(' ', a:offsets[1]) . line[col + caralen:]
            endif
            if a:offsets[0]
                let line = line[:col - 1] . repeat(' ', a:offsets[0]) . line[col:]
                let col = col + a:offsets[0]
            endif

            if a:align_cara 
                let col = col - 1
            else
                let col = col + caralen - 1
            endif

            let line = line[:col] . repeat(' ', diff) . line[col + 1:]

            while line[len(line)-1] == ' '
                let line = line[:len(line)-2]
            endwhile

            call setline(linenr, line)

            let linenr = nextnonblank(linenr + 1)
        endwhile
        return 1
    endfunction
    function! Align(cara, range)
        " Align lines together on given character
        let save = winsaveview()

        let align_cara = 1
        let offsets = [1, 1]

        if a:cara == ':' || a:cara == ','
            let align_cara = 0
            let offsets = [0, 1]
        endif

        let searchSave = @/
        if a:range < 0
            " Match mode
            let from = line('.')
            while match(getline(from), a:cara) >= 0 && from > 1
                let from = from - 1
            endwhile
            let to = line('.')
            while match(getline(to), a:cara) >= 0 && to < line('$')
                let to = to + 1
            endwhile
        else
            " Visual Mode
            let from = line("'<")
            let to = line("'>")
        endif

        let jump = 0
        while AlignFromTo(a:cara, [from, to], offsets, align_cara, jump)
            let jump = jump + 1
        endwhile

        call winrestview(save)
    endfunction
    command! -range -nargs=+  A call Align(<q-args>, '<count>')

    function! DoAtEach(macro, range)
        " Execute the given keystrokes to each occurence of a search, or at
        " each line if in select mode
        let save = winsaveview()
        let count = 0
        let searchSave = @/
        let selSave = [ getpos("'<"), getpos("'>") ]
        if a:range < 0
            " Match mode
            call setpos('.', [0, 1, 1, 0])

            " Counting number of matches
            let matchnr = 0
            while search(@/, 'W') | let matchnr += 1 | endwhile
            call setpos('.', [0, 1, 1, 0])
            call search(@/, 'W')
            exe "norm!\<BS>"
            let @/ = substitute(@/, '\\%[<>]\d\+l', '', 'g')
            let searchSave = @/

            while search(@/, 'c') && matchnr > 0
                exe "exe \"norm! " . substitute(substitute(a:macro, '<>', '\<ESC>', 'g'), '<[a-zA-Z-]\+>\|"', '\\&', 'gi') . '"'

                let @/ = searchSave
                call setpos("'<", selSave[0])
                call setpos("'>", selSave[1])

                let matchnr -= 1
            endwhile
        else
            " Visual Mode
            call setpos('.', getpos("'<"))
            let botline = line("'>")
            while line('.') <= botline

                let col = col('.')
                exe "exe \"norm! " . substitute(substitute(a:macro, '<>', '\<ESC>', 'g'), '<[a-zA-Z-]\+>\|"', '\\&', 'gi') . '"'
                if line('.') == line('$')
                    break
                endif
                call setpos('.', [0, line('.')+1, col, 0])
                " norm!j

                let @/ = searchSave
                call setpos("'<", selSave[0])
                call setpos("'>", selSave[1])

                let count += 1
                if count > 10000
                    break
                endif
            endwhile
            " norm!gv
        endif

        call winrestview(save)
    endfunction
    noremap M :M<SPACE>
    command! -range -nargs=+  M call DoAtEach(<q-args>, '<count>')

    function! ParseErrorLine(errLine)
        let data = split(a:errLine, ':')
        let filename = remove(data, 0)
        if len(data) > 0
            let line = remove(data, 0)
        else
            let line = 1
        endif
        if len(data) > 0
            let column = remove(data, 0)
        else
            let column = 1
        endif
        exe "edit ".filename
        call cursor(line, column)
        filetype detect
        redraw!
    endfunction
    command! -nargs=+  Err call ParseErrorLine('<args>')

    function! CursorInFileWindow()
        let notFile = {
            \   'filetype' : [
            \     'qf'      , 'vimpager', 'undotree', 'tagbar',
            \     'nerdtree', 'vimshell', 'vimfiler', 'voom'  ,
            \     'tabman'  , 'unite'   , 'quickrun', 'Decho',
            \     'fzf'
            \   ],
            \   'bufname' : [
            \     'GoToFile'                  , 'diffpanel_\d\+'      ,
            \     '__Gundo_Preview__'         , '__Gundo__'           ,
            \     '\[LustyExplorer-Buffers\]' , '\-MiniBufExplorer\-' ,
            \     '_VOOM\d\+$'                , '__Urannotate_\d\+__' ,
            \     '__MRU_Files__', '.*FZF'
            \   ]
            \ }

        if index(notFile.filetype, &ft) != -1 ||
                    \ len(&buftype)
            return 0
        endif
        let bufname = buffer_name()
        for rx in notFile.bufname
            if len(matchstr(bufname, rx))
                return 0
            endif
        endfor
        return 1
    endfunction

    function! SmartJumpToEnd()
        if search('\%#.\?$', 'n') != 0
            " If cursor is at the end of the line
            call setpos("'m", getpos('.'))
            call search('^\(\s\+\).*\%#.*\n\(\1.*\n\)*\zs\1')
            call append('.', repeat(' ', indent('.')))
            norm!j
            call setpos("'n", getpos('.'))
            norm!=`m`n
            call EOL()
        else
            let pos = search('\%#.\{-}\zs[\[\](){}]')

            if pos == 0
                call search('.;\?$')
            elseif search('\%#[[({]') != 0
                " Opening tag
                norm!%
            else
                " Closing tag
                norm!h
            endif
        endif
    endfunction

    function! MapToNextMove(cmd)
        let cmd = escape(a:cmd, '\\"')
        sil!exe "aug nextmove \<BAR>" .
                    \ "autocmd CursorMoved * :sil!exe \"" . cmd . "\\<BAR> aug nextmove \\<BAR> au! \\<BAR> aug END \\<BAR> aug! nextmove\" \<BAR>"
                    \ "aug END"
    endfunction

    function! DuplicateLines(type, ...)
        if a:0
            " We're in visual mode
            if visualmode() == 'v'
                exe 'normal! "my"mPgv'
            else
                exe "normal! :co '<-1\<CR>gv"
            endif
        else
            '[,'] copy '[-1
            call setpos('.', [0, line("']")+1, 1000, 0])
        endif
    endfunction

    function! GetGroupName()
        if !exists("*synstack" )
            return
        endif
        echo map(synstack(line('.'), col('.')), 'synIDattr(v:val, "name" )')
    endfunction

    function! FoldLevel(lnum)
        return indent(nextnonblank(a:lnum)) / getbufvar('.', '&tabstop', 1)
    endfunction

    function! NeatFoldText()
        let foldchar         = matchstr(&fillchars, 'fold:\zs.')
        let lines_count      = v:foldend - v:foldstart + 1
        let lines_count_text = printf("┈─ %1s lines ─┈", lines_count) . repeat(foldchar, 10)
        let foldtextstart    = repeat(' ', indent(nextnonblank(v:foldstart))) . " ••• " 
        let foldtextend      = lines_count_text . repeat(foldchar, 8)
        let foldtextlength   = strlen(substitute(foldtextstart . foldtextend, '.', 'x', 'g')) + &foldcolumn

        return foldtextstart . repeat(foldchar, winwidth(0) - foldtextlength) . foldtextend
    endfunction

    function! CountBefore(rx, until_pos)
        " Amount of rx matches before a given position
        let save = winsaveview()
        let count=0
        while search(a:rx, 'Wb', a:until_pos[0])
            if col('.') > a:until_pos[1]
                let count += 1
            else
                break
            endif
        endwhile
        call winrestview(save)
        return count
    endfunction

    function! FindNextCouple(couple, reverse)
        if a:reverse && CursorOnMatch(a:couple[0]) || ! a:reverse && CursorOnMatch(a:couple[1])
            let pos = getpos('.')[1:2]
            return pos
        endif
        let save = winsaveview()
        let stack = 0
        if a:reverse
            let flags = 'Wb'
        else
            let flags = 'W'
        endif
        while search(a:couple[0].'\|'.a:couple[1], flags)
            if CursorOnMatch(a:couple[0])
                let stack += 1
            else
                let stack -= 1
            endif
            if a:reverse && stack > 0 || !a:reverse && stack < 0
                break
            endif
        endwhile
        let pos = getpos('.')[1:2]
        call winrestview(save)
        return pos
    endfunction

    function! FindSmallestRangePossible(in)
        let couples = [
                    \   ['['         , ']'         , 1],
                    \   ['{'         , '}'         , 1],
                    \   ['('         , ')'         , 1],
                    \   ['\/\*'      , '\*\/'      , 1],
                    \   ['"'         , '"'         , 0],
                    \   ["'"         , "'"         , 0],
                    \   ['[^`]`[^`]' , '[^`]`[^`]' , 1],
                    \   ['`'         , '`'         , 1],
                    \ ]
        let best_before = [0, 0]
        let best_after = [0, 0]
        let best_couple = []

        let save = winsaveview()
        for couple in couples
            let [start, end, wraps] = couple
            let before = searchpos(start, 'Wbnc')
            let after = searchpos(end, 'Wnce')
            
            if before == [0, 0] || after == [0, 0]
                continue
            endif

            if before == after
                let limit_line = 0
                if !wraps | let limit_line = line('.') | endif
                if CountBefore(start, [limit_line, 0]) % 2 == 0
                    call setpos('.', [0, line('.'), col('.')+1, 0])
                else
                    call setpos('.', [0, line('.'), col('.')-1, 0])
                endif
                let before = searchpos(start, 'Wbnc')
                let after = searchpos(end, 'Wnce')
            endif

            if best_before == [0, 0] || best_after == [0, 0] || ( 
                \   ComparePositions(best_before, before)>0
                \   && ComparePositions(after, best_after)>0
                \ )
                if start == end
                    let limit_line = 0
                    if !wraps | let limit_line = line('.') | endif
                    if CountBefore(start, [limit_line, 0]) % 2 == 0
                        continue
                    endif
                else
                    let _before = FindNextCouple(couple, 1)
                    let _after = FindNextCouple(couple, 0)
                    if _before == before
                        let after = _after
                    elseif _after == after
                        let before = _before
                    else
                        continue
                    endif
                endif
                let best_before = before
                let best_after = after
                let best_couple = couple
            endif
            call winrestview(save)
        endfor

        if best_before == [0, 0] || best_after == [0, 0]
            return [0]
        endif

        if (a:in)
            call setpos('.', [0] + best_before + [])
            call search(best_couple[0], 'ecW')
            call search('\s*[^[:blank:]]\|^')
            let best_before = getpos('.')[1:2]

            call setpos('.', [0] + best_after + [0])
            call search(best_couple[1], 'bcW')
            call search('[^[:blank:]]\s*\|$', 'be')
            let best_after = getpos('.')[1:2]
            call winrestview(save)
        endif

        return [best_before, best_after, best_couple]
    endfunction

    function! SelectSmallestRangePossible(external)
        let res = FindSmallestRangePossible(! a:external )
        if res == [0]
            return
        endif
        call setpos("'<", [0] + res[0] + [0])
        call setpos("'>", [0] + res[1] + [0])
        norm!gv
        if mode() == 'V'
            norm!v
        end
    endfunction

    let g:fzf_options = 
                \ '--tiebreak=index ' .
                \ '--filepath-word ' .
                \ '--history /home/zorzi/.local/share/fzf-history/FZF ' .
                \ '--keep-right ' .
                \ '--preview="bash -c \"bat -pp --color always {}\"" ' .
                \ '--preview-window="right:50%:rounded:nowrap:nofollow:nocycle:nohidden" ' .
                \ '--sync'
    function! FZFFindFile()
        let cmd = 'bash -c "rg . --files || find . -type f" | datesort.js'
        silent! call fzf#run({'source': cmd, 'sink': 'e', 'options': g:fzf_options, 'down':'40%'})
    endfunction
    function! FZFUpOneDir()
        if !exists('b:fzf_lookup_dir') || b:fzf_lookup_dir == ''
            let b:fzf_lookup_dir = expand('%:h')
        else
            let b:fzf_lookup_dir = fnamemodify(b:fzf_lookup_dir, ':h')
        end
        echo b:fzf_lookup_dir
        call MapToNextMove('let b:fzf_lookup_dir = ""')
    endfunction
    function! OpenRanger()
        if !exists('b:fzf_lookup_dir') || b:fzf_lookup_dir == ''
            let dir = expand('%')
        else
            let dir = b:fzf_lookup_dir
        end
        let copy_save = @+
        let enter_cmd = "eval fm.move(right=1) if fm.thisfile.is_directory else fm.execute_console(\\'chain shell -f bash -c \"realpath \\\%f | xclip -sel clip\"; quit\\')"
        let cmd =
                    \ "!kitty --title floating" .
                    \ " -o remember_window_size=no -o initial_window_height=500 -o initial_window_width=1000" .
                    \ " ranger" .
                    \ " --cmd 'map <CR> ".enter_cmd."'" .
                    \ " --cmd 'map <RIGHT> ".enter_cmd."'" .
                    \ " --cmd 'map q eval fm.execute_console(\\'chain shell -f bash -c \"echo -n | xclip -sel clip\"; quit\\')'" .
                    \ " " . dir
        sil! exe cmd
        sleep 50m
        if filereadable(trim(@+))
            exe "e " . trim(@+)
            let @+ = copy_save
        endif
    endfunction
    function! FZFFindFileInSameDir()
        if !exists('b:fzf_lookup_dir') || b:fzf_lookup_dir == ''
            let dir = expand('%:h')
        else
            let dir = b:fzf_lookup_dir
        end
        let cmd = '/usr/bin/ls --color=never -t (find '.dir.' -maxdepth 1 -type f) 2> /dev/null'
        silent! call fzf#run({'source': cmd, 'sink': 'e', 'options': g:fzf_options, 'down':'40%'})
    endfunction
    function! s:FZFOpenVimOutput(str)
        let thefile = matchstr(a:str, '^.\{-\}\ze:')
        let theline = matchstr(a:str, '^.\{-\}:\zs\d\+\ze:')
        silent! exe 'edit ' . fnameescape(thefile)
        echo cursor(theline,0)
    endfunction

    " Save current view settings on a per-window, per-buffer basis.
    function! AutoSaveWinView()
        if !exists("w:SavedBufView")
            let w:SavedBufView = {}
        endif
        let w:SavedBufView[bufnr("%")] = winsaveview()
    endfunction
    " Restore current view settings.
    function! AutoRestoreWinView()
        let buf = bufnr("%")
        if exists("w:SavedBufView") && has_key(w:SavedBufView, buf)
            let v = winsaveview()
            let atStartOfFile = v.lnum == 1 && v.col == 0
            if atStartOfFile && !&diff
                call winrestview(w:SavedBufView[buf])
            endif
            unlet w:SavedBufView[buf]
        endif
    endfunction

    function! GetHighlightProps(grpName)
        " Saving linting colors, for the function
        let grpID = synIDtrans(hlID(a:grpName))

        let baseProperties = [ "bold", "italic", "reverse", "inverse", "standout", "underline", "undercurl", "strikethrough" ]
        let base = []

        for prop in baseProperties
            if synIDattr(grpID, prop) == '1'
                let base += [prop]
            endif
        endfor
        let base = join(base, ',')

        return {
                    \ 'name': a:grpName,
                    \ 'fg': synIDattr(grpID, "fg"),
                    \ 'bg': synIDattr(grpID, "bg"),
                    \ 'base': base
                    \ }
    endfunction

    function! FloatingMessage(message)
        let bufnr = nvim_create_buf(v:false, v:true)
        call setbufvar(bufnr, '&signcolumn', 'no')

        let message = ' -- ' . a:message

        let winheight = 1
        let winwidth = len(message)

        let width = float2nr(winwidth - (winwidth*2/10))

        let opts = {
                    \ 'relative': 'cursor',
                    \ 'row': 0,
                    \ 'col': col('$') - col('.') + 4,
                    \ 'focusable': 0,
                    \ 'width': winwidth,
                    \ 'height': 1,
                    \ 'style': 'minimal'
                    \ }

        call appendbufline(bufnr, 0, message)

        let winnr = nvim_open_win(bufnr, v:false, opts)

        let props = GetHighlightProps('Comment')

        let prefix = 'cterm'
        if &termguicolors | let prefix='gui' | endif

        exe "hi Pop cterm=italic gui=italic " . prefix . "bg=" . props.bg . " ctermfg=245 guifg=#928374"
        call setwinvar(winnr, '&winhighlight', 'NormalFloat:Pop')

        call MapToNextMove('exe "norm!:bd!' . bufnr . '\<CR>"')
    endfunction

    function! GitBlame()
        let line=line('.')
        let truefile = system('readlink -f ' . expand('%'))
        let truepath = matchstr(truefile, '^.*/', '')
        let cmd = 'cd '.truepath.' && git blame -p -L '.line.','.line.' '.truefile
        let res = systemlist(cmd)

        let author = ''
        let summary = ''
        let time = ''
        for line in res
            if match(line, 'author ') == 0
                let author = substitute(line, '^\S*\s*', '', '')
            endif
            if match(line, 'summary ') == 0
                let summary = substitute(line, '^\S*\s*', '', '')
            endif
            if match(line, 'author-time ') == 0
                let time = substitute(line, '^\S*\s*', '', '')
            endif
        endfor

        let time = EpochToRelative(time)

        call FloatingMessage(author . ' ) ' . time . ' | ' . summary)
    endfunction

    function! EpochToRelative(epoch)
        let now = system('date +"%s"')
        let diff = now - a:epoch

        let units = ['year', 'month', 'day', 'hour', 'minute', 'second']
        let values = [1] " second
        call insert(values, values[0] * 60) " minute
        call insert(values, values[0] * 60) " hour
        call insert(values, values[0] * 24) " day
        call insert(values, values[0] * 31) " month
        call insert(values, values[1] * 365) " year

        let out = ''
        let cnt = 0
        let yes = 0
        while cnt < len(values)
            let nb = diff / values[cnt]
            let diff -= nb * values[cnt]
            if nb > 0
                let plural = ''
                if nb > 1 | let plural = 's' | endif
                let out .= nb.' '.units[cnt].plural.', '

                " Max 2 units displayed
                if yes | break
                else | let yes = 1
                endif
            endif
            let cnt += 1
        endwhile

        let out = substitute(out, '[[:blank:],]\+$', '', '') . ' ago'

        return out
    endfunction
    function! WhichBraceAmIIn()
        let matches = {
                    \ '{': '}',
                    \ '(': ')',
                    \ '\[': '\]',
                    \ '<': '>'
                    \ }

        let closest_brace = [
                    \ [0, 0],
                    \ [0, 0],
                    \ ['', '']
                    \ ]

        for open_cara in keys(matches)
            let close_cara = matches[open_cara]
            let start_pos = searchpairpos(open_cara, '', close_cara, 'bcn')
            if !closest_brace[0][0] || ComparePositions(closest_brace[0], start_pos) > 0
                let end_pos = searchpairpos(open_cara, '', close_cara, 'n')
                let closest_brace = [
                            \ start_pos,
                            \ end_pos,
                            \ [open_cara, close_cara]
                            \ ]
            endif
        endfor

        return closest_brace
    endfunction
    function! Pack()
        let [start_pos, end_pos, chars] = WhichBraceAmIIn()
        if !start_pos[0] || !end_pos[0] | return | endif

        let line_start = start_pos[0]
        let line_end = end_pos[0]

        if line_start >= line_end | return | endif

        exe (line_start).','.(line_end-1).'s/\n//'
        sil!s/\S\zs\s\+/ /g
        sil!s/[\[(<]\zs\s\+//g
        sil!s/\s\+\ze[\])>]//g

        call cursor(start_pos[0], start_pos[1])
    endfunction

    function! SetIndent(ind, ...)
        " Puts the line at the given indent
        let line = get(a:, 1, line('.'))
        let old_indent = indent(line)
        call setline(line, repeat(' ', a:ind) . getline(line)[old_indent:])
    endfunction

    function! IsSyn(grp_str, line, col)
        let syngrps = map(synstack(a:line, a:col), 'synIDattr(v:val, "name" )')

        let is_string = 0

        for syngrp in syngrps
            if match(tolower(syngrp), tolower(a:grp_str)) >= 0 
                return 1
            endif
            let papa_name = synIDattr(synIDtrans(hlID(syngrp)), 'name')
            if match(tolower(papa_name), tolower(a:grp_str)) >= 0 
                return 1
            endif
        endfor
        return 0
    endfunction

    function! UnpackHtml(start_pos, end_pos, chars)
        let start_indent = indent(a:start_pos[0])
        call search('\s\+\|[''"]\|>')
        let cur_pos = [ line('.'), col('.') ]
        let cur_cara = getline('.')[col('.')-1]
        let cnt = 0
        while cur_cara != '>'
            let cnt = cnt + 1
            if cnt > 100 | return | endif
            if cur_cara == '"' || cur_cara == "'"
                call SearchQuotePair(cur_cara)
                call search('\s\+\|[''"]\|>')
                let cur_pos = [ line('.'), col('.') ]
                let cur_cara = getline('.')[col('.')-1]
                continue
            endif
            if !IsSyn('string', line('.'), col('.'))
                exe "norm i\<CR>"
                call SetIndent(start_indent + &tabstop)
                norm! ^
            endif
            call search('\s\+\|[''"]\|>')
            let cur_pos = [ line('.'), col('.') ]
            let cur_cara = getline('.')[col('.')-1]
        endwhile
        exe "norm i\<CR>"
        call SetIndent(start_indent)
    endfunction
    function! Unpack()
        let [start_pos, end_pos, chars] = WhichBraceAmIIn()
        if !start_pos[0] || !end_pos[0] | return | endif

        let [char_open, char_close] = chars

        if &ft == 'html'
            call cursor(start_pos[0], start_pos[1])
            call UnpackHtml(start_pos, end_pos, chars)
            call cursor(start_pos[0], start_pos[1])
            return
        endif

        call cursor(end_pos[0], end_pos[1])
        exe "norm i\<CR>"

        let next_pos = searchpos('[\])},]', 'nbW')
        let cnt = 200
        while ComparePositions(start_pos, next_pos) > 0
            let cnt -= 1
            if cnt < 0 | break | endif
            call cursor(next_pos[0], next_pos[1])
            let char_now = getline('.')[col('.')-1]
            if char_now == ','
                exe "norm mma\<CR>\<ESC>`m"
            else
                norm!%
            endif

            let next_pos = searchpos('[\])},]', 'nbW')
        endwhile

        call cursor(start_pos[0], start_pos[1])
        exe "norm a\<CR>"
        call cursor(start_pos[0], start_pos[1])
    endfunction

    function! AngularHtmlGotoImplementation()
        let word_under_cursor = expand('<cword>')
        let saveview = winsaveview()

        if search('</\?[a-zA_Z-]*\%#', 'n')
            " Cursor on xml anchor
            exe "CtrlSF -R 'selector:.*" . word_under_cursor . "'"
            return
        endif

        let path = expand('%:h')
        let html_file = expand('%:t')

        if match(html_file, '\.html$') < 0
            " not an HTML file
            return
        endif

        let script_file = ''
        let extensions = ['ts', 'js']
        for ext in extensions
            let script_file = matchstr(html_file, '^.*\.') . ext
            if filereadable(path . '/' . script_file)
                break
            endif
        endfor
        if ! filereadable(path . '/' . script_file)
            return
        endif

        exe 'e ' . path . '/' . script_file

        call cursor(1, 1)

        if
            \ search('\<\%(private\|public\|get\|set\)\s\+\zs' . word_under_cursor . '\>') ||
            \ search('\s\zs' . word_under_cursor . '\>') ||
            \ search('\<' . word_under_cursor . '\>')
            return
        endif

        " Nothing found...
        exe 'e ' . path . '/' . html_file
        call winrestview(saveview)
    endfunction
    autocmd! FileType html nnoremap <buffer> <C-]> <CMD>call AngularHtmlGotoImplementation()<CR>

    function! AngularSwitchFile()
        if exists('g:lastfile') && exists('g:thisfile') && g:thisfile == expand('%')
            let g:thisfile = g:lastfile
            let file = g:lastfile
            let g:lastfile = expand('%')
            return file
        endif
        let path = expand('%:h')
        let current_file = expand('%:t')

        let other_file = ''
        if match(current_file, '\.html$') >= 1
            let extensions = ['ts', 'js']
        else
            let extensions = ['html', 'htm']
        endif

        for ext in extensions
            let other_file = matchstr(current_file, '^.*\.') . ext
            if filereadable(path . '/' . other_file)
                break
            endif
        endfor
        if ! filereadable(path . '/' . other_file)
            let other_file = matchstr(current_file, '^.*\.') . extensions[0]
        endif

        let g:thisfile = path . '/' . other_file
        let g:lastfile = expand('%')
        return path . '/' . other_file
    endfunction
    autocmd! BufEnter *html,*ts,*js,*css nnoremap <buffer> <LEADER>w <CMD>exec "e " . AngularSwitchFile()<CR>

    function! GetMeOut(cara)
        if search('\v%#.[.,\)\}]', 'n')  > 0 || search('\v[.\(]%#', 'n')  > 0
            norm x
        endif
        call search(a:cara, 'cb')
        norm!%
        if search('\v%#\s*$', 'n')  > 0
            " cursor at end of line
            exe "norm a\<SPACE>"
        endif
    endfunction

    function! TsDocFunc()
        " Going after the parenthesis
        norm ^ma%

        " Going at the opening bracket
        call search('{', 'c')

        " Looking for the end of the function
        let [endline, endcol] = searchpairpos('{', '', '}', 'n')

        call setpos('.', getpos("'a"))

        let text = ''
        let line = line('.')

        while line < endline
            let text = text . '\n' . getline(line)
            let line += 1
        endwhile

        let @+ = text

        call system('node /home/zorzi/.my_env/scripts/js-comment-function.js')

        sleep 100m

        call setpos('.', getpos("'a"))
        norm "+P
    endfunction
    function! TsDocSelection()
        " Going at the start of the selection
        call setpos('.', getpos("'<"))

        let text = ''
        let line = line('.')
        let endline = line("'>")

        while line < endline
            let text = text . "\n" . getline(line)
            let line += 1
        endwhile

        let @+ = text

        let res = system('node /home/zorzi/.my_env/scripts/js-comment-code.js')

        let @+ = trim(res)

        sleep 100m

        norm gvp
    endfunction
    function! GuessCode()
        let text = ''
        let line = line('.') - 40
        let endline = line('.') + 10

        if line < 0 | let line = 0 | endif
        if endline > line('$') | let endline = line('$') | endif

        while line < endline
            if line == line('.')
                let linetext = getline(line)
                let beforeCursor = linetext[:col('.') - 1]
                if len(beforeCursor) == 0
                    let beforeCursor = repeat(' ', indent(prevnonblank(line)))
                endif
                let afterCursor = linetext[col('.'):]
                let text = text . '\n' . beforeCursor . '#CURSOR#' . afterCursor
            else
                let text = text . '\n' . getline(line)
            endif
            let line += 1
        endwhile

        let @+ = text

        let res = system('node /home/zorzi/.my_env/scripts/js-guess-code.js ' . &ft)
        let @+ = trim(res)

        sleep 100m

        norm p
    endfunction
    nmap <LEADER>* :call TsDocFunc()<CR>
    vmap <LEADER>* <ESC><CMD>call TsDocSelection()<CR>
    inoremap <C-p> <ESC><CMD>call GuessCode()<CR>

" 
" PLUGINS CONFIG
" 
    " smartHits
        let g:smartHits_should_setup_maps = 0

        call AddMapping('i', '<SPACE>', 'smartHits#smartSpace()')
        call AddMapping('i', '<CR>', 'smartHits#smartCR()')
        call AddMapping('i', '<BS>', 'smartHits#smartBS()')
        call AddMapping('i', '<C-]>', 'smartHits#skip()')
        call AddMapping('i', '\;[', 'smartHits#unskip()')
        " inoremap <LEADER>;[ smartHits#unskip()

        let g:smartHits_pairs = [
            \ ['(', ')'],
            \ ['[', ']'],
            \ ['{', '}'],
            \ ['<', '>'],
            \ ['/**', '*/'],
            \ ['''', ''''],
            \ ['"', '"'],
            \ ['```', '```'],
            \ ]

        " ^ at start of lhs to only work if match at start of line
        " $ at end of lhs to only work if match at end of line
        " \(...\) in lhs, and $1 in rhs to repeat capture or $& to repeat full match
        let g:smartHits_abbrevs = {
            \   'vim': {
            \     '^l': "let",
            \     '^log': "echom",
            \   },
            \   'sh': {
            \     '^log': "echo $!",
            \   },
            \   'html': {
            \     '^\%(div\|span\|table\|h\d\)$': "<$&></$&>\<C-o>F<!",
            \     '^\.\.\([[:alnum:]-]\+\)$': "<div class=\"$1\"></div>\<C-o>F<!",
            \     '\[\([[:alnum:]-]\+\)\]\@=': "\<DEL>[$1]=\"\"\<LEFT>!",
            \   },
            \   'javascript': {
            \     'l': "let",
            \     'c': "const",
            \     'func': "function",
            \     '^log': "console.log();\<LEFT>\<LEFT>!",
            \     'import \(cors\|express\|fs\|path\)': "import $1 from '$1';!",
            \     'import \(\w*\) ': "import $1 from '$1';!",
            \     '^\(if\|for\)$': "$1 ()\<LEFT>!",
            \     '^iff': "if () {\<CR>}<UP><ESC>f(a!",
            \     '^fori': "for (let i=0; i < .length ; i++)\<ESC>F.i!",
            \     '\%(for\s*([^)]*\)\@<=in': "of",
            \     'if\s*(!\([^)]* in\)': "if (!($1)<\LEFT>",
            \     'if\s*(\([^)]*\)not in': "if (!($1)<\LEFT>in",
            \     'if\s*(!\([^)]*instanceof\)': "if (!($1)<\LEFT>",
            \     'if\s*(\([^)]*\)not instanceof': "if (!($1)<\LEFT>instanceof",
            \     '\%(\[[^\]]*\)\@<=\s*=': "\<ESC>F[f]a = !",
            \     '^\(if\|for\|while\|switch\)\s\+\([^([:blank:]][^(]\+\)': "$1 ($2)\<LEFT>",
            \     'prom': "new Promise((resolve, reject) => {})\<LEFT>\<LEFT>!",
            \     '^ret': "return",
            \     ')\s*ret': ") return",
            \     'req$': "require('')\<LEFT>\<LEFT>!",
            \     'aw': "await",
            \     '^ii': "if(  )\<LEFT>\<LEFT>!",
            \     'ff': "\<ESC>:if match(getline(line('.')), ')$') != -1 \<BAR> call setline('.', getline('.') . ';') \<BAR> endif\<CR>a() => {\<CR>}\<C-o>O!",
            \     '^tryc$': "try {\<ESC>:call SmartJumpToEnd()\<CR>a} catch (err) {\<CR>}\<C-o>O\<SPACE>\<BS>\<C-o>z"
            \   },
            \   'javascriptreact': {
            \     '@inherit': 'javascript',
            \   },
            \   'typescriptreact': {
            \     '@inherit': 'javascriptreact typescript',
            \   },
            \   'typescript': {
            \     '@inherit': 'javascript',
            \     'ro': "readonly",
            \     '^Inp': "@Input() attr: string;\<ESC>Fave\<C-g>!",
            \     '^Out': "@Output() attr: EventEmitter<string> = new EventEmitter<string>();\<ESC>^fave\<C-g>!",
            \     'pub': "public",
            \     'pri': "private",
            \   },
            \   'vue': {
            \     '@inherit': 'typescript',
            \   },
            \   'sql': {
            \     'sel': 'SELECT * FROM',
            \     'upd': 'UPDATE tbl SET row = ""',
            \     'del': 'DELETE FROM',
            \   },
            \   'python': {
            \     '^tryc$': "try:\<ESC>:call SmartJumpToEnd()\<CR>aexcept:\<CR>pass\<C-o>O\<SPACE>\<BS>\<C-o>z",
            \     '^log': "print()\<LEFT>!",
            \     '^print': "print()\<LEFT>!",
            \   },
            \ }

    " indentLine
        let g:indentLine_char = '┆'
    
    " CoC
        let g:coc_snippet_next = "<C-x>"
        let g:coc_snippet_prev = "<C-z>"
        function! s:check_back_space() abort
            let col = col('.') - 1
            return !col || getline('.')[col - 1]  =~# '\s'
        endfunction

        function! SmartPumComplete(str)
            if ! coc#_selected() || ! pumvisible()
                return a:str
            endif
            let infos = complete_info()
            let selected = get(infos, 'selected', 0)
            let items = get(infos, 'items', [])
            if selected < -1 | return "\<C-y>" | endif
            if selected == -1 || selected >= len(items)
                return a:str
            endif
            let item = items[selected]
            if get(item, 'word', '') != get(item, 'abbr', '')
                return "\<C-y>"
            endif
            return a:str
        endfunction

        call AddMapping('i', "<SPACE>", 'SmartPumComplete("<SPACE>")')
        call AddMapping('i', "<CR>", 'SmartPumComplete("<CR>")')
        nmap <silent> <C-]> <Plug>(coc-implementation)
        nmap <silent> <F12> <Plug>(coc-references)
        nmap <silent> <F6> <CMD>call CocAction('runCommand', 'cSpell.toggleEnableSpellChecker')<CR>

        " Use K to show documentation in preview window.
        nnoremap <silent> <F1> :call <SID>show_documentation()<CR>
        inoremap <silent> <F1> <CMD>call CocActionAsync('showSignatureHelp')<CR>

        function! s:show_documentation()
            if (index(['vim','help'], &filetype) >= 0)
                execute 'h '.expand('<cword>')
            else
                call CocActionAsync('doHover')
            endif
        endfunction

        " Symbol renaming.
        nmap <leader>rn <Plug>(coc-rename)

        " Formatting selected code.
        xmap <leader>f  <Plug>(coc-format-selected)
        nmap <leader>f  <Plug>(coc-format-selected)

        augroup mygroup
            autocmd!
            " Setup formatexpr specified filetype(s).
            autocmd FileType typescript,json setl formatexpr=CocAction('formatSelected')
            " Update signature help on jump placeholder.
            autocmd User CocJumpPlaceholder call CocActionAsync('showSignatureHelp')
        augroup end

        " Remap keys for applying codeAction to the current line.
        " nmap <leader>ac  <Plug>(coc-codeaction)

        " Use <TAB> for selections ranges.
        " NOTE: Requires 'textDocument/selectionRange' support from the language server.
        " coc-tsserver, coc-python are the examples of servers that support it.
        xmap <silent> <TAB> <Plug>(coc-range-select)

        " Add `:Format` command to format current buffer.
        command! -nargs=0 Format :call CocAction('format')

        " Add `:Fold` command to fold current buffer.
        command! -nargs=? Fold :call     CocAction('fold', <f-args>)

        " Add `:OR` command for organize imports of the current buffer.
        command! -nargs=0 OR   :call     CocAction('runCommand', 'editor.action.organizeImport')

        " Add (Neo)Vim's native statusline support.
        " NOTE: Please see `:h coc-status` for integrations with external plugins that
        " provide custom statusline: lightline.vim, vim-airline.
        " set statusline^=%{coc#status()}%{get(b:,'coc_current_function','')}

    " Vim LightLine
        let g:lightline = {
            \ 'colorscheme': 'powerline',
            \ 'active': {
            \   'left':[ [ 'mode', 'paste' ],
            \            [ 'gitbranch', 'readonly', 'filename', 'modified' ]
            \   ]
            \ },
            \ 'tabline': {
            \   'left': [ ['buffers'] ],
            \   'right': [ [ 'close' ], ],
            \ },
            \ 'component_expand': {
            \   'buffers': 'lightline#bufferline#buffers'
            \ },
            \ 'component_type': {
            \   'buffers': 'tabsel'
            \ },
            \ 'component': {
            \   'separator': '',
            \   'lineinfo': ' %3l:%-2v',
            \ },
        \ }

        " NERDTree File highlighting
        function! ExplorerHighlight(extension, link, all)
            exec 'autocmd filetype coc-explorer highlight link ' . a:extension .' '.a:link
            if a:all
                exec 'autocmd filetype coc-explorer syn match ' . a:extension .' #^\W*\zs\w.*'. a:extension .'\>\s\+#'
            else
                exec 'autocmd filetype coc-explorer syn match ' . a:extension .' #^\W*\w.*\zs'. a:extension .'\>\ze\s\+#'
            endif
        endfunction

        call ExplorerHighlight('txt', 'GruvboxBlue', 0)
        call ExplorerHighlight('md',  'GruvboxBlue', 0)
        " call ExplorerHighlight('css', 'GruvboxBlue', 0)

        call ExplorerHighlight('lock',    'GruvboxBlackItalic', 1)
        call ExplorerHighlight('conf',    'GruvboxBlackItalic', 1)
        call ExplorerHighlight('config',  'GruvboxBlackItalic', 1)
        call ExplorerHighlight('gql',     'GruvboxBlackItalic', 1)
        call ExplorerHighlight('ini',     'GruvboxBlackItalic', 1)
        call ExplorerHighlight('css',     'GruvboxBlackItalic', 1)
        call ExplorerHighlight('json',    'GruvboxBlackItalic', 1)
        call ExplorerHighlight('spec.ts', 'GruvboxBlackItalic', 1)
        call ExplorerHighlight('ico',     'GruvboxBlackItalic', 1)

        call ExplorerHighlight('csv',  'GruvboxYellow', 0)

        call ExplorerHighlight('yaml',       'GruvboxAqua', 0)
        call ExplorerHighlight('yml',        'GruvboxAqua', 0)
        call ExplorerHighlight('Dockerfile', 'GruvboxAqua', 0)

        call ExplorerHighlight('html', 'GruvboxPurple', 0)
        call ExplorerHighlight('php',  'GruvboxPurple', 0)

        call ExplorerHighlight('py',     'GruvboxRed', 0)
        call ExplorerHighlight('coffee', 'GruvboxRed', 0)
        call ExplorerHighlight('js',     'GruvboxRed', 0)
        call ExplorerHighlight('ts',     'GruvboxRed', 0)

        let g:lightline.component_raw = {'buffers': 1}
        let g:lightline#bufferline#enable_devicons = 1
        let g:lightline#bufferline#clickable = 1
        let g:lightline#bufferline#modified = ' ●'
        " let g:lightline#bufferline#reverse_buffers = 1

        let g:lightline.separator = {
            \   'left': '', 'right': ''
          \}
        let g:lightline.subseparator = {
            \   'left': '', 'right': '' 
          \}

    " ultisnips
        let g:UltiSnipsSnippetDirectories  = [$HOME.'/.vim/UltiSnips']
        let g:UltiSnipsExpandTrigger       = "<C-l>"
        call AddMapping('i', '<C-l>', 'UltiSnips#ExpandSnippet()')
        " inoremap <C-l> <CMD>call UltiSnips#ExpandSnippet()<CR>
        inoremap <C-SPACE> <C-x>
        inoremap <C-x> <CMD>call UltiSnips#JumpForwards()<CR>
        inoremap <C-z> <CMD>call UltiSnips#JumpBackwards()<CR>
        xnoremap <C-x> <CMD>call UltiSnips#JumpForwards()<CR>
        xnoremap <C-z> <CMD>call UltiSnips#JumpBackwards()<CR>

    " FZF
        let g:fzf_history_dir = '~/.local/share/fzf-history'
        let g:fzf_nvim_statusline = 0 " disable statusline overwriting

    " GitGutter
        let g:gitgutter_map_keys = 0
        let g:gitgutter_max_signs = 2000
        let g:gitgutter_sign_added = '▎'
        let g:gitgutter_sign_modified = '▎'
        let g:gitgutter_sign_removed = '▎'
        let g:gitgutter_sign_modified_removed = '▎'
        let g:gitgutter_sign_removed_above_and_below = '▎'
        let g:gitgutter_sign_removed_first_line = '▎'

    " Import Cost
        let g:import_cost_show_gzipped = 0

    "Visual Multi
        let g:VM_mouse_mappings   = 0
        let g:VM_theme            = 'iceblue'
        let g:VM_custom_motions  = {'<C-up>': "k", '<C-right>': "l", '<C-down>': "j", '<C-left>': "h"}

        let g:VM_maps = {}
        let g:VM_maps["Reselect Last"] = 'gs'
        let g:VM_maps["Align"] = '='
        let g:VM_maps["Add Cursor At Pos"] = ''
        let g:VM_maps["Add Cursor At Word"] = ''
        let g:VM_maps["Start Regex Search"] = ''
        let g:VM_maps["Select All"] = ''
        let g:VM_maps["Add Cursor Down"] = 's<DOWN>'
        let g:VM_maps["Add Cursor Up"] = 's<UP>'
        let g:VM_maps["Visual Regex"] = ''
        let g:VM_maps["Visual All"] = ''  
        let g:VM_maps["Visual Add"] = ''  
        let g:VM_maps["Visual Find"] = ''
        let g:VM_maps["Visual Cursors"] = ''  
        let g:VM_maps["Find Under"] = ''
        let g:VM_maps["Duplication"] = 'Z'
        " When in search mode
            let g:VM_maps["Find Next"] = '<C-n>'
            let g:VM_maps["Find Previous"] = '<CS-n>'
            " let g:VM_maps["Goto Next"] = ''
            " let g:VM_maps["Goto Previous"] = ''

        let g:VM_maps["Slash Search"] = 's/'
        let g:VM_maps["Find Subword Under"] = ''
        let g:VM_maps["Select Cursor Down"] = ''
        let g:VM_maps["Select Cursor Up"] = ''
        let g:VM_maps["Select j"] = ''
        let g:VM_maps["Select l"] = ''
        let g:VM_maps["Select k"] = ''
        let g:VM_maps["Select h"] = ''
        let g:VM_maps["Select w"] = ''
        let g:VM_maps["Select b"] = ''
        let g:VM_maps["Select E"] = ''
        let g:VM_maps["Select BBW"] = ''
        let g:VM_maps["Mouse Cursor"] = ''
        let g:VM_maps["Mouse Word"] = ''
        let g:VM_maps["Mouse Column"] = ''
        let g:VM_maps["Select Operator"] = 'v'
        
        fun! CursOnMatches() abort
            let v = winsaveview()
            
            call setpos('.', [0, 1, 1, 0])

            let s = @/

            while search(s, 'W')
                call vm#commands#add_cursor_at_pos(0)
            endwhile

            call winrestview(v)
        endfun
        
        fun! MultiCursorOn() abort
            if !exists('g:Vm.buffer')
                return 0
            endif
            return g:Vm.buffer
        endfun

    " CtrlSF
        let g:ctrlsf_auto_close = {
            \ "normal" : 1,
            \ "compact": 1
            \}

        let g:ctrlsf_auto_focus = {
            \ "at": "start"
            \ }

        let g:ctrlsf_auto_preview = 0
        let g:ctrlsf_case_sensitive = 'yes'
        let g:ctrlsf_context = '-B 3 -A 3'
        let g:ctrlsf_default_root = 'cwd'
        let g:ctrlsf_default_view_mode = 'compact'
        let g:ctrlsf_regex_pattern = 0
        let g:ctrlsf_winsize = '40%'
        let g:ctrlsf_mapping = {
            \ "chgmode": "<TAB>",
            \ "quit": "q"
            \ }
    " JsDoc
        let g:jsdoc_formatter = 'tsdoc'

    " vimspector
        let g:vimspector_base_dir='/home/zorzi/.vim/bundle/vimspector'

    " diffunit
        let g:DiffUnit = 'Word'

        function OnOpenVimDiff()
            cab x xa
            cab q qa
            cab w wa

            nnoremap <CS-right> <CMD>diffput <BAR> diffupdate<CR>
            nnoremap <CS-left> <CMD>diffget <BAR> diffupdate<CR>

            nnoremap u u<CMD>diffupdate<CR>

            nnoremap <CS-up> [c
            nnoremap <CS-down> ]c

            nnoremap <F5> :diffupdate<CR>
        endfunction
        autocmd FileType * if &diff | call OnOpenVimDiff() | endif

        set patchexpr=MyPatch()
        function MyPatch()
           :call system("patch -o " . v:fname_out . " " . v:fname_in .
           \  " < " . v:fname_diff)
           :call system("patch -o " . v:fname_out . " " . v:fname_in .
           \  " < " . v:fname_diff . " > ")
        endfunction

        " set diffexpr=MyDiff()
        " function MyDiff()
        "    let opt = ""
        "    if &diffopt =~ "icase"
        "      let opt = opt . "-i "
        "    endif
        "    if &diffopt =~ "iwhite"
        "      let opt = opt . "-b "
        "    endif
        "    silent execute "!diff -d -E -Z -b -B -a -d " . opt . v:fname_in . " " . v:fname_new . " > " . v:fname_out
        "    " echom "!git diff --no-index -w --output " . v:fname_out .  " -- " . v:fname_in . " " . v:fname_new
        "    " echom system("ls " . v:fname_in)
        "    " execute "!git diff -w --output " . v:fname_out .  " -- " . v:fname_in . " " . v:fname_new
        "    " redraw!
        " endfunction
"
" PLUGINS
" 
    " including Vundle and initialize
    set rtp+=~/.vim/bundle/Vundle.vim
    call vundle#begin()

        " 
        " Gotta go fast!
        " 
            " indent range
            Plugin 'vim-indent-object'

            " Fast surround shortcuts
            Plugin 'tpope/vim-surround'

            " fast comment
            Plugin 'tpope/vim-commentary'

            if has('nvim')
                " Snippets
                Plugin 'sirver/UltiSnips'
            endif

            " Recursive search
            Plugin 'dyng/ctrlsf.vim'

            " Multi cursors
            Plugin 'mg979/vim-visual-multi'

        " 
        " Pretty editor
        " 
            " " minimap
            " Plugin 'z0rzi/minimap.vim'

            " visual indents
            Plugin 'Yggdroot/indentLine'

            " Pretty icons
            Plugin 'ryanoasis/vim-devicons'

            " Line on the bottom of the screen
            Plugin 'itchyny/lightline.vim'

        " 
        " Language specific
        " 
            Plugin 'norcalli/nvim-colorizer.lua'

            Plugin 'prettier/vim-prettier', { 'do': 'yarn install --frozen-lockfile --production' }

            Plugin 'HerringtonDarkholme/yats.vim'
            Plugin 'maxmellon/vim-jsx-pretty'

        " 
        " Others
        " 
            " visual GIT modifs
            Plugin 'airblade/vim-gitgutter'

            " Fuzzy search
            Plugin 'junegunn/fzf', { 'do': { -> fzf#install() } }
            " Plugin 'junegunn/fzf.vim'

            " Buffer stuff
            Plugin 'z0rzi/lightline-bufferline'

            Plugin 'neoclide/coc.nvim', {'branch': 'master', 'do': 'yarn install --frozen-lockfile'}

            " Plugin 'rickhowe/diffchar.vim'

        " 
        " My plugins!
        " 
            Plugin 'z0rzi/vim-adaptive-indent'
            Plugin 'z0rzi/vim-zorzi-smoothie'
            Plugin 'z0rzi/vim-smart-hits'

    call vundle#end()

" 
" MAPS
" 
    " Basic Vim Shortcuts
        nmap <A-x> <ESC>
        nmap <A-z> <ESC>
        nnoremap >> i<C-t><ESC>
        inoremap <<SPACE> <<SPACE>
        inoremap << <<
        nnoremap Y y$
        nnoremap z<RIGHT> $
        nnoremap z<LEFT> ^
        nnoremap YY <CMD>let v = winsaveview()<CR>ggyG<CMD>call winrestview(v)<CR>
        nnoremap VV ggVG
        nnoremap vv v$h
        nnoremap <CR> <CMD>call SearchPair()<CR>
        onoremap <CR> v<CMD>call SearchPair()<CR>
        inoremap <F2> <ESC>
        inoremap <C-x><C-l> <C-x><C-l>
        inoremap <silent> <C-r>/ <C-r>=substitute(@/, '\\.', '', 'g')<CR>
        inoremap <LEFT> <C-G>U<LEFT>
        inoremap <RIGHT> <C-G>U<RIGHT>
        inoremap <DOWN> <C-G>U<DOWN>
        inoremap <UP> <C-G>U<UP>

        xnoremap <CR> <CMD>if mode() == 'V' <BAR> call search('\%#.*\zs\([{[(][;:.,\\]*\<BAR>\/\*\+\)$') <BAR> endif<CR>%

        xnoremap p <CMD>let save=@0<CR>p<CMD>let [@0, @", @+] = [save, save, save]<CR>
        xnoremap $ $h
        xnoremap " "rc"<C-r>r"<ESC>gvlolo
        xnoremap ' "rc'<C-r>r'<ESC>gvlolo
        nnoremap - 2<C-y><C-g>
        nnoremap + 2<C-e><C-g>
        xnoremap g= c<C-r>=<C-r>+<CR><ESC>
        nnoremap g= Vc<C-r>=<C-r>+<CR><ESC>
        inoremap \'e é


        " nnoremap <F3> :set hlsearch!<CR>
        nnoremap <F3> <CMD>noh<CR>
        " Plugin: GitGutter
        nmap <F5> <CMD>redraw!<CR><CMD>GitGutter<CR><CMD>set foldmethod=expr<CR><CMD>AdaptIndent<CR>

        " Fast selection wrap
            xnoremap "" c""<ESC>Pgvlolo
            xnoremap '' c''<ESC>Pgvlolo
            xnoremap `` c``<ESC>Pgvlolo
            xnoremap {{ c{  }<ESC>hPgvllollo
            xnoremap }} c{}<ESC>Pgvlolo
            xnoremap [[ c[  ]<ESC>hPgvllollo
            xnoremap ]] c[]<ESC>Pgvlolo
            xnoremap (( c(  )<ESC>hPgvllollo
            xnoremap )) c()<ESC>Pgvlolo

        " no yank delete
            nnoremap \ "_

        " no include newline
            nnoremap 'd ^D
            nnoremap 'D 0D
            nnoremap 'c ^C
            nnoremap 'C 0C
            nnoremap 'y mm^y$`m
            nnoremap 'Y mm0y$`m
            nnoremap 'v ^v$ho
            nnoremap 'V 0v$ho

        " move lines
            nnoremap <C-j> <CMD>m+1<CR>
            nnoremap <C-k> <CMD>m-2<CR>
            nnoremap <C-up> <CMD>if MultiCursorOn()<BAR>exe "norm k"<BAR>else<BAR>m-2<BAR>endif<CR>
            nnoremap <C-down> <CMD>if MultiCursorOn()<BAR>exe "norm j"<BAR>else<BAR>m+1<BAR>endif<CR>
            " nnoremap <C-down> <CMD>m+1<CR>
            " nnoremap <C-up> <CMD>m-2<CR>
            xnoremap <C-up> :<C-u>exe (line("'<")-1) . " m " . line("'>")<CR>gv
            xnoremap <C-down> :<C-u>exe (line("'>")+1) . " m " . (line("'<") - 1)<CR>gv
            xnoremap <C-right> dpgvlolo
            xnoremap <C-left> dhPgvhoho

        " Duplicate lines
            nnoremap <silent> Z <CMD>set opfunc=DuplicateLines<CR>g@
            xnoremap <silent> Z  <CMD>call DuplicateLines(visualmode(), 1)<CR>
            nnoremap <silent> ZZ <CMD>co +0<CR>
            nnoremap <silent> zx <CMD>co +0<CR>

        " Easy search n replace
            nnoremap <C-c> <CMD>if CursorOnMatch(@/) <BAR> exe "norm!lN" <BAR> else <BAR> let @/="\\<".expand("<cword>")."\\>" <BAR> endif<CR>cgn
            nnoremap <C-d> <CMD>if CursorOnMatch(@/) <BAR> exe "norm!lN" <BAR> else <BAR> let @/="\\<".expand("<cword>")."\\>" <BAR> endif<CR>dgn

        " Better ranges for XML
            nmap >it vitVkoj>
            nmap <it vitVkoj<


        " Cool selection stuff
            xnoremap <C-c> "ay:let @/ = SelectionToRx(@a) <BAR> call histadd('/', @/) <BAR> set hlsearch <CR>cgn
            function! ToNextOccurence(backward)
                if mode() == 'n'
                    call RestrictSearch(0)
                    if ! CursorOnMatch(@/)
                        let @/ = '\<'.expand('<cword>').'\>'
                    endif
                    if a:backward | call search(@/, 'bc') | endif
                else
                    norm! "ay
                    let @/ = SelectionToRx(@a)
                endif
                let @/ = @/
                let flags = ''
                " if !exists('s:minimap_search') | let s:minimap_search = '' | endif
                " if s:minimap_search != @/
                "     let s:minimap_search = @/
                "     call minimap#vim#HighlightSearch()
                " endif
                if a:backward | let flags .= 'b' | endif
                call search(@/, flags)
                call histadd('/', @/)
            endfunction
            xnoremap <S-LEFT> <CMD>call ToNextOccurence(1) <BAR> set hlsearch<CR>
            xnoremap <S-RIGHT> <CMD>call ToNextOccurence(0) <BAR> set hlsearch<CR>
            nnoremap <silent> <S-LEFT> <CMD>call ToNextOccurence(1) <BAR> set hlsearch<CR>
            nnoremap <silent> <S-RIGHT> <CMD>call ToNextOccurence(0) <BAR> set hlsearch<CR>
            xnoremap # <CMD>call ToNextOccurence(1) <BAR> set hlsearch<CR>
            xnoremap * <CMD>call ToNextOccurence(0) <BAR> set hlsearch<CR>
            nmap <CS-Right> <CMD>call RestrictSearch(1)<CR>
            nmap <CS-Left> <CMD>call RestrictSearch(-1)<CR>

        " Init folds
            function! FoldIfMakeSense(offset)
                let line = line('.') + matchstr(a:offset, '-\?\d*$')
                let foldline = foldclosed(line)

                if foldline != -1
                    return
                endif

                exe"".a:offset."foldclose"
            endfunction
            function! FoldAllSameLevel()
                let curpos = getcurpos()
                let saveSearch = @/
                let indent = matchstr(getline(line('.')), '^\s\+')
                exe"%g/^\\(".indent."\\s*\\S\\)\\@!\\s*\\S.*\\(\\n\\s*\\)\\+".indent."\\S/call FoldIfMakeSense('+1')"
                let @/ = saveSearch
                call setpos('.', curpos)
                noh
            endfunction
            nnoremap zff <CMD>call FoldAllSameLevel()<CR>

    " Moving mapping
        " fast exact search
            nnoremap <leader>/ /\<\><LEFT><LEFT>

        " Skip word by word with CTRL + direction
            function! CtrlMove(direction)
                if a:direction == 'left'
                    call search('\<\|\u\l\|_[a-z]\|\s\zs\S\|^', 'bW')
                else
                    call search('\w\>\|\u\l\|_[a-z]\|\S\s\|$', 'W')
                    if mode()[0] == 'i'
                        call setpos('.', [0, line('.'), col('.')+1, 0])
                    endif
                endif
            endfunction
            nnoremap <C-LEFT>  <CMD>call CtrlMove('left')<CR>
            nnoremap <C-RIGHT> <CMD>call CtrlMove('right')<CR>
            inoremap <C-LEFT> <CMD>call CtrlMove('left')<CR>
            inoremap <C-RIGHT> <CMD>call CtrlMove('right')<CR>

        " go to end of indent
            function! IndentJump(direction)
                let curline = line('.')
                " let indent = matchstr(getline(curline), '^\s*')
                let indent = indent(curline)
                if a:direction >= 0
                    " let nextLineNum = search('^.*\S.*$', 'n')
                    let nextLineNum = nextnonblank(line('.')+1)
                else
                    " let nextLineNum = search('^.*\S.*\n\_.*\%#', 'nb')
                    let nextLineNum = prevnonblank(line('.')-1)
                endif
                " let nextIndent = matchstr(getline(nextLineNum), '^\s*')
                let nextIndent = indent(nextLineNum)

                if nextIndent < indent || indent == 0
                    if a:direction >= 0
                        let flag = ''
                    else
                        let flag = 'b'
                    endif
                    call search('^.*\S.*\zs$', flag)
                else
                    if a:direction >= 0
                        " call search('^\('.indent.'\).*\n\(\1.*\n\|\s*\n\)*\1.*\zs')
                        call search('[\n[:blank:]]*\n\%\( \)\{,'.(indent-1).'}\S')
                    else
                        " call search('^\('.indent.'\)\S.*\zs\ze\n\(\1.*\n\|\s*\n\)*.*\%#')
                        call search('^\%\( \)\{,'.(indent-1).'}\S.*\n[\n[:blank:]]*.*\zs', 'b')
                    endif
                endif
            endfunction
            noremap <S-UP> <CMD>call IndentJump(-1)<CR>
            noremap <S-DOWN> <CMD>call IndentJump(1)<CR>
            nnoremap z<UP> <CMD>call IndentJump(-1)<CR>
            nnoremap z<DOWN> <CMD>call IndentJump(1)<CR>

        " go to end of scope
            nnoremap { [{
            nnoremap } ]}

        " Easy beg/end of line
            nnoremap ^ 0
            nnoremap 0 ^
            nnoremap <S-Insert> $

        " Move between splits
            nmap <A-LEFT> <C-w><LEFT>
            nmap <A-UP> <C-w><UP>
            nmap <A-RIGHT> <C-w><RIGHT>
            nmap <A-DOWN> <C-w><DOWN>
            nmap <A-h> <C-w>h
            nmap <A-k> <C-w>k
            nmap <A-h> <C-w>h
            nmap <A-l> <C-w>l

    " Plugin related maps
        " CtrlSF
            nnoremap <C-f> :CtrlSF ''<LEFT>
            nnoremap <C-s> :let @/ = '<C-r>=expand('<cword>')<CR>'<CR>:CtrlSF -R '\b<C-r>=@/<CR>\b'<CR>:CtrlSFFocus<CR>
            xnoremap <C-f> <ESC>:let @/ = escape(getline('.')[col("'<")-1 : col("'>")-1], '.\\[]')<CR>:CtrlSF -R "<C-r>=escape(@/, '"()')<CR>"<LEFT>
            xnoremap <C-s> <ESC>:let @/ = escape(getline('.')[col("'<")-1 : col("'>")-1], '.\\[]')<CR>:CtrlSF -R "<C-r>=escape(@/, '"()')<CR>"<CR>

        " CoC
            nnoremap <C-q> :CocAction<CR>
            nnoremap <S-q> :CocCommand<CR>

            " Tab to go through completion list
            inoremap <silent><expr> <TAB>
                  \ pumvisible() ? "\<C-n>":
                  \ <SID>check_back_space() ? "\<TAB>":
                  \ coc#refresh()
            inoremap <expr><S-TAB> pumvisible() ? "\<C-p>" : coc#refresh()

            " Close the preview window when completion is done.
            autocmd! CompleteDone * if pumvisible() == 0 | pclose | endif

            " nmap <silent> <C-c> <Plug>(coc-cursors-position)
            " nmap <silent> <C-d> <Plug>(coc-cursors-word)
            " xmap <silent> <C-d> <Plug>(coc-cursors-range)
            " use normal command like `<leader>xi(`
            " nmap <leader>x  <Plug>(coc-cursors-operator)

        " Git stuff
            " Plugin: GitGutter
            function! GitGutterStageSelection(line_start, line_end)
                let view = winsaveview()
                
                let curline = a:line_start - 1
                call setpos('.', [0, curline, 1, 0])

                while 1
                    sil! GitGutterNextHunk
                    if curline == line('.') || line('.') > a:line_end
                        break
                    endif
                    let curline = line('.')
                    sil! GitGutterStageHunk
                sil! GitGutter
                endwhile

                " call winrestview(view)
                sil! GitGutter
            endfunction
            command -range GitGutterStageSelection call GitGutterStageSelection(<line1>, <line2>)
            xnoremap <LEADER>ga :GitGutterStageSelection<CR>

            nnoremap <LEADER>gs <CMD>call system('git reset ' . @%) <BAR> GitGutter<CR>
            nnoremap <LEADER>gr <CMD>call system('git reset ' . @%) <BAR> GitGutter<CR>
            nnoremap <LEADER>ga <CMD>sil!GitGutterStageHunk<CR>
            nnoremap <LEADER>gu <CMD>sil!GitGutterUndoHunk<CR>
            nnoremap <LEADER>gn <CMD>sil!GitGutterNextHunk<CR>
            nnoremap <LEADER>gp <CMD>sil!GitGutterPrevHunk<CR>
            nnoremap <LEADER>gP <CMD>sil!GitGutterPreviewHunk<CR>
            nnoremap <LEADER>gh <CMD>call system('kitty git-history ' . @%)<CR>
            nnoremap <LEADER>gb <CMD>call GitBlame()<CR>
            nnoremap <LEADER>gD <CMD>call system('git difftool ' . @%) <BAR> GitGutter<CR><CR>

        " FZF
            nnoremap <C-p> <CMD>call FZFFindFile()<CR>
            nnoremap <LEADER>;o <CMD>call FZFUpOneDir()<CR>
            nnoremap <LEADER>;i <CMD>call OpenRanger()<CR>
            nnoremap <F2> <CMD>call OpenRanger()<CR>
            nnoremap <LEADER>;p <CMD>call FZFFindFileInSameDir()<CR>

        " Commentary
            nnoremap  <CMD>Commentary<CR>
            inoremap  <CMD>Commentary<CR>
            xnoremap  :Commentary<CR>gv

        " Multi cursors
            nnoremap s/ :call CursOnMatches()<CR>
            xnoremap s :call vm#commands#visual_cursors()<CR>
            nnoremap ss :call vm#commands#add_cursor_at_pos(0)<CR>
            nnoremap sp :call vm#commands#seek_up()<CR>
            nnoremap sn :call vm#commands#seek_down()<CR>

        " Formatting
            function! FormatFile()
                if index(['javascript', 'typescript', 'typescriptreact', 'html', 'scc', 'scss', 'sass'], &ft) >= 0
                    Prettier
                else
                    let saveview = winsaveview()
                    norm! gg=G
                    call winrestview(saveview)
                endif
            endfunction

            nnoremap <LEADER>= <CMD>call FormatFile()<CR>
            autocmd! FileType json nnoremap <LEADER>= <CMD>%!jq<CR>
            autocmd! FileType jsonc nnoremap <LEADER>= <CMD>%!jq<CR>

    " Buffer related maps
        " Buffers navigation 
            " nnoremap <Tab> <CMD>bnext<CR>
            " nnoremap <S-Tab> <CMD>bprev<CR>
            nnoremap <Tab> <CMD>call lightline#bufferline#next()<CR>
            nnoremap <S-Tab> <CMD>call lightline#bufferline#prev()<CR>
            " nnoremap <Tab> <CMD>b#<CR>
            " nnoremap <S-Tab> <CMD>:Buffers<CR>

        " Buffer management
            nnoremap <LEADER>q <CMD>call lightline#bufferline#remove()<CR>
            " nnoremap <LEADER>q <CMD>bprev<BAR>bd#<CR>
            nnoremap <LEADER>Q <CMD>bd<CR>

    " New Ideas
        " Pack / unpack
            nnoremap <LEADER><CR> <CMD>call Unpack()<CR>
            nnoremap <LEADER><BS> <CMD>call Pack()<CR>

        " Fast insert mode
            nnoremap <LEADER>b bi
            nnoremap <LEADER>i bi
            nnoremap <LEADER>B Bi
            nnoremap <LEADER>I Bi
            nnoremap <LEADER>e ea
            nnoremap <LEADER>a ea
            nnoremap <LEADER>E Ea
            nnoremap <LEADER>A Ea
            nnoremap <LEADER>. f.a

        " Double Tap shortcut
            " inoremap )) (<CMD>call SmartJumpToEnd()<CR><RIGHT>)
            " inoremap ]] [<CMD>call SmartJumpToEnd()<CR><RIGHT>]
            " inoremap }} {<CMD>call SmartJumpToEnd()<CR><RIGHT>}
            " inoremap )<TAB> (<CMD>call SmartJumpToEnd()<CR><RIGHT>)
            " inoremap ]<TAB> [<CMD>call SmartJumpToEnd()<CR><RIGHT>]
            " inoremap }<TAB> {<CMD>call SmartJumpToEnd()<CR><RIGHT>}

        " Backspace selector
            function! BSOperator()
                exe"norm!V\<ESC>"
                call setpos("'<", getpos('.'))
                call search('[{\[(]$', 'W')
                norm!%
                call setpos("'>", getpos('.'))
                norm!gv
            endfunction
            onoremap <BS> <CMD>call BSOperator()<CR>
            xnoremap <BS> <CMD>call BSOperator()<CR>

        " Paste selector
            nnoremap >p mm`[>`]`m
            nnoremap <p mm`[<`]`m
            " nnoremap dp '[d']
            nnoremap =p mm`[=`]`m

        " Easy delete until...
            nnoremap v; vt;
            nnoremap v: vt:
            nnoremap v) vt)
            nnoremap v} vt}
            nnoremap v> vt>
            nnoremap v] vt]
            nnoremap v. vt.
            nnoremap v" vt"
            nnoremap v' vt'
            nnoremap v, vt,
            onoremap ; t;
            onoremap : t:
            onoremap ) t)
            onoremap b t)
            onoremap <S-b> t}
            onoremap ( t(
            onoremap } t}
            onoremap { t{
            onoremap > t>
            onoremap ] t]
            onoremap . t.
            onoremap " t"
            onoremap ' t'
            onoremap , t,
            nnoremap c= ^<CMD>call search('= \?\zs\\|$')<CR>mm<CMD>call search('[;,]\?$')<CR>mn`mc`n
            nnoremap d= ^<CMD>call search('= \?\zs\\|$')<CR>mm<CMD>call search('[;,]\?$')<CR>mn`md`n

        " Until MAJ or underscore
            nnoremap dq mm<CMD>call search('\u\\|\>\\|_')<CR>d`m
            nnoremap cq mm<CMD>call search('\u\\|\>\\|_')<CR>c`m
            " inoremap <C-q> <SPACE><LEFT><CMD>exe "norm!mm" <BAR> call search('\u\<BAR>\<\<BAR>_\zs\w', 'b') <BAR> exe "norm!d`m"<CR><DEL>

        " Delete after cursor in insert
            inoremap <C-e> <CMD>norm!de<CR>

        " semi-column things
            inoremap ;; <CMD>call setline('.', getline('.') . ';')<CR>
            inoremap ;a <C-o>A
            inoremap ;. <CMD>norm!$<CR><RIGHT>.
            inoremap ;, <C-o>A,

        " select multiple lines in a VSCode Style
            nnoremap <CS-DOWN> <C-v>j
            nnoremap <CS-UP> <C-v>k
            xnoremap <CS-DOWN> j
            xnoremap <CS-UP> k
            xnoremap <LEADER>i I
            xnoremap <LEADER>a A
            xnoremap <LEADER>I ^I
            xnoremap <LEADER>A $A

        " Around selection, completes the vim-surround plugin
            xmap m S
            xnoremap m/ c//<ESC>P
            xnoremap m_ c__<ESC>P
            xnoremap m+ c++<ESC>P
            xnoremap m. c..<ESC>P
            xnoremap m<SPACE> c<SPACE><SPACE><ESC>P
            xnoremap m<BS> dvhpgv

        " Smallest range possible
            onoremap io <CMD>call SelectSmallestRangePossible(0)<CR>
            onoremap ao <CMD>call SelectSmallestRangePossible(1)<CR>
            xnoremap io <ESC>:call SelectSmallestRangePossible(0)<CR>
            xnoremap ao <ESC>:call SelectSmallestRangePossible(1)<CR>

" 
" AUTOCMD
" 
    " go to insert mode when open terminal window
        autocmd TermEnter,TermOpen * startinsert | set nonu
        autocmd TermLeave * stopinsert | set nu
        autocmd TermClose * call feedkeys("\<SPACE>") | set nu


    " taking back position at buffer open
        autocmd BufReadPost * silent!norm!g;
        autocmd BufLeave * call AutoSaveWinView()
        autocmd BufEnter * call AutoRestoreWinView()

    " Correcting bad commenting for specific languages | Plugin: Commentary
        autocmd! FileType php let b:commentary_format="// %s"
        autocmd! FileType python let b:commentary_format="# %s"
        autocmd! FileType sh let b:commentary_format="# %s"
        autocmd! FileType dockerfile let b:commentary_format="# %s"
        autocmd! FileType vue let b:commentary_format="// %s"
        autocmd! FileType typescript let b:commentary_format="// %s"
        autocmd! FileType typescriptreact let b:commentary_format="// %s"
        autocmd! FileType sql let b:commentary_format="-- %s"
        autocmd! FileType coffee let b:commentary_format="# %s"
        autocmd! FileType conf let b:commentary_format="# %s"
        autocmd! FileType vim let b:commentary_format="\" %s"
        autocmd! FileType yaml let b:commentary_format="# %s"
        autocmd! FileType journal let b:commentary_format="-- %s"
        autocmd! FileType matlab let b:commentary_format="% %s"

    " Auto detecting indent on entering a file! | Plugin: vim-adaptive-indent
        autocmd BufReadPost * AdaptIndent
        " autocmd BufEnter * set tabstop=4

    " Language specific maps
        function! CloseXmlTag()
            call search('<', 'b')
            let col = col('.')
            let tag = matchstr(getline('.'), '\%'.col.'c<\zs.\{-}\ze\%(\s\|>\|$\)')
            call search('>', '')
            let col = col('.')
            let line = getline('.')
            call setline(line('.'), getline('.')[:col-1] . '</'.tag.'>' . getline('.')[col:])
            call setpos('.', [0, line('.'), col + 1, 0])
        endfunction
        autocmd FileType html,php,javascript,typescriptreact,javascriptreact inoremap >> <CMD>call CloseXmlTag()<CR>

    " Correcting FZF buffer | Plugin: FZF
        autocmd! FileType fzf
        autocmd  FileType fzf set laststatus=0 noshowmode noruler
          \| autocmd BufLeave <buffer> set laststatus=2 showmode ruler

    " refreshing file when modified outside of vim
        autocmd BufEnter * checktime
        autocmd FocusGained * checktime
        autocmd BufWritePost * GitGutter

    " Unsupported files formats
        autocmd BufEnter *.json set filetype=jsonc
        autocmd BufEnter *.abnf set filetype=abnf
        autocmd BufEnter *.flux set filetype=flux
        autocmd BufEnter *.fish set filetype=fish
        autocmd BufNewFile,BufRead *.vue set filetype=vue
        autocmd BufNewFile,BufRead *.coffee set filetype=coffee
        autocmd BufNewFile,BufRead *.jrl set filetype=journal
        autocmd BufNewFile,BufRead *.txt set filetype=txt
        autocmd BufNewFile,BufRead *.snippets set filetype=snippets
        autocmd BufNewFile,BufRead *.nim set filetype=nim
        autocmd BufNewFile,BufRead Jenkinsfile set filetype=groovy

    " Update custom mappings after everything else has been done
        autocmd VimEnter * call UpdateMappings()

    " Highlight current selection
        let s:last_mode = 'n'
        let s:sel_matches = ''
        hi SelectionOthers cterm=bold,underline ctermbg=NONE ctermfg=none gui=bold,underline guibg=NONE guifg=none
        function! SelectionToRx(selText)
            return substitute(escape(a:selText, '/\\^$*.[~'), '\%(\s\|\n\)\+', '\\%(\\s\\|\\n\\)\\+', 'g')
        endfunction
        function! HighlightSel()
            sil!call matchdelete(s:sel_matches)
            sil!exe "norm!\"aygv"
            let s:sel_matches = matchadd('SelectionOthers', SelectionToRx(@a))
        endfunction
        function EnterVisual()
            aug VisualHi
                autocmd!
                autocmd CursorMoved * call HighlightSel()
            aug END
        endfunction
        function LeaveVisual()
            sil!call matchdelete(s:sel_matches)
            aug VisualHi
                autocmd!
            aug END
        endfunction
        function ModeChanged()
            let curmode = mode()
            let s:last_mode = curmode

            if curmode == 'v'     | call EnterVisual()
            elseif curmode == 'n' | call LeaveVisual()
            endif
        endfunction
        autocmd CursorMoved * if mode() != s:last_mode | call ModeChanged() | endif

" 
" ABREVS
" 
    " Comments shortcut
        iab /// //<ENTER><C-o>O

    " Mistypes
        iab cnosole console
        iab cnosoel console
        iab cnsole console
        iab loaction location
        iab loaciton location 

    " French Accents
        iab etre être
        iab occupee occupée
        iab entete entête
        iab entetes entêtes
        iab requete requête
        iab etudiant étudiant
        iab etudiants étudiants
        iab ecole école
        iab ecoles écoles
        iab etais étais
        iab etait était
        iab implemente implémente
        iab implementation implémentation

    " Unicode
        iab \> ➤
        iab \\> ⤷
        iab \! ⚠



function! WrapLine(num)
    while len(getline('.')) > 81
        norm! ^
        let pos = col('.')
        call setpos('.', [0, line('.'), pos+a:num, 0])
        call search('\S\s', 'bW')
        if pos > col('.')
            break
        endif
        exe "norm! a\<CR>\<ESC>"
    endwhile
endfunction

nnoremap gqq <CMD>call WrapLine(81)<CR>


function! CopyWord(lnum, full_line)
    let lnum = line('.') + a:lnum

    if lnum > line('$') | let lnum = line('$') | endif
    if lnum < 0 | let lnum = 0 | endif

    if a:lnum < 0
        let lnum = prevnonblank(lnum)
    else
        let lnum = nextnonblank(lnum)
    endif
    let cnum = col('.')

    let line = getline(lnum)

    if a:full_line
        call setline('.', getline(lnum))
        call setpos('.', [0, line('.'), col('$'), 0])
        return ''
    endif

    let cara = matchstr(line, '\%'.cnum.'c.')

    if match(cara, '[a-zA-Z0-9_]') >= 0
        return matchstr(line, '\%([^a-zA-Z0-9_]\|^\)[a-zA-Z0-9_]\{-}\zs\%'.cnum.'c[a-zA-Z0-9_]\{-}\ze\%([^a-zA-Z0-9_]\|$\)')
    endif

    return cara
endfunction

inoremap <silent> <S-UP> <C-r>=CopyWord(-1, 0)<CR>
inoremap <silent> <S-DOWN> <C-r>=CopyWord(1, 0)<CR>
inoremap <silent> <CS-UP> <C-r>=CopyWord(-1, 1)<CR>
inoremap <silent> <CS-DOWN> <C-r>=CopyWord(1, 1)<CR>

function! HandleSig()
    let errFile = system('cat /tmp/vim_sig.txt')
    let errFile = trim(errFile)
    call ParseErrorLine(errFile)
endfunction
autocmd Signal SIGUSR1 call HandleSig()

function! SearchQuotePair(cara)
    if !IsSyn('string', line('.'), col('.')-1) && IsSyn('string', line('.'), col('.')+1)
        call search(a:cara)
    elseif IsSyn('string', line('.'), col('.')-1) && !IsSyn('string', line('.'), col('.')+1)
        call search(a:cara, 'b')
    else
        " No string, we count the amount of characters before cursor
        let line = getline('.')[:col('.') - 1]
        let cnt = 0
        for cara in split(line, '\ze.')
            if cara == a:cara
                let cnt += 1
            endif
        endfor
        if cnt % 2 == 0
            call search(a:cara, 'b')
        else
            call search(a:cara)
        endif
    endif
endfunction
function! SearchPair()
    let save = winsaveview()
    " For comments, putting cursor in proper place
    call search('\*\%#\/', 'b')
    if !search('[''"`}{\]\[()<>]\|/\*\*\|\*/', 'cW')
        return
    endif

    let cara = getline('.')[col('.')-1]

    if match(cara, '[''"`]') >= 0
        call SearchQuotePair(cara)
    else
        norm!%
    endif
endfunction
