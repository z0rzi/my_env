" 
" GENERAL NATIVE VIM SETTINGS
" 
    " filetype plugin indent off
    syn on
    filetype on
    set nu
    set nosol
    set wrap
    set linebreak
    set breakindent
    set ruler
    set hidden
    " set updatetime=1000
    set showtabline=2  " always show tabline
    set noshowmode
    set nobackup
    set nowritebackup
    set updatetime=1000
    set shortmess+=c
    set diffopt=context:15
    set diffopt+=internal
    set diffopt+=algorithm:patience
    set diffopt+=indent-heuristic
    set diffopt+=filler
    set diffopt+=vertical
    set signcolumn=yes
    " set termguicolors  " Increases the saturation
    set previewheight=5

    " different cursors in different modes
        let &t_SI = "\<Esc>[6 q"
        let &t_SR = "\<Esc>[4 q"
        let &t_EI = "\<Esc>[2 q"
        set timeoutlen=1000 ttimeoutlen=0

    set ve=block
    set hlsearch
    set incsearch

    set smartindent
    set autoindent

    set wildmenu
    set showcmd
    set scrolloff=5
    " set relativenumber
    set conceallevel=2
    set nostartofline
    set mouse=a

    set formatoptions=cro
    set clipboard=unnamedplus

    set swapfile
    set dir=/tmp
    set modeline

    " to refresh file on git checkout
        set autoread

    set tabstop=4 shiftwidth=4 expandtab

    " Considering '-' as part of a word
        set iskeyword+=-

    " Disable freaking sql completion
        let g:omni_sql_no_default_maps = 1

    " change the leader key to <space>
        let g:mapleader = "\<Space>"
    " Don't conceal markdown
        let g:vim_markdown_conceal_code_blocks=0
        let g:vim_markdown_conceal=0

" 
" LOOKS AND FEEL
" 
    " General
        colorscheme gruvbox
        set fillchars=stl:\ ,stlnc:=,vert:│,fold:\ ,diff:-
        set listchars=tab:.\ , list

    " Folding
        set foldlevelstart=99
        set foldmethod=expr
        set foldexpr=FoldLevel(v:lnum)
        set foldtext=NeatFoldText()

    " GruvBox config
        let g:gruvbox_italic = 1
        let g:gruvbox_undercurl = 1
        let g:gruvbox_termcolors = 256
        let g:gruvbox_contrast_dark = "medium"
        let g:gruvbox_italicize_strings = 1
        let g:gruvbox_invert_selection = 0
        let g:gruvbox_invert_signs = 0  " for GitGutter signs
        let g:gruvbox_guisp_fallback = 'bg'

    " GVim
        set guioptions-=m  "remove menu bar
        set guioptions-=T  "remove toolbar
        set guioptions-=r  "remove right-hand scroll bar
        set guioptions-=L  "remove left-hand scroll bar
        set background=dark

    " language specific
        " python
            " let g:python_highlight_all
            let g:python_highlight_builtin_funcs=1
            let g:python_highlight_builtin_objs=1
            let g:python_highlight_builtins=1
            let g:python_highlight_doctests=1
            let g:python_highlight_exceptions=1
            let g:python_highlight_file_headers_as_comments=1
            let g:python_highlight_indent_errors=0
            let g:python_highlight_space_errors=0
            let g:python_highlight_string_format=1
            let g:python_highlight_string_formatting=1
            let g:python_highlight_string_templates=1
            let g:python_print_as_function=1
            let g:python_slow_sync=0
            let g:python_version_2=0

" 
" FUNCTIONS
" 
    let g:mappings = {}
    function! UpdateMappings()
        if ! exists('g:mappings') | let g:mappings = {} | endif
        for mode in keys(g:mappings)
            for cmd in keys(g:mappings[mode])
                " Destroying existing mappings
                let old_map = maparg(cmd, mode)
                if old_map != ''
                    sil!exe mode[0]."unmap ".cmd
                    sil!exe mode[0]."unmap <buffer> ".cmd
                endif

                let escaped_cmd = substitute(cmd, '<', '</', 'g')
                " Setting up new mapping
                if match(mode, '^i') >= 0
                    exe mode."map <silent> ".cmd." <C-r>=ExeMap('".mode."', '".escaped_cmd."')<CR>"
                else
                    exe mode."map <silent> ".cmd." <CMD>call ExeMap('".mode."', '".escaped_cmd."')<CR>"
                endif
            endfor
        endfor
    endfunction
    function! AddMapping(mode, cmd, code)
        if ! exists('g:mappings')               | let g:mappings = {}                | endif
        if ! has_key(g:mappings, a:mode)        | let g:mappings[a:mode] = {}        | endif
        if ! has_key(g:mappings[a:mode], a:cmd) | let g:mappings[a:mode][a:cmd] = [] | endif
        call add(g:mappings[a:mode][a:cmd], a:code)
    endfunction
    function! ExeMap(mode, cmd, ...)
        if ! has_key(g:mappings, a:mode)
            return ''
        endif
        let cmd = substitute(a:cmd, "</", "<", "g")
        if ! has_key(g:mappings[a:mode], cmd)
            return ''
        endif
        let codes = g:mappings[a:mode][cmd]
        if match(a:mode, '^i') >= 0
            " insert mode

            let cnt_per_cmd = get(a:, 2, 0)

            if len(codes) <= cnt_per_cmd
                return RepairSpecial(cmd)
            endif

            let cara = eval(codes[cnt_per_cmd])
            let cara = substitute(cara, " ", "<SPACE>", "g")

            if cara == cmd
                let cnt_per_cmd += 1
            else
                let cnt_per_cmd = 0
            endif

            let cnt_total = get(a:, 1, 0)
            if cnt_total < 10
                let res = ExeMap(a:mode, substitute(cara, '<', '</', 'g'), cnt_total+1, cnt_per_cmd)
                if res != ''
                    return RepairSpecial(res)
                endif
            endif
            return RepairSpecial(cara)
        else
            for code in codes
                exe code
            endfor
            return ''
        endif
    endfunction
    function! RepairSpecial(str)
        let str = substitute(a:str, '<', '\\<', 'g')
        let str = substitute(str, '"', '\\"', 'g')
        return eval('"'.str.'"')
    endfunction
    function! RestrictSearch(flag)
        let cursearch = @/
        let save = winsaveview()

        " let cara = matchstr( a:line, '\S\ze\s' )
        let start = matchstr(cursearch, '\\%>\zs\d\+\zel')
        let end = matchstr(cursearch, '\\%<\zs\d\+\zel')
        let search = substitute(cursearch, '\\%[<>]\d\+l', '', 'g')

        if a:flag == 0
            let @/ = search
            return
        endif

        if a:flag < 0
            if !end
                let end = line('.') + 1
            endif
            if start
                call setpos('.', [0, start + 1, 0, 0])
            endif
            call search(search, 'bW')
            let start = line('.') - 1
        else
            if !start
                let start = line('.') - 1
            endif
            if end
                call setpos('.', [0, end, 0, 0])
            endif
            call search(search, 'W')
            let end = line('.') + 1
        endif

        call winrestview(save)

        let @/ = '\%>'.start.'l\%<'.end.'l'.search
        " call histadd('/', @/)
    endfunction

    function! DoAtEach(macro, range)
        echom a:macro
        let save = winsaveview()
        let count = 0
        let searchSave = @/
        let selSave = [ getpos("'<"), getpos("'>") ]
        if a:range < 0
            " Match mode
            call setpos('.', [0, 1, 1, 0])

            " Counting number of matches
            let matchnr = 0
            while search(@/, 'W') | let matchnr += 1 | endwhile
            call setpos('.', [0, 1, 1, 0])
            call search(@/, 'W')
            exe "norm!\<BS>"
            let @/ = substitute(@/, '\\%[<>]\d\+l', '', 'g')
            let searchSave = @/

            while search(@/, 'W') && matchnr > 0
                exe "exe \"norm! " . substitute(substitute(a:macro, '<>', '\<ESC>', 'g'), '<[a-zA-Z-]\+>\|"', '\\&', 'gi') . '"'

                let @/ = searchSave
                call setpos("'<", selSave[0])
                call setpos("'>", selSave[1])

                let matchnr -= 1
            endwhile
        else
            " Visual Mode
            call setpos('.', getpos("'<"))
            let botline = line("'>")
            while line('.') <= botline

                let col = col('.')
                exe "exe \"norm! " . substitute(substitute(a:macro, '<>', '\<ESC>', 'g'), '<[a-zA-Z-]\+>\|"', '\\&', 'gi') . '"'
                if line('.') == line('$')
                    break
                endif
                call setpos('.', [0, line('.')+1, col, 0])
                " norm!j

                let @/ = searchSave
                call setpos("'<", selSave[0])
                call setpos("'>", selSave[1])

                let count += 1
                if count > 10000
                    break
                endif
            endwhile
            " norm!gv
        endif

        call winrestview(save)
    endfunction
    command! -range -nargs=+  MacroToAll call DoAtEach(<q-args>, '<count>')
    command! -range -nargs=+  M call DoAtEach(<q-args>, '<count>')

    function! ParseErrorLine(errLine)
        let data = split(a:errLine, ':')
        let filename = remove(data, 0)
        if len(data) > 0
            let line = remove(data, 0)
        else
            let line = 1
        endif
        if len(data) > 0
            let column = remove(data, 0)
        else
            let column = 1
        endif
        exe "edit ".filename
        call cursor(line, column)
        filetype detect
        redraw!
    endfunction
    command! -nargs=+  Err call ParseErrorLine('<args>')

    function! ComparePositions(p1, p2)
        let linediff = a:p2[0] - a:p1[0]
        let coldiff = a:p2[1] - a:p1[1]
        return linediff + (!linediff) * coldiff
    endfunction

    function! CursorOnMatch(searchPattern)
        let position = getcurpos()[1:2]
        let curpos = getpos('.')
        call setpos('.', [0] + position + [0])

        let pos = searchpos(a:searchPattern, 'ec')

        if pos == [0,0] || ComparePositions(position, pos) < 0
            call setpos('.', curpos)
            return 0
        endif


        let pos = searchpos(a:searchPattern, 'bnc')

        if pos == [0,0] || ComparePositions(pos, position) < 0
            call setpos('.', curpos)
            return 0
        endif

        call setpos('.', curpos)
        return 1
    endfunction

    function! EOL()
        call setpos('.', [0, line('.'), col('$'), 0, col('$')])
    endfunction

    function! CursorInFileWindow()
        let notFile = {
            \   'filetype' : [
            \     'qf'      , 'vimpager', 'undotree', 'tagbar',
            \     'nerdtree', 'vimshell', 'vimfiler', 'voom'  ,
            \     'tabman'  , 'unite'   , 'quickrun', 'Decho',
            \     'fzf'
            \   ],
            \   'bufname' : [
            \     'GoToFile'                  , 'diffpanel_\d\+'      ,
            \     '__Gundo_Preview__'         , '__Gundo__'           ,
            \     '\[LustyExplorer-Buffers\]' , '\-MiniBufExplorer\-' ,
            \     '_VOOM\d\+$'                , '__Urannotate_\d\+__' ,
            \     '__MRU_Files__', '.*FZF'
            \   ]
            \ }

        if index(notFile.filetype, &ft) != -1 ||
                    \ len(&buftype)
            return 0
        endif
        let bufname = buffer_name()
        for rx in notFile.bufname
            if len(matchstr(bufname, rx))
                return 0
            endif
        endfor
        return 1
    endfunction

    function! SmartJumpToEnd()
        if search('\%#.\?$', 'n') != 0
            call setpos("'m", getpos('.'))
            call search('^\(\s\+\).*\%#.*\n\(\1.*\n\)*\zs\1')
            call append('.', repeat(' ', indent('.')))
            norm!j
            call setpos("'n", getpos('.'))
            norm!=`m`n
            call EOL()
        else
            let pos = search('\%#.\{-}\zs[\[\](){}]')

            if pos == 0
                call search('.;\?$')
            elseif search('\%#[[({]') != 0
                " Opening tag
                norm!%
            else
                " Closing tag
                norm!h
            endif
        endif
    endfunction

    function! MapToNextMove(cmd)
        let cmd = escape(a:cmd, '\\"')
        sil!exe "aug nextmove \<BAR>" .
                    \ "autocmd CursorMoved * :sil!exe \"" . cmd . "\\<BAR> aug nextmove \\<BAR> au! \\<BAR> aug END \\<BAR> aug! nextmove\" \<BAR>"
                    \ "aug END"
    endfunction

    function! DuplicateLines(type, ...)
        if a:0
            " We're in visual mode
            if visualmode() == 'v'
                exe 'normal! "my"mPgv'
            else
                exe "normal! :co '<-1\<CR>gv"
            endif
        else
            '[,'] copy '[-1
            call setpos('.', [0, line("']")+1, 1000, 0])
        endif
    endfunction

    function! GetGroupName()
        if !exists("*synstack" )
            return
        endif
        echo map(synstack(line('.'), col('.')), 'synIDattr(v:val, "name" )')
    endfunction

    function! FoldLevel(lnum)
        return indent(nextnonblank(a:lnum)) / getbufvar('.', '&tabstop', 1)
    endfunction

    function! NeatFoldText()
        let foldchar         = matchstr(&fillchars, 'fold:\zs.')
        let lines_count      = v:foldend - v:foldstart + 1
        let lines_count_text = printf("┈─ %1s lines ─┈", lines_count) . repeat(foldchar, 10)
        let foldtextstart    = repeat(' ', indent(nextnonblank(v:foldstart))) . " ••• " 
        let foldtextend      = lines_count_text . repeat(foldchar, 8)
        let foldtextlength   = strlen(substitute(foldtextstart . foldtextend, '.', 'x', 'g')) + &foldcolumn

        return foldtextstart . repeat(foldchar, winwidth(0) - foldtextlength) . foldtextend
    endfunction

    function! EatNChars(num)
        let l:number = a:num
        let l:string = ""

        while l:number > 0
            let l:string .= nr2char(getchar())
            let l:number -= 1
        endwhile

        return ''
    endfunction

    function! CountBefore(rx, until_pos)
        let save = winsaveview()
        let count=0
        while search(a:rx, 'Wb', a:until_pos[0])
            if col('.') > a:until_pos[1]
                let count += 1
            else
                break
            endif
        endwhile
        call winrestview(save)
        return count
    endfunction

    function! FindNextCouple(couple, reverse)
        if a:reverse && CursorOnMatch(a:couple[0]) || ! a:reverse && CursorOnMatch(a:couple[1])
            let pos = getpos('.')[1:2]
            return pos
        endif
        let save = winsaveview()
        let stack = 0
        if a:reverse
            let flags = 'Wb'
        else
            let flags = 'W'
        endif
        while search(a:couple[0].'\|'.a:couple[1], flags)
            if CursorOnMatch(a:couple[0])
                let stack += 1
            else
                let stack -= 1
            endif
            if a:reverse && stack > 0 || !a:reverse && stack < 0
                break
            endif
        endwhile
        let pos = getpos('.')[1:2]
        call winrestview(save)
        return pos
    endfunction

    function! FindSmallestRangePossible(in)
        let couples = [
                    \   ['['         , ']'         , 1],
                    \   ['<'         , '>'         , 1],
                    \   ['{'         , '}'         , 1],
                    \   ['('         , ')'         , 1],
                    \   ['\/\*'      , '\*\/'      , 1],
                    \   ['"'         , '"'         , 0],
                    \   ["'"         , "'"         , 0],
                    \   ['[^`]`[^`]' , '[^`]`[^`]' , 1],
                    \   ['`'         , '`'         , 1],
                    \ ]
        let best_before = [0, 0]
        let best_after = [0, 0]
        let best_couple = []

        let save = winsaveview()
        for couple in couples
            let [start, end, wraps] = couple
            let before = searchpos(start, 'Wbnc')
            let after = searchpos(end, 'Wnce')
            
            if before == [0, 0] || after == [0, 0]
                continue
            endif

            if before == after
                let limit_line = 0
                if !wraps | let limit_line = line('.') | endif
                if CountBefore(start, [limit_line, 0]) % 2 == 0
                    call setpos('.', [0, line('.'), col('.')+1, 0])
                else
                    call setpos('.', [0, line('.'), col('.')-1, 0])
                endif
                let before = searchpos(start, 'Wbnc')
                let after = searchpos(end, 'Wnce')
            endif

            if best_before == [0, 0] || best_after == [0, 0] || ( 
                \   ComparePositions(best_before, before)>0
                \   && ComparePositions(after, best_after)>0
                \ )
                if start == end
                    let limit_line = 0
                    if !wraps | let limit_line = line('.') | endif
                    if CountBefore(start, [limit_line, 0]) % 2 == 0
                        continue
                    endif
                else
                    let _before = FindNextCouple(couple, 1)
                    let _after = FindNextCouple(couple, 0)
                    if _before == before
                        let after = _after
                    elseif _after == after
                        let before = _before
                    else
                        continue
                    endif
                endif
                let best_before = before
                let best_after = after
                let best_couple = couple
            endif
            call winrestview(save)
        endfor

        if best_before == [0, 0] || best_after == [0, 0]
            return [0]
        endif

        if (a:in)
            call setpos('.', [0] + best_before + [0])
            call search(best_couple[0], 'ecW')
            call search('\s*[^[:blank:]]\|^')
            let best_before = getpos('.')[1:2]

            call setpos('.', [0] + best_after + [0])
            call search(best_couple[1], 'bcW')
            call search('[^[:blank:]]\s*\|$', 'be')
            let best_after = getpos('.')[1:2]
            call winrestview(save)
        endif

        return [best_before, best_after, best_couple]
    endfunction

    function! SelectSmallestRangePossible(external)
        let res = FindSmallestRangePossible(! a:external )
        if res == [0]
            return
        endif
        call setpos("'<", [0] + res[0] + [0])
        call setpos("'>", [0] + res[1] + [0])
        norm!gv
        if mode() == 'V'
            norm!v
        end
    endfunction

    function! VimToGrepRegex(str)
        let rx = a:str

        let gargs = ""

        let rx = substitute(rx, '\\<\|\\>','\\b', 'g')

        if rx =~ '\\c'
            let rx = substitute(rx, '\\c','', '')
            let gargs .= " -i"
        endif

        return [rx, gargs]
    endfunction

    let s:fzf_options = 
                \ '--tiebreak=index ' .
                \ '--filepath-word ' .
                \ '--history /home/zorzi/.local/share/fzf-history/FZF ' .
                \ '--algo=v2 ' .
                \ '--keep-right ' .
                \ '--multi ' .
                \ '--preview="bash -c \"[ \\\"\\\$(git ls-files -m {})\\\" ] && flag=-d; bat --color always \\\$flag {} | tail -n+2\"" ' .
                \ '--preview-window="right:50%:rounded:nowrap:nofollow:nocycle:nohidden" ' .
                \ '--sync'
                " \ '--no-sort ' .
                " \ '-e ' .
                " \ '--preview="[ \"$(git ls-files -m ''{}'')\" ] && bash -c \"bat -d --color always {} | tail -n+2\" || bat {}" ' .
                " \ '--preview="git diff --color=always {} | sed -e \"1,5d\" -e \"s/^\s\+//g\" | diff-so-fancy" ' .
    function! FZFFindFile()
        let cmd = 'ls --color=never -t $(rg . --files) 2> /dev/null'
        silent! exe fzf#run({'source': cmd, 'sink': 'e', 'options': s:fzf_options, 'down':'40%'})
    endfunction
    function! s:FZFOpenVimOutput(str)
        let thefile = matchstr(a:str, '^.\{-\}\ze:')
        let theline = matchstr(a:str, '^.\{-\}:\zs\d\+\ze:')
        silent! exe 'edit ' . fnameescape(thefile)
        echo cursor(theline,0)
    endfunction
    function! s:FZFPrintUnicode(line)
        let cara = matchstr( a:line, '\S\ze\s' )
        exe 'silent !grep "^'.cara.'" $HOME/.vim/customFiles/unicode_chars.txt > /tmp/unicode_temp.txt'
        exe 'silent !grep -v "^'.cara.'" $HOME/.vim/customFiles/unicode_chars.txt >> /tmp/unicode_temp.txt'
        exe 'silent !mv /tmp/unicode_temp.txt $HOME/.vim/customFiles/unicode_chars.txt'
        exe "norm!i" . cara
    endfunction
    function! FZFUnicode()
        let cmd = 'cat $HOME/.vim/customFiles/unicode_chars.txt'
        call fzf#run({'source': cmd, 'sink': function('s:FZFPrintUnicode'), 'options': '-e --algo=v1 --no-sort --ansi', 'down':'40%' })
    endfunction

    " Save current view settings on a per-window, per-buffer basis.
    function! AutoSaveWinView()
        if !exists("w:SavedBufView")
            let w:SavedBufView = {}
        endif
        let w:SavedBufView[bufnr("%")] = winsaveview()
    endfunction
    " Restore current view settings.
    function! AutoRestoreWinView()
        let buf = bufnr("%")
        if exists("w:SavedBufView") && has_key(w:SavedBufView, buf)
            let v = winsaveview()
            let atStartOfFile = v.lnum == 1 && v.col == 0
            if atStartOfFile && !&diff
                call winrestview(w:SavedBufView[buf])
            endif
            unlet w:SavedBufView[buf]
        endif
    endfunction

    function! GetHighlightProps(grpName)
        " Saving linting colors, for the function
        let grpID = synIDtrans(hlID(a:grpName))

        let baseProperties = [ "bold", "italic", "reverse", "inverse", "standout", "underline", "undercurl", "strikethrough" ]
        let base = []

        for prop in baseProperties
            if synIDattr(grpID, prop) == '1'
                let base += [prop]
            endif
        endfor
        let base = join(base, ',')

        return {
                    \ 'name': a:grpName,
                    \ 'fg': synIDattr(grpID, "fg"),
                    \ 'bg': synIDattr(grpID, "bg"),
                    \ 'base': base
                    \ }
    endfunction

    function! FloatingMessage(message)
        let bufnr = nvim_create_buf(v:false, v:true)
        call setbufvar(bufnr, '&signcolumn', 'no')

        let message = ' -- ' . a:message

        let winheight = 1
        let winwidth = len(message)

        let width = float2nr(winwidth - (winwidth*2/10))

        let opts = {
                    \ 'relative': 'cursor',
                    \ 'row': 0,
                    \ 'col': col('$') - col('.') + 4,
                    \ 'focusable': 0,
                    \ 'width': winwidth,
                    \ 'height': 1,
                    \ 'style': 'minimal'
                    \ }

        call appendbufline(bufnr, 0, message)

        let winnr = nvim_open_win(bufnr, v:false, opts)

        let props = GetHighlightProps('Normal')

        exe "hi Pop cterm=italic ctermbg=" . props.bg . " ctermfg=245"
        call setwinvar(winnr, '&winhighlight', 'NormalFloat:Pop')

        call MapToNextMove('exe "norm!:bd!' . bufnr . '\<CR>"')
    endfunction

    function! GitBlame()
        let line=line('.')
        let truefile = system('readlink -f ' . expand('%'))
        let truepath = matchstr(truefile, '^.*/', '')
        let cmd = 'cd '.truepath.' && git blame -p -L '.line.','.line.' '.truefile
        let res = systemlist(cmd)

        let author = ''
        let summary = ''
        let time = ''
        for line in res
            if match(line, 'author ') == 0
                let author = substitute(line, '^\S*\s*', '', '')
            endif
            if match(line, 'summary ') == 0
                let summary = substitute(line, '^\S*\s*', '', '')
            endif
            if match(line, 'author-time ') == 0
                let time = substitute(line, '^\S*\s*', '', '')
            endif
        endfor

        let time = EpochToRelative(time)

        call FloatingMessage(author . ' ) ' . time . ' | ' . summary)
    endfunction

    function! EpochToRelative(epoch)
        let now = system('date +"%s"')
        let diff = now - a:epoch

        let units = ['year', 'month', 'day', 'hour', 'minute', 'second']
        let values = [1] " second
        call insert(values, values[0] * 60) " minute
        call insert(values, values[0] * 60) " hour
        call insert(values, values[0] * 24) " day
        call insert(values, values[0] * 31) " month
        call insert(values, values[1] * 365) " year

        let out = ''
        let cnt = 0
        let yes = 0
        while cnt < len(values)
            let nb = diff / values[cnt]
            let diff -= nb * values[cnt]
            if nb > 0
                let plural = ''
                if nb > 1 | let plural = 's' | endif
                let out .= nb.' '.units[cnt].plural.', '

                " Max 2 units displayed
                if yes | break
                else | let yes = 1
                endif
            endif
            let cnt += 1
        endwhile

        let out = substitute(out, '[[:blank:],]\+$', '', '') . ' ago'

        return out
    endfunction
    function! WhichBraceAmIIn()
        let matches = {
                    \ '{': '}',
                    \ '(': ')',
                    \ '\[': '\]'
                    \ }

        let closest_brace = [
                    \ [0, 0],
                    \ [0, 0],
                    \ ['', '']
                    \ ]

        for open_cara in keys(matches)
            let close_cara = matches[open_cara]
            let start_pos = searchpairpos(open_cara, '', close_cara, 'bcn')
            if !closest_brace[0][0] || ComparePositions(closest_brace[0], start_pos) > 0
                let end_pos = searchpairpos(open_cara, '', close_cara, 'n')
                let closest_brace = [
                            \ start_pos,
                            \ end_pos,
                            \ [open_cara, close_cara]
                            \ ]
            endif
        endfor

        return closest_brace
    endfunction
    function! Pack()
        let [start_pos, end_pos, chars] = WhichBraceAmIIn()
        if !start_pos[0] || !end_pos[0] | return | endif

        let line_start = start_pos[0]
        let line_end = end_pos[0]

        if line_start >= line_end | return | endif

        exe (line_start).','.(line_end-1).'s/\n//'
        sil!s/\S\zs\s\+/ /g
        sil!s/[\[(]\zs\s\+//g
        sil!s/\s\+\ze[\])]//g

        call cursor(start_pos[0], start_pos[1])
    endfunction

    function! Unpack()
        let [start_pos, end_pos, chars] = WhichBraceAmIIn()
        if !start_pos[0] || !end_pos[0] | return | endif

        let [char_open, char_close] = chars

        call cursor(end_pos[0], end_pos[1])

        exe "norm i\<CR>"

        let next_pos = searchpos('[\])},]', 'nbW')
        let cnt = 200
        while ComparePositions(start_pos, next_pos) > 0
            let cnt -= 1
            if cnt < 0 | break | endif
            call cursor(next_pos[0], next_pos[1])
            let char_now = getline('.')[col('.')-1]
            if char_now == ','
                exe "norm mma\<CR>\<ESC>`m"
            else
                norm!%
            endif

            let next_pos = searchpos('[\])},]', 'nbW')
        endwhile

        call cursor(start_pos[0], start_pos[1])
        exe "norm a\<CR>"
        call cursor(start_pos[0], start_pos[1])
    endfunction

    function! AngularHtmlGotoImplementation()
        let func_name = expand('<cword>')
        let saveview = winsaveview()

        let path = expand('%:h')
        let html_file = expand('%:t')

        if match(html_file, '\.html$') < 0
            " not an HTML file
            return
        endif

        let script_file = ''
        let extensions = ['ts', 'js']
        for ext in extensions
            let script_file = matchstr(html_file, '^.*\.') . ext
            if filereadable(path . '/' . script_file)
                break
            endif
        endfor
        if ! filereadable(path . '/' . script_file)
            return
        endif

        exe 'e ' . path . '/' . script_file

        call cursor(1, 1)
        if ! search('^\s*\%(private\|public\)\?\s*\zs' . func_name . '\ze\s*(')
            exe 'e ' . path . '/' . html_file
            call winrestview(saveview)
        endif
    endfunction
    autocmd! FileType html nnoremap <buffer> <C-]> <CMD>call AngularHtmlGotoImplementation()<CR>

" 
" PLUGINS CONFIG
" 
    " smartHits
        let g:smartHits_should_setup_maps = 0

        call AddMapping('i', '<SPACE>', 'smartHits#smartSpace()')
        call AddMapping('i', '<CR>', 'smartHits#smartCR()')
        call AddMapping('i', '<BS>', 'smartHits#smartBS()')
        call AddMapping('i', '<C-]>', 'smartHits#skip()')

        let g:smartHits_pairs = [
            \ ['(', ')'],
            \ ['[', ']'],
            \ ['{', '}'],
            \ ['<', '>'],
            \ ['/**', '*/'],
            \ ['''', ''''],
            \ ['"', '"'],
            \ ['```', '```'],
            \ ]

        " ^ at start of lhs to only work if match at start of line
        " $ at end of lhs to only work if match at end of line
        " \(...\) in lhs, and $1 in rhs to repeat capture or $& to repeat full match
        let g:smartHits_abbrevs = {
            \   'vim': {
            \     '^l': "let",
            \   },
            \   'html': {
            \     '^\%(div\|span\|table\|h\d\)$': "<$&></$&>\<C-o>F<!",
            \     '^\.\.\([[:alnum:]-]\+\)$': "<div class=\"$1\"></div>\<C-o>F<!",
            \     '\[\([[:alnum:]-]\+\)\]\@=': "\<DEL>[$1]=\"\"\<LEFT>!",
            \   },
            \   'javascript': {
            \     'l': "let",
            \     '^iff': "if () {\<CR>}<UP><ESC>f(a!",
            \     '^forr': "for () {\<CR>}<UP><ESC>f(a!",
            \     '\%(for\s*([^)]*\)\@<=in': "of",
            \     '^\(if\|for\|while\|switch\)\s\+\([^([:blank:]][^(]\+\)': "$1 ($2)\<LEFT>",
            \     'c': "const",
            \     'prom': "new Promise((resolve, reject) => {})\<LEFT>\<LEFT>!",
            \     '^ret$': "return",
            \     'req$': "require('')\<LEFT>\<LEFT>!",
            \     'aw': "await",
            \     '^ii': "if(  )\<LEFT>\<LEFT>!",
            \     'ff': "\<ESC>:if match(getline(line('.')), ')$') != -1 \<BAR> call setline('.', getline('.') . ';') \<BAR> endif\<CR>a() => {\<CR>}\<C-o>O!",
            \     '^tryc$': "try {\<ESC>:call SmartJumpToEnd()\<CR>a} catch (err) {\<CR>}\<C-o>O\<SPACE>\<BS>\<C-o>z"
            \   },
            \   'javascriptreact': {
            \     '@inherit': 'javascript',
            \   },
            \   'typescriptreact': {
            \     '@inherit': 'javascriptreact typescript',
            \   },
            \   'typescript': {
            \     '@inherit': 'javascript',
            \     'ro': "readonly",
            \     'pub': "public",
            \     'pri': "private",
            \   },
            \   'vue': {
            \     '@inherit': 'typescript',
            \   },
            \   'sql': {
            \     'sel': 'SELECT * FROM',
            \     'upd': 'UPDATE tbl SET row = ""',
            \     'del': 'DELETE FROM',
            \   },
            \   'python': {
            \     '^tryc$': "try:\<ESC>:call SmartJumpToEnd()\<CR>aexcept:\<CR>pass\<C-o>O\<SPACE>\<BS>\<C-o>z"
            \   },
            \ }

    " indentLine
        let g:indentLine_char = '┆'
    
    " CoC
        let g:coc_snippet_next = "<C-x>"
        let g:coc_snippet_prev = "<C-z>"
        function! s:check_back_space() abort
            let col = col('.') - 1
            return !col || getline('.')[col - 1]  =~# '\s'
        endfunction

        function! SmartPumComplete(str)
            if ! coc#_selected() || ! pumvisible()
                return a:str
            endif
            let infos = complete_info()
            let selected = get(infos, 'selected', 0)
            let items = get(infos, 'items', [])
            if selected < -1 | return "\<C-y>" | endif
            if selected == -1 || selected >= len(items)
                return a:str
            endif
            let item = items[selected]
            if get(item, 'word', '') != get(item, 'abbr', '')
                return "\<C-y>"
            endif
            return a:str
        endfunction

        call AddMapping('i', "<SPACE>", 'SmartPumComplete("<SPACE>")')
        call AddMapping('i', "<CR>", 'SmartPumComplete("<CR>")')
        nmap <silent> <C-]> <Plug>(coc-implementation)
        nmap <silent> <F12> <Plug>(coc-references)

        " Use K to show documentation in preview window.
        nnoremap <silent> <F1> :call <SID>show_documentation()<CR>
        inoremap <silent> <F1> <CMD>call CocActionAsync('showSignatureHelp')<CR>

        function! s:show_documentation()
            if (index(['vim','help'], &filetype) >= 0)
                execute 'h '.expand('<cword>')
            else
                call CocActionAsync('doHover')
            endif
        endfunction

        " Symbol renaming.
        nmap <leader>rn <Plug>(coc-rename)

        " Formatting selected code.
        xmap <leader>f  <Plug>(coc-format-selected)
        nmap <leader>f  <Plug>(coc-format-selected)

        augroup mygroup
            autocmd!
            " Setup formatexpr specified filetype(s).
            autocmd FileType typescript,json setl formatexpr=CocAction('formatSelected')
            " Update signature help on jump placeholder.
            autocmd User CocJumpPlaceholder call CocActionAsync('showSignatureHelp')
        augroup end

        " Remap keys for applying codeAction to the current line.
        " nmap <leader>ac  <Plug>(coc-codeaction)

        " Use <TAB> for selections ranges.
        " NOTE: Requires 'textDocument/selectionRange' support from the language server.
        " coc-tsserver, coc-python are the examples of servers that support it.
        xmap <silent> <TAB> <Plug>(coc-range-select)

        " Add `:Format` command to format current buffer.
        command! -nargs=0 Format :call CocAction('format')

        " Add `:Fold` command to fold current buffer.
        command! -nargs=? Fold :call     CocAction('fold', <f-args>)

        " Add `:OR` command for organize imports of the current buffer.
        command! -nargs=0 OR   :call     CocAction('runCommand', 'editor.action.organizeImport')

        " Add (Neo)Vim's native statusline support.
        " NOTE: Please see `:h coc-status` for integrations with external plugins that
        " provide custom statusline: lightline.vim, vim-airline.
        set statusline^=%{coc#status()}%{get(b:,'coc_current_function','')}

    " Coc Explorer
        let g:coc_explorer_global_presets = {
                    \   '.vim': {
                    \      'root-uri': '~/.vim',
                    \   },
                    \   'floating': {
                    \      'position': 'floating',
                    \   },
                    \   'floatingTop': {
                    \     'position': 'floating',
                    \     'floating-position': 'center-top',
                    \   },
                    \   'floatingLeftside': {
                    \      'position': 'floating',
                    \      'floating-position': 'left-center',
                    \      'floating-width': 50,
                    \   },
                    \   'floatingRightside': {
                    \      'position': 'floating',
                    \      'floating-position': 'left-center',
                    \      'floating-width': 50,
                    \   },
                    \   'simplify': {
                    \     'file-child-template': '[selection | clip | 1] [indent][icon | 1] [filename omitCenter 1]'
                    \   }
                    \ }

        autocmd! FileType coc-explorer set conceallevel=0

    " Vim LightLine
        let g:lightline = {
            \ 'colorscheme': 'powerline',
            \ 'active': {
            \   'left':[ [ 'mode', 'paste' ],
            \            [ 'gitbranch', 'readonly', 'filename', 'modified' ]
            \   ]
            \ },
            \ 'tabline': {
            \   'left': [ ['buffers'] ],
            \   'right': [ [ 'close' ], ],
            \ },
            \ 'component_expand': {
            \   'buffers': 'lightline#bufferline#buffers'
            \ },
            \ 'component_type': {
            \   'buffers': 'tabsel'
            \ },
            \ 'component': {
            \   'separator': '',
            \   'lineinfo': ' %3l:%-2v',
            \ },
        \ }

        " NERDTree File highlighting
        function! ExplorerHighlight(extension, link, all)
            exec 'autocmd filetype coc-explorer highlight link ' . a:extension .' '.a:link
            if a:all
                exec 'autocmd filetype coc-explorer syn match ' . a:extension .' #^\W*\zs\w.*'. a:extension .'\>\s\+#'
            else
                exec 'autocmd filetype coc-explorer syn match ' . a:extension .' #^\W*\w.*\zs'. a:extension .'\>\ze\s\+#'
            endif
        endfunction

        call ExplorerHighlight('txt', 'GruvboxBlue', 0)
        call ExplorerHighlight('md',  'GruvboxBlue', 0)
        " call ExplorerHighlight('css', 'GruvboxBlue', 0)

        call ExplorerHighlight('lock',    'GruvboxBlackItalic', 1)
        call ExplorerHighlight('conf',    'GruvboxBlackItalic', 1)
        call ExplorerHighlight('config',  'GruvboxBlackItalic', 1)
        call ExplorerHighlight('gql',     'GruvboxBlackItalic', 1)
        call ExplorerHighlight('ini',     'GruvboxBlackItalic', 1)
        call ExplorerHighlight('css',     'GruvboxBlackItalic', 1)
        call ExplorerHighlight('json',    'GruvboxBlackItalic', 1)
        call ExplorerHighlight('spec.ts', 'GruvboxBlackItalic', 1)
        call ExplorerHighlight('ico',     'GruvboxBlackItalic', 1)

        call ExplorerHighlight('csv',  'GruvboxYellow', 0)

        call ExplorerHighlight('yaml',       'GruvboxAqua', 0)
        call ExplorerHighlight('yml',        'GruvboxAqua', 0)
        call ExplorerHighlight('Dockerfile', 'GruvboxAqua', 0)

        call ExplorerHighlight('html', 'GruvboxPurple', 0)
        call ExplorerHighlight('php',  'GruvboxPurple', 0)

        call ExplorerHighlight('py',     'GruvboxRed', 0)
        call ExplorerHighlight('coffee', 'GruvboxRed', 0)
        call ExplorerHighlight('js',     'GruvboxRed', 0)
        call ExplorerHighlight('ts',     'GruvboxRed', 0)

        let g:lightline.component_raw = {'buffers': 1}
        let g:lightline#bufferline#enable_devicons = 1
        let g:lightline#bufferline#clickable = 1
        let g:lightline#bufferline#modified = ' ●'
        " let g:lightline#bufferline#reverse_buffers = 1

        let g:lightline.separator = {
            \   'left': '', 'right': ''
          \}
        let g:lightline.subseparator = {
            \   'left': '', 'right': '' 
          \}

    " ultisnips
        let g:UltiSnipsSnippetDirectories  = [$HOME.'/.vim/UltiSnips']
        let g:UltiSnipsExpandTrigger       = "<C-l>"
        call AddMapping('i', '<C-l>', 'UltiSnips#ExpandSnippet()')
        " inoremap <C-l> <CMD>call UltiSnips#ExpandSnippet()<CR>
        inoremap <C-SPACE> <C-x>
        inoremap <C-x> <CMD>call UltiSnips#JumpForwards()<CR>
        inoremap <C-z> <CMD>call UltiSnips#JumpBackwards()<CR>
        vnoremap <C-x> <CMD>call UltiSnips#JumpForwards()<CR>
        vnoremap <C-z> <CMD>call UltiSnips#JumpBackwards()<CR>

    " FZF
        let g:fzf_history_dir = '~/.local/share/fzf-history'
        let g:fzf_nvim_statusline = 0 " disable statusline overwriting

    " GitGutter
        let g:gitgutter_map_keys = 0
        let g:gitgutter_max_signs = 2000
        let g:gitgutter_sign_added = '▎'
        let g:gitgutter_sign_modified = '▎'
        let g:gitgutter_sign_removed = '▎'
        let g:gitgutter_sign_modified_removed = '▎'
        let g:gitgutter_sign_removed_above_and_below = '▎'
        let g:gitgutter_sign_removed_first_line = '▎'

    " Minimap
        " let g:minimap_auto_start = 1
        autocmd! VimEnter * if !&diff | exe "Minimap" | endif
        nnoremap <F4> <CMD>call minimap#vim#HighlightSearch()<CR>

    " Import Cost
        let g:import_cost_show_gzipped = 0

    " Visual Multi
        let g:VM_mouse_mappings   = 0
        let g:VM_theme            = 'iceblue'
        let g:VM_custom_motions  = {'<C-up>': "k", '<C-right>': "l", '<C-down>': "j", '<C-left>': "h"}

        let g:VM_maps = {}
        let g:VM_maps["Reselect Last"] = 'gs'
        let g:VM_maps["Add Cursor At Pos"] = ''
        let g:VM_maps["Add Cursor At Word"] = ''
        let g:VM_maps["Start Regex Search"] = ''
        let g:VM_maps["Select All"] = ''
        let g:VM_maps["Add Cursor Down"] = 's<DOWN>'
        let g:VM_maps["Add Cursor Up"] = 's<UP>'
        let g:VM_maps["Visual Regex"] = ''
        let g:VM_maps["Visual All"] = ''  
        let g:VM_maps["Visual Add"] = ''  
        let g:VM_maps["Visual Find"] = ''
        let g:VM_maps["Visual Cursors"] = ''  
        let g:VM_maps["Find Under"] = ''
        let g:VM_maps["Duplication"] = 'Z'
        " When in search mode
            let g:VM_maps["Find Next"] = '<C-n>'
            let g:VM_maps["Find Previous"] = '<CS-n>'
            " let g:VM_maps["Goto Next"] = ''
            " let g:VM_maps["Goto Previous"] = ''

        let g:VM_maps["Slash Search"] = 's/'
        let g:VM_maps["Find Subword Under"] = ''
        let g:VM_maps["Select Cursor Down"] = ''
        let g:VM_maps["Select Cursor Up"] = ''
        let g:VM_maps["Select j"] = ''
        let g:VM_maps["Select l"] = ''
        let g:VM_maps["Select k"] = ''
        let g:VM_maps["Select h"] = ''
        let g:VM_maps["Select w"] = ''
        let g:VM_maps["Select b"] = ''
        let g:VM_maps["Select E"] = ''
        let g:VM_maps["Select BBW"] = ''
        let g:VM_maps["Mouse Cursor"] = ''
        let g:VM_maps["Mouse Word"] = ''
        let g:VM_maps["Mouse Column"] = ''
        let g:VM_maps["Select Operator"] = 'v'
        
        fun! CursOnMatches() abort
            let v = winsaveview()
            
            call setpos('.', [0, 1, 1, 0])

            let s = @/

            while search(s, 'W')
                call vm#commands#add_cursor_at_pos(0)
            endwhile

            call winrestview(v)
        endfun
        
        fun! MultiCursorOn() abort
            if !exists('g:Vm.buffer')
                return 0
            endif
            return g:Vm.buffer
        endfun

    " CtrlSF
        let g:ctrlsf_auto_close = {
            \ "normal" : 1,
            \ "compact": 1
            \}

        let g:ctrlsf_auto_focus = {
            \ "at": "start"
            \ }

        let g:ctrlsf_auto_preview = 0
        let g:ctrlsf_case_sensitive = 'yes'
        let g:ctrlsf_context = '-B 3 -A 3'
        let g:ctrlsf_default_root = 'cwd'
        let g:ctrlsf_default_view_mode = 'compact'
        let g:ctrlsf_regex_pattern = 1
        let g:ctrlsf_winsize = '40%'
        let g:ctrlsf_mapping = {
            \ "chgmode": "<TAB>",
            \ "quit": "q"
            \ }
    " JsDoc
        let g:jsdoc_formatter = 'tsdoc'

    " diffunit
        let g:DiffUnit = 'Word'

        function OnOpenVimDiff()
            cab x xa
            cab q qa
            cab w wa

            nnoremap <CS-right> <CMD>diffput <BAR> diffupdate<CR>
            nnoremap <CS-left> <CMD>diffget <BAR> diffupdate<CR>

            nnoremap u u<CMD>diffupdate<CR>

            nnoremap <CS-up> [c
            nnoremap <CS-down> ]c

            nnoremap <F5> :diffupdate<CR>
        endfunction
        autocmd FileType * if &diff | call OnOpenVimDiff() | endif

        set patchexpr=MyPatch()
        function MyPatch()
           :call system("patch -o " . v:fname_out . " " . v:fname_in .
           \  " < " . v:fname_diff)
           :call system("patch -o " . v:fname_out . " " . v:fname_in .
           \  " < " . v:fname_diff . " > ")
        endfunction

        set diffexpr=MyDiff()
        function MyDiff()
           let opt = ""
           if &diffopt =~ "icase"
             let opt = opt . "-i "
           endif
           if &diffopt =~ "iwhite"
             let opt = opt . "-b "
           endif
           silent execute "!diff -w -B -a --binary " . opt . v:fname_in . " " . v:fname_new . " > " . v:fname_out
           " exe "!/home/zorzi/.local/bin/custom/diff.js -w -B -a --binary " . opt . v:fname_in . " " . v:fname_new ." > " . v:fname_out

           " silent execute "!diff -e -w -B -a " . opt . v:fname_in . " " . v:fname_new .
           "  \  " > " . v:fname_out
           redraw!
        endfunction
        " let diffexpr='diff -t -w -B -a --strip-trailing-cr -d'
        let diffexpr=MyDiff()
"
" PLUGINS
" 
    " including Vundle and initialize
    set rtp+=~/.vim/bundle/Vundle.vim
    call vundle#begin()

        " 
        " Gotta go fast!
        " 
            " indent range
            Plugin 'vim-indent-object'

            " Fast surround shortcuts
            Plugin 'tpope/vim-surround'

            " fast comment
            Plugin 'tpope/vim-commentary'

            if has('nvim')
                " Snippets
                Plugin 'sirver/UltiSnips'
            endif

            " Recursive search
            Plugin 'dyng/ctrlsf.vim'

            " Multi cursors
            Plugin 'mg979/vim-visual-multi'

        " 
        " Pretty editor
        " 
            " minimap
            Plugin 'z0rzi/minimap.vim'

            " visual indents
            Plugin 'Yggdroot/indentLine'

            " Pretty icons
            Plugin 'ryanoasis/vim-devicons'

            " Line on the bottom of the screen
            Plugin 'itchyny/lightline.vim'

        " 
        " Language specific
        " 
            Plugin 'heavenshell/vim-jsdoc', { 
              \ 'for': ['javascript', 'javascript.jsx','typescript'], 
              \ 'do': 'make install'
            \}

        " 
        " Others
        " 
            " visual GIT modifs
            Plugin 'airblade/vim-gitgutter'

            " Fuzzy search
            Plugin 'junegunn/fzf'
            Plugin 'junegunn/fzf.vim'

            " Buffer stuff
            Plugin 'z0rzi/lightline-bufferline'

            Plugin 'neoclide/coc.nvim', {'branch': 'master', 'do': 'yarn install --frozen-lockfile'}

            Plugin 'rickhowe/diffchar.vim'

        " 
        " My plugins!
        " 
            Plugin 'z0rzi/vim-adaptive-indent'
            Plugin 'z0rzi/vim-zorzi-smoothie'
            Plugin 'z0rzi/vim-smart-hits'

    call vundle#end()

" 
" MAPS
" 
    " Basic Vim Shortcuts
        nnoremap >> i<C-t><ESC>
        nnoremap Y y$
        nnoremap YY <CMD>let v = winsaveview()<CR>ggyG<CMD>call winrestview(v)<CR>
        nnoremap vv v$h
        nnoremap <CR> <CMD>call SearchPair()<CR>
        onoremap <CR> v<CMD>call SearchPair()<CR>
        inoremap <F2> <ESC>
        inoremap <C-x><C-l> <C-x><C-l>
        inoremap <silent> <C-r>/ <C-r>=substitute(@/, '\\.', '', 'g')<CR>
        inoremap <LEFT> <C-G>U<LEFT>
        inoremap <RIGHT> <C-G>U<RIGHT>
        inoremap <DOWN> <C-G>U<DOWN>
        inoremap <UP> <C-G>U<UP>

        vnoremap <CR> <CMD>if mode() == 'V' <BAR> call search('\%#.*\zs\([{[(][;:.,\\]*\<BAR>\/\*\+\)$') <BAR> endif<CR>%

        vnoremap p <CMD>let save=@0<CR>p<CMD>let [@0, @", @+] = [save, save, save]<CR>
        vnoremap $ $h
        nnoremap - 2<C-y><C-g>
        nnoremap + 2<C-e><C-g>
        vnoremap g= c<C-r>=<C-r>+<CR><ESC>
        nnoremap g= Vc<C-r>=<C-r>+<CR><ESC>
        inoremap \'e é
        nnoremap cb vbc
        nnoremap db vbd


        " nnoremap <F3> :set hlsearch!<CR>
        nnoremap <F3> <CMD>noh<CR>
        " Plugin: GitGutter
        nmap <F5> <CMD>redraw!<CR><CMD>GitGutter<CR><CMD>set foldmethod=expr<CR><CMD>AdaptIndent<CR><CMD>MinimapToggle<CR><CMD>MinimapToggle<CR>

        " Fast selection wrap
            vnoremap "" c""<ESC>Pgvlolo
            vnoremap '' c''<ESC>Pgvlolo
            vnoremap `` c``<ESC>Pgvlolo
            vnoremap {{ c{  }<ESC>hPgvllollo
            vnoremap }} c{}<ESC>Pgvlolo
            vnoremap [[ c[  ]<ESC>hPgvllollo
            vnoremap ]] c[]<ESC>Pgvlolo
            vnoremap (( c(  )<ESC>hPgvllollo
            vnoremap )) c()<ESC>Pgvlolo

        " no yank delete
            nnoremap \ "_

        " no include newline
            nnoremap 'd ^D
            nnoremap 'D 0D
            nnoremap 'c ^C
            nnoremap 'C 0C
            nnoremap 'y mm^y$`m
            nnoremap 'Y mm0y$`m
            nnoremap 'v ^v$ho
            nnoremap 'V 0v$ho

        " move lines
            nnoremap <C-j> <CMD>m+1<CR>
            nnoremap <C-k> <CMD>m-2<CR>
            nnoremap <C-up>   <CMD>if MultiCursorOn()<BAR>exe "norm k"<BAR>else<BAR>m-2<BAR>endif<CR>
            nnoremap <C-down> <CMD>if MultiCursorOn()<BAR>exe "norm j"<BAR>else<BAR>m+1<BAR>endif<CR>
            " nnoremap <C-down> <CMD>m+1<CR>
            " nnoremap <C-up> <CMD>m-2<CR>
            vnoremap <C-up> :<C-u>exe (line("'<")-1) . " m " . line("'>")<CR>gv
            vnoremap <C-down> :<C-u>exe (line("'>")+1) . " m " . (line("'<") - 1)<CR>gv
            vnoremap <C-right> dpgvlolo
            vnoremap <C-left> dhPgvhoho


        " Duplicate lines
            nnoremap <silent> Z <CMD>set opfunc=DuplicateLines<CR>g@
            vnoremap <silent> Z  <CMD>call DuplicateLines(visualmode(), 1)<CR>
            nnoremap <silent> ZZ <CMD>co +0<CR>
            nnoremap <silent> zx <CMD>co +0<CR>

        " Easy search n replace
            nnoremap <C-c> <CMD>if CursorOnMatch(@/) <BAR> exe "norm!lN" <BAR> else <BAR> let @/="\\<".expand("<cword>")."\\>" <BAR> endif<CR>cgn
            nnoremap <C-d> <CMD>if CursorOnMatch(@/) <BAR> exe "norm!lN" <BAR> else <BAR> let @/="\\<".expand("<cword>")."\\>" <BAR> endif<CR>dgn

        " Better ranges for XML
            nmap >it vitVkoj>
            nmap <it vitVkoj<


        " Cool selection stuff
            vnoremap <C-c> "ay:let @/ = SelectionToRx(@a) <BAR> call histadd('/', @/) <BAR> set hlsearch <CR>cgn
            function! ToNextOccurence(backward)
                if mode() == 'n'
                    call RestrictSearch(0)
                    if ! CursorOnMatch(@/)
                        let @/ = '\<'.expand('<cword>').'\>'
                    endif
                    if a:backward | call search(@/, 'bc') | endif
                else
                    norm! "ay
                    let @/ = SelectionToRx(@a)
                endif
                let @/ = @/
                let flags = ''
                if !exists('s:minimap_search') | let s:minimap_search = '' | endif
                if s:minimap_search != @/
                    let s:minimap_search = @/
                    call minimap#vim#HighlightSearch()
                endif
                if a:backward | let flags .= 'b' | endif
                call search(@/, flags)
                call histadd('/', @/)
            endfunction
            vnoremap <S-LEFT> <CMD>call ToNextOccurence(1) <BAR> set hlsearch<CR>
            vnoremap <S-RIGHT> <CMD>call ToNextOccurence(0) <BAR> set hlsearch<CR>
            nnoremap <silent> <S-LEFT> <CMD>call ToNextOccurence(1) <BAR> set hlsearch<CR>
            nnoremap <silent> <S-RIGHT> <CMD>call ToNextOccurence(0) <BAR> set hlsearch<CR>
            vnoremap # <CMD>call ToNextOccurence(1) <BAR> set hlsearch<CR>
            vnoremap * <CMD>call ToNextOccurence(0) <BAR> set hlsearch<CR>
            nmap <CS-Right> <CMD>call RestrictSearch(1)<CR>
            nmap <CS-Left> <CMD>call RestrictSearch(-1)<CR>

        " Init folds
            function! FoldIfMakeSense(offset)
                let line = line('.') + matchstr(a:offset, '-\?\d*$')
                let foldline = foldclosed(line)

                if foldline != -1
                    return
                endif

                exe"".a:offset."foldclose"
            endfunction
            function! FoldAllSameLevel()
                let curpos = getcurpos()
                let saveSearch = @/
                let indent = matchstr(getline(line('.')), '^\s\+')
                exe"%g/^\\(".indent."\\s*\\S\\)\\@!\\s*\\S.*\\(\\n\\s*\\)\\+".indent."\\S/call FoldIfMakeSense('+1')"
                let @/ = saveSearch
                call setpos('.', curpos)
                noh
            endfunction
            nnoremap zff <CMD>call FoldAllSameLevel()<CR>

    " Moving mapping
        " fast exact search
            nnoremap <leader>/ /\<\><LEFT><LEFT>

        " Skip word by word with CTRL + direction
            function! CtrlMove(direction)
                if a:direction == 'left'
                    call search('\<\|\u\l\|_[a-z]\|\s\zs\S\|^', 'bW')
                else
                    call search('\w\>\|\u\l\|_[a-z]\|\S\s\|$', 'W')
                    if mode()[0] == 'i'
                        call setpos('.', [0, line('.'), col('.')+1, 0])
                    endif
                endif
            endfunction
            nnoremap <C-LEFT>  <CMD>call CtrlMove('left')<CR>
            nnoremap <C-RIGHT> <CMD>call CtrlMove('right')<CR>
            inoremap <C-LEFT> <CMD>call CtrlMove('left')<CR>
            inoremap <C-RIGHT> <CMD>call CtrlMove('right')<CR>

        " go to end of paragraph
            function! IndentJump(direction)
                let curline = line('.')
                " let indent = matchstr(getline(curline), '^\s*')
                let indent = indent(curline)
                if a:direction >= 0
                    " let nextLineNum = search('^.*\S.*$', 'n')
                    let nextLineNum = nextnonblank(line('.')+1)
                else
                    " let nextLineNum = search('^.*\S.*\n\_.*\%#', 'nb')
                    let nextLineNum = prevnonblank(line('.')-1)
                endif
                " let nextIndent = matchstr(getline(nextLineNum), '^\s*')
                let nextIndent = indent(nextLineNum)

                if nextIndent < indent || indent == 0
                    if a:direction >= 0
                        let flag = ''
                    else
                        let flag = 'b'
                    endif
                    call search('^.*\S.*\zs$', flag)
                else
                    if a:direction >= 0
                        " call search('^\('.indent.'\).*\n\(\1.*\n\|\s*\n\)*\1.*\zs')
                        call search('[\n[:blank:]]*\n\%\( \)\{,'.(indent-1).'}\S')
                    else
                        " call search('^\('.indent.'\)\S.*\zs\ze\n\(\1.*\n\|\s*\n\)*.*\%#')
                        call search('^\%\( \)\{,'.(indent-1).'}\S.*\n[\n[:blank:]]*.*\zs', 'b')
                    endif
                endif
            endfunction
            noremap <S-UP> <CMD>call IndentJump(-1)<CR>
            noremap <S-DOWN> <CMD>call IndentJump(1)<CR>

        " go to end of paragraph
            nnoremap { [(
            nnoremap } ])

        " Easy beg/end of line
            nnoremap ^ 0
            nnoremap 0 ^
            nnoremap <S-Insert> $

        " Move between splits
            nmap <A-LEFT> <C-w><LEFT>
            nmap <A-UP> <C-w><UP>
            nmap <A-RIGHT> <C-w><RIGHT>
            nmap <A-DOWN> <C-w><DOWN>
            nmap <A-h> <C-w>h
            nmap <A-k> <C-w>k
            nmap <A-h> <C-w>h
            nmap <A-l> <C-w>l

    " Plugin related maps
        " JsDoc
            nnoremap <LEADER>* :JsDoc<CR>
            vnoremap <LEADER>* :JsDoc<CR>

        " CtrlSF
            nnoremap <C-f> :CtrlSF ''<LEFT>
            nnoremap <C-s> :let @/ = '<C-r>=expand('<cword>')<CR>'<CR>:CtrlSF '\b<C-r>=@/<CR>\b'<CR>:CtrlSFFocus<CR>
            vnoremap <C-f> <ESC>:let @/ = escape(getline('.')[col("'<")-1 : col("'>")-1], '.\\[]')<CR>:CtrlSF "<C-r>=escape(@/, '"()')<CR>"<LEFT>
            vnoremap <C-s> <ESC>:let @/ = escape(getline('.')[col("'<")-1 : col("'>")-1], '.\\[]')<CR>:CtrlSF "<C-r>=escape(@/, '"()')<CR>"<CR>

        " CoC
            nnoremap <C-q> :CocAction<CR>
            nnoremap <S-q> :CocCommand<CR>

            nnoremap <LEADER>= <CMD>call CocAction('format')<CR>

            " Tab to go through completion list
            inoremap <silent><expr> <TAB>
                  \ pumvisible() ? "\<C-n>":
                  \ <SID>check_back_space() ? "\<TAB>":
                  \ coc#refresh()
            inoremap <expr><S-TAB> pumvisible() ? "\<C-p>" : "\<C-h>"

            nnoremap <F2> :CocCommand explorer<CR>

            " Close the preview window when completion is done.
            autocmd! CompleteDone * if pumvisible() == 0 | pclose | endif

            " nmap <silent> <C-c> <Plug>(coc-cursors-position)
            " nmap <silent> <C-d> <Plug>(coc-cursors-word)
            " xmap <silent> <C-d> <Plug>(coc-cursors-range)
            " use normal command like `<leader>xi(`
            " nmap <leader>x  <Plug>(coc-cursors-operator)

        " Git stuff
            " Plugin: GitGutter
            function! GitGutterStageSelection(line_start, line_end)
                let view = winsaveview()
                
                let curline = a:line_start - 1
                call setpos('.', [0, curline, 1, 0])

                while 1
                    sil! GitGutterNextHunk
                    if curline == line('.') || line('.') > a:line_end
                        break
                    endif
                    let curline = line('.')
                    sil! GitGutterStageHunk
                sil! GitGutter
                endwhile

                " call winrestview(view)
                sil! GitGutter
            endfunction
            command -range GitGutterStageSelection call GitGutterStageSelection(<line1>, <line2>)
            vnoremap <LEADER>ga :GitGutterStageSelection<CR>

            nnoremap <LEADER>gs <CMD>call system('git reset ' . @%) <BAR> GitGutter<CR>
            nnoremap <LEADER>gr <CMD>call system('git reset ' . @%) <BAR> GitGutter<CR>
            nnoremap <LEADER>ga <CMD>sil!GitGutterStageHunk<CR>
            nnoremap <LEADER>gu <CMD>sil!GitGutterUndoHunk<CR>
            nnoremap <LEADER>gn <CMD>sil!GitGutterNextHunk<CR>
            nnoremap <LEADER>gp <CMD>sil!GitGutterPrevHunk<CR>
            nnoremap <LEADER>gP <CMD>sil!GitGutterPreviewHunk<CR>
            nnoremap <LEADER>gh <CMD>sil!GitGutterLineHighlightsToggle<CR>
            nnoremap <LEADER>gb <CMD>call GitBlame()<CR>
            nnoremap <LEADER>gD <CMD>call system('git difftool ' . @%) <BAR> GitGutter<CR><CR>

        " Tabular indenting
            nnoremap <leader>t= mm<CMD>Tabular /^[^=]*\zs=<CR>`m
            nnoremap <leader>t: mm<CMD>Tabular /^[^:]*:\zs/l0r1<CR>`m
            nnoremap <leader>t> mm<CMD>Tabular /^[^=]*\zs=>/<CR>`m
            nnoremap <leader>t<SPACE> mm<CMD>Tabular / *\zs /l0<CR>`m
            vnoremap <leader>t= :Tabular /^[^=]*\zs=<CR>
            vnoremap <leader>t: :Tabular /:\zs<CR>
            vnoremap <leader>t<SPACE> :Tabular / *\zs /l0<CR>
            nnoremap <leader>t> mm<CMD>Tabular /^[^=]*\zs=>/<CR>`m

            " nmap <leader>t* mm?/\*\*<CR>kmn:/\/\*\*/,/\*\//s/^\s\+\*\s\+@\S\+\zs\s\+/ /<CR>`n:/\/\*\*/,/\*\//s/^\s\+\*\s\+@\(param\\|return\)\s\+\S\+\zs\s\+/ /<CR>`n:/\/\*\*/,/\*\//s/@param\s\+\S\+\s\+\S\+\zs\s\+/ /<CR>`nO<ESC>0CTabular /^\s\+\*\s\+@\S\+\s*\zs\s/l0\|Tabular /^\s\+\*\s\+@\(param\\|return\)\s\+\S\+\s*\zs\s/l0\|Tabular /^\s\+\*\s\+@param\s\+\S\+\s\+\S\+\s*\zs\s/l0<ESC>:s/[^\\]\zs\|/\r/g<CR>^tDddk^"rDddk^"eDdd`n:/\/\*\*/,/\*\//g/./<C-r>e<CR>`n:/\/\*\*/,/\*\//g/./<C-r>r<CR>`n:/\/\*\*/,/\*\//g/./<C-r>t<CR>`m

            nnoremap <leader>t :Tabular /
            vnoremap <leader>t :Tabular /

        " FZF
            nnoremap <C-p> <CMD>call FZFFindFile()<CR>
            nnoremap <LEADER>u <CMD>call FZFUnicode()<CR>

        " Commentary
            nnoremap  <CMD>Commentary<CR>
            inoremap  <CMD>Commentary<CR>
            vnoremap  :Commentary<CR>gv

        " Multi cursors
            nnoremap s/ :call CursOnMatches()<CR>
            vnoremap s :call vm#commands#visual_cursors()<CR>
            nnoremap ss :call vm#commands#add_cursor_at_pos(0)<CR>
            nnoremap sp :call vm#commands#seek_up()<CR>
            nnoremap sn :call vm#commands#seek_down()<CR>

    " Buffer related maps
        " Buffers navigation 
            " nnoremap <Tab> <CMD>bnext<CR>
            " nnoremap <S-Tab> <CMD>bprev<CR>
            nnoremap <Tab> <CMD>call lightline#bufferline#next()<CR>
            nnoremap <S-Tab> <CMD>call lightline#bufferline#prev()<CR>
            " nnoremap <Tab> <CMD>b#<CR>
            " nnoremap <S-Tab> <CMD>:Buffers<CR>

        " Buffer management
            nnoremap <LEADER>q <CMD>call lightline#bufferline#remove()<CR>
            " nnoremap <LEADER>q <CMD>bprev<BAR>bd#<CR>
            nnoremap <LEADER>Q <CMD>bd<CR>

    " New Ideas
        " Pack / unpack
            nnoremap <LEADER><CR> <CMD>call Unpack()<CR>
            nnoremap <LEADER><BS> <CMD>call Pack()<CR>

        " Fast insert mode
            nnoremap <LEADER>b bi
            nnoremap <LEADER>i bi
            nnoremap <LEADER>B Bi
            nnoremap <LEADER>I Bi
            nnoremap <LEADER>e ea
            nnoremap <LEADER>a ea
            nnoremap <LEADER>E Ea
            nnoremap <LEADER>A Ea
            nnoremap <LEADER>. f.a

        " Double Tap shortcut
            " inoremap )) (<CMD>call SmartJumpToEnd()<CR><RIGHT>)
            " inoremap ]] [<CMD>call SmartJumpToEnd()<CR><RIGHT>]
            " inoremap }} {<CMD>call SmartJumpToEnd()<CR><RIGHT>}
            inoremap )<TAB> (<CMD>call SmartJumpToEnd()<CR><RIGHT>)
            inoremap ]<TAB> [<CMD>call SmartJumpToEnd()<CR><RIGHT>]
            inoremap }<TAB> {<CMD>call SmartJumpToEnd()<CR><RIGHT>}

        " Backspace selector
            function! BSOperator()
                exe"norm!V\<ESC>"
                call setpos("'<", getpos('.'))
                call search('[{\[(]$', 'W')
                norm!%
                call setpos("'>", getpos('.'))
                norm!gv
            endfunction
            onoremap <BS> <CMD>call BSOperator()<CR>
            vnoremap <BS> <CMD>call BSOperator()<CR>

        " Paste selector
            nnoremap >p mm`[>`]`m
            nnoremap <p mm`[<`]`m
            " nnoremap dp '[d']
            nnoremap =p mm`[=`]`m

        " Easy delete until...
            nnoremap v; vt;
            nnoremap v: vt:
            nnoremap v) vt)
            nnoremap v} vt}
            nnoremap v> vt>
            nnoremap v] vt]
            nnoremap v. vt.
            nnoremap v" vt"
            nnoremap v' vt'
            nnoremap v, vt,
            onoremap ; t;
            onoremap : t:
            onoremap ) t)
            onoremap ( t(
            onoremap } t}
            onoremap { t{
            onoremap > t>
            onoremap ] t]
            onoremap . t.
            onoremap " t"
            onoremap ' t'
            onoremap , t,
            nnoremap c= ^<CMD>call search('= \?\zs\\|$')<CR>mm<CMD>call search('[;,]\?$')<CR>mn`mc`n
            nnoremap d= ^<CMD>call search('= \?\zs\\|$')<CR>mm<CMD>call search('[;,]\?$')<CR>mn`md`n

        " Until MAJ or underscore
            nnoremap dq mm<CMD>call search('\u\\|\>\\|_')<CR>d`m
            nnoremap cq mm<CMD>call search('\u\\|\>\\|_')<CR>c`m
            " inoremap <C-q> <SPACE><LEFT><CMD>exe "norm!mm" <BAR> call search('\u\<BAR>\<\<BAR>_\zs\w', 'b') <BAR> exe "norm!d`m"<CR><DEL>

        " Delete after cursor in insert
            inoremap <C-e> <CMD>norm!de<CR>

        " semi-column things
            inoremap ;; <CMD>call setline('.', getline('.') . ';')<CR>
            inoremap ;a <C-o>A
            inoremap ;. <CMD>norm!$<CR><RIGHT>.
            inoremap ;, <C-o>A,

        " select multiple lines in a VSCode Style
            nnoremap <CS-DOWN> <C-v>j
            nnoremap <CS-UP> <C-v>k
            vnoremap <CS-DOWN> j
            vnoremap <CS-UP> k
            vnoremap <LEADER>i I
            vnoremap <LEADER>a A
            vnoremap <LEADER>I ^I
            vnoremap <LEADER>A $A

        " Around selection, completes the vim-surround plugin
            vmap m S
            vnoremap m/ c//<ESC>P
            vnoremap m_ c__<ESC>P
            vnoremap m+ c++<ESC>P
            vnoremap m. c..<ESC>P
            vnoremap m<SPACE> c<SPACE><SPACE><ESC>P
            vnoremap m<BS> dvhpgv

        " Smallest range possible
            onoremap io <CMD>call SelectSmallestRangePossible(0)<CR>
            onoremap ao <CMD>call SelectSmallestRangePossible(1)<CR>
            vnoremap io <ESC>:call SelectSmallestRangePossible(0)<CR>
            vnoremap ao <ESC>:call SelectSmallestRangePossible(1)<CR>

" 
" AUTOCMD
" 
    " auto delete empty lines on insert leave
        " autocmd InsertLeave * sil!s/^\s*$//

    " taking back position at buffer open
        autocmd BufReadPost * silent!norm!g;
        autocmd BufLeave * call AutoSaveWinView()
        autocmd BufEnter * call AutoRestoreWinView()

    " Correcting bad commenting for specific languages | Plugin: Commentary
        autocmd! FileType php let b:commentary_format="// %s"
        autocmd! FileType python let b:commentary_format="# %s"
        autocmd! FileType sh let b:commentary_format="# %s"
        autocmd! FileType dockerfile let b:commentary_format="# %s"
        autocmd! FileType vue let b:commentary_format="// %s"
        autocmd! FileType typescript let b:commentary_format="// %s"
        autocmd! FileType sql let b:commentary_format="-- %s"
        autocmd! FileType coffee let b:commentary_format="# %s"
        autocmd! FileType conf let b:commentary_format="# %s"
        autocmd! FileType vim let b:commentary_format="\" %s"
        autocmd! FileType yaml let b:commentary_format="# %s"

    " Auto detecting indent on entering a file! | Plugin: vim-adaptive-indent
        autocmd BufReadPost * AdaptIndent

    " Language specific maps
        function! CloseXmlTag()
            call search('<', 'b')
            let col = col('.')
            let tag = matchstr(getline('.'), '\%'.col.'c<\zs.\{-}\ze\%(\s\|>\|$\)')
            call search('>', '')
            let col = col('.')
            let line = getline('.')
            call setline(line('.'), getline('.')[:col-1] . '</'.tag.'>' . getline('.')[col:])
            call setpos('.', [0, line('.'), col + 1, 0])
        endfunction
        autocmd FileType html,php,javascript,javascriptreact inoremap >> <CMD>call CloseXmlTag()<CR>

    " Correcting FZF buffer | Plugin: FZF
        autocmd! FileType fzf
        autocmd  FileType fzf set laststatus=0 noshowmode noruler
          \| autocmd BufLeave <buffer> set laststatus=2 showmode ruler

    " refreshing file when modified outside of vim
        autocmd BufEnter * checktime
        autocmd FocusGained * checktime
        autocmd BufWritePost * GitGutter

    " Unsupported files formats
        autocmd BufEnter *.abnf set filetype=abnf
        autocmd BufEnter *.fish set filetype=fish
        autocmd BufNewFile,BufRead *.vue set filetype=vue
        autocmd BufNewFile,BufRead *.coffee set filetype=coffee
        autocmd BufNewFile,BufRead *.jrl set filetype=journal
        autocmd BufNewFile,BufRead *.txt set filetype=txt
        autocmd BufNewFile,BufRead *.snippets set filetype=snippets
        autocmd BufNewFile,BufRead *.nim set filetype=nim
        autocmd BufNewFile,BufRead Jenkinsfile set filetype=groovy

    " Update custom mappings after everything else has been done
        autocmd VimEnter * call UpdateMappings()

    " Highlight current selection
        let s:last_mode = 'n'
        let s:sel_matches = ''
        hi SelectionOthers cterm=bold,underline ctermbg=NONE ctermfg=none
        function! SelectionToRx(selText)
            return substitute(escape(a:selText, '/\\^$*.[~'), '\%(\s\|\n\)\+', '\\%(\\s\\|\\n\\)\\+', 'g')
        endfunction
        function! HighlightSel()
            sil!call matchdelete(s:sel_matches)
            sil!exe "norm!\"aygv"
            let s:sel_matches = matchadd('SelectionOthers', SelectionToRx(@a))
        endfunction
        function EnterVisual()
            aug VisualHi
                autocmd!
                autocmd CursorMoved * call HighlightSel()
            aug END
        endfunction
        function LeaveVisual()
            sil!call matchdelete(s:sel_matches)
            aug VisualHi
                autocmd!
            aug END
        endfunction
        function ModeChanged()
            let curmode = mode()
            let s:last_mode = curmode

            if curmode == 'v'     | call EnterVisual()
            elseif curmode == 'n' | call LeaveVisual()
            endif
        endfunction
        autocmd CursorMoved * if mode() != s:last_mode | call ModeChanged() | endif

" 
" ABREVS
" 
    " Comments shortcut
        iab /// //<ENTER><C-o>O

    " Mistypes
        iab cnosole console
        iab cnosoel console
        iab cnsole console
        iab loaction location
        iab loaciton location 

    " French Accents
        iab etre être
        iab occupee occupée
        iab entete entête
        iab entetes entêtes
        iab requete requête
        iab etudiant étudiant
        iab etudiants étudiants
        iab ecole école
        iab ecoles écoles
        iab etais étais
        iab etait était
        iab implemente implémente
        iab implementation implémentation

    " Unicode
        iab \> ➤
        iab \\> ⤷
        iab \! ⚠



function! WrapLine(num)
    while len(getline('.')) > 81
        norm! ^
        let pos = col('.')
        call setpos('.', [0, line('.'), pos+a:num, 0])
        call search('\S\s', 'bW')
        if pos > col('.')
            break
        endif
        exe "norm! a\<CR>\<ESC>"
    endwhile
endfunction

nnoremap gqq <CMD>call WrapLine(81)<CR>


function! CopyWord(lnum, full_line)
    let lnum = line('.') + a:lnum

    if lnum > line('$') | let lnum = line('$') | endif
    if lnum < 0 | let lnum = 0 | endif

    if a:lnum < 0
        let lnum = prevnonblank(lnum)
    else
        let lnum = nextnonblank(lnum)
    endif
    let cnum = col('.')

    let line = getline(lnum)

    if a:full_line
        call setline('.', getline(lnum))
        call setpos('.', [0, line('.'), col('$'), 0])
        return ''
    endif

    let cara = matchstr(line, '\%'.cnum.'c.')

    if match(cara, '[a-zA-Z0-9_]') >= 0
        return matchstr(line, '\%([^a-zA-Z0-9_]\|^\)[a-zA-Z0-9_]\{-}\zs\%'.cnum.'c[a-zA-Z0-9_]\{-}\ze\%([^a-zA-Z0-9_]\|$\)')
    endif

    return cara
endfunction

inoremap <silent> <S-UP> <C-r>=CopyWord(-1, 0)<CR>
inoremap <silent> <S-DOWN> <C-r>=CopyWord(1, 0)<CR>
inoremap <silent> <CS-UP> <C-r>=CopyWord(-1, 1)<CR>
inoremap <silent> <CS-DOWN> <C-r>=CopyWord(1, 1)<CR>

function! HandleSig()
    let errFile = system('cat /tmp/vim_sig.txt')
    let errFile = trim(errFile)
    call ParseErrorLine(errFile)
endfunction
autocmd Signal SIGUSR1 call HandleSig()

function! IsSyn(grp_str, line, col)
    let syngrps = map(synstack(a:line, a:col), 'synIDattr(v:val, "name" )')

    let is_string = 0

    for syngrp in syngrps
        if match(tolower(syngrp), tolower(a:grp_str)) >= 0 
            return 1
        endif
        let papa_name = synIDattr(synIDtrans(hlID(syngrp)), 'name')
        if match(tolower(papa_name), tolower(a:grp_str)) >= 0 
            return 1
        endif
    endfor
    return 0
endfunction
function! SearchQuotePair(cara)
    if !IsSyn('string', line('.'), col('.')-1) && IsSyn('string', line('.'), col('.')+1)
        call search(a:cara)
    elseif IsSyn('string', line('.'), col('.')-1) && !IsSyn('string', line('.'), col('.')+1)
        call search(a:cara, 'b')
    else
        " No string, we count the amount of characters before cursor
        let line = getline('.')[:col('.') - 1]
        let cnt = 0
        for cara in split(line, '\ze.')
            if cara == a:cara
                let cnt += 1
            endif
        endfor
        if cnt % 2 == 0
            call search(a:cara, 'b')
        else
            call search(a:cara)
        endif
    endif
endfunction
function! SearchPair()
    let save = winsaveview()
    " For comments, putting cursor in proper place
    call search('\*\%#\/', 'b')
    if !search('[''"`}{\]\[()]\|/\*\*\|\*/', 'cW')
        return
    endif

    let cara = getline('.')[col('.')-1]

    if match(cara, '[''"`]') >= 0
        call SearchQuotePair(cara)
    else
        norm!%
    endif
endfunction
