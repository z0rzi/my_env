" 
" GENERAL NATIVE VIM SETTINGS
" 
    filetype plugin indent off
    syn on
    filetype on
    set nu
    set wrap
    set ruler
    set hidden
    set showtabline=2  " always show tabline
    set noshowmode
    set nobackup
    set nowritebackup
    set updatetime=300
    set shortmess+=c
    set signcolumn=yes
    " set termguicolors  " Increases the saturation
    set previewheight=5

    " different cursors in different modes
        let &t_SI = "\<Esc>[6 q"
        let &t_SR = "\<Esc>[4 q"
        let &t_EI = "\<Esc>[2 q"
        set timeoutlen=1000 ttimeoutlen=0

    set ve=block
    set hlsearch
    set incsearch

    set smartindent
    set autoindent

    set wildmenu
    set showcmd
    set scrolloff=5
    " set relativenumber
    set conceallevel=2
    set nostartofline
    set mouse=a

    set formatoptions=cro
    set clipboard=unnamedplus

    set swapfile
    set dir=/tmp
    set modeline

    " to refresh file on git checkout
        set autoread

    set tabstop=4 shiftwidth=4 expandtab

    " Considering '-' as part of a word
        " set iskeyword+=-

    " change the leader key to <space>
        let g:mapleader = "\<Space>"
    " Don't conceal markdown
        let g:vim_markdown_conceal_code_blocks=0
        let g:vim_markdown_conceal=0
    " Ignored files ( formated in bash style, like in the `ls` command )
        let g:ignoredDirs = [ '__pycache__', '.git', 'cache', 'node_modules', 'coverage', 'dist' ]
        let g:ignoredFiles = [ '*.log', '*.class', 'tags' ]

" 
" LOOKS AND FEEL
" 
    " General
        colorscheme gruvbox
        set fillchars=stl:\ ,stlnc:=,vert:│,fold:\ ,diff:-
        set listchars=tab:.\ , list

    " Folding
        let g:foldMode=1
        set foldlevelstart=99
        set foldmethod=expr
        set foldexpr=FindFoldLevel(v:lnum)
        set foldtext=NeatFoldText()

    " GruvBox config
        let g:gruvbox_italic = 1
        let g:gruvbox_undercurl = 1
        let g:gruvbox_termcolors = 256
        let g:gruvbox_contrast_dark = "medium"
        let g:gruvbox_italicize_strings = 1
        let g:gruvbox_invert_selection = 0
        let g:gruvbox_invert_signs = 0  " for GitGutter signs
        let g:gruvbox_guisp_fallback = 'bg'

    " GVim
        set guioptions-=m  "remove menu bar
        set guioptions-=T  "remove toolbar
        set guioptions-=r  "remove right-hand scroll bar
        set guioptions-=L  "remove left-hand scroll bar
        set background=dark

    " language specific
        " python
            " let g:python_highlight_all
            let g:python_highlight_builtin_funcs=1
            let g:python_highlight_builtin_objs=1
            let g:python_highlight_builtins=1
            let g:python_highlight_doctests=1
            let g:python_highlight_exceptions=1
            let g:python_highlight_file_headers_as_comments=1
            let g:python_highlight_indent_errors=0
            let g:python_highlight_space_errors=0
            let g:python_highlight_string_format=1
            let g:python_highlight_string_formatting=1
            let g:python_highlight_string_templates=1
            let g:python_print_as_function=1
            let g:python_slow_sync=0
            let g:python_version_2=0

" 
" FUNCTIONS
" 

    function! EOL()
        call setpos('.', [0, line('.'), col('$'), 0, col('$')])
    endfunction

    function! SmartJumpToEnd()
        if search('\%#.\?$', 'n') != 0
            call setpos("'m", getpos('.')
            call search('^\(\s\+\).*\%#.*\n\(\1.*\n\)*\zs\1')
            call append('.', repeat(' ', indent('.')))
            norm!j
            call setpos("'n", getpos('.')
            norm!=`m`n
        else
            let pos = search('\%#.\{-}\zs[\[\](){}]')

            if pos == 0
                call search('.;\?$')
            elseif search('\%#[[({]') != 0
                " Opening tag
                norm!%
            else
                " Closing tag
                norm!h
            endif
        endif
    endfunction

    function! MapToNextMove(cmd)
        exe "nnoremap <RIGHT> ".a:cmd."<CMD>call UnmapMoves()<CR>"
        exe "nnoremap <LEFT>  ".a:cmd."<CMD>call UnmapMoves()<CR>"
        exe "nnoremap <DOWN>  ".a:cmd."<CMD>call UnmapMoves()<CR>"
        exe "nnoremap <UP>    ".a:cmd."<CMD>call UnmapMoves()<CR>"
        exe "nnoremap <ESC>   ".a:cmd."<CMD>call UnmapMoves()<CR>"
    endfunction
    function! UnmapMoves()
        nunmap <RIGHT>
        nunmap <LEFT>
        nunmap <DOWN>
        nunmap <UP>
        nunmap <ESC>
    endfunction

    function! DuplicateLines(type, ...)
        call setpos("'m", getpos("."))
        if a:0
            silent exe "normal! gvy"
        else
            silent exe "normal! '[V']y"
        endif

        silent exe "normal! P"
        call setpos('.', getpos('m"))
        if search('^\s*\%#', 'n') != 0
            call search('^\s\+\zs\S')
            norm!$
        endif
        " s/^\ze.*\%#/\r/ " To add a new line between the old and the duplicate
    endfunction

    function! GetGroupName()
        if !exists("*synstack" )
            return
        endif
        echo map(synstack(line('.'), col('.')), 'synIDattr(v:val, "name" )')
    endfunction

    function! FindFoldLevel(lnum)
        if getline(a:lnum)=~'^$'
            let i = 0
            while 1
                if ! (getline(a:lnum + i) =~ '^\s*$')
                    return indent(a:lnum + i)
                endif
                let i += 1
                if i > 10
                    return -1
                endif
            endwhile
        endif

        let nextIndent = 0
        let i = 0
        while nextIndent == 0 && i <= 10
            let i += 1
            if ! (getline(a:lnum + i) =~ '^\s*$')
                let nextIndent = indent(a:lnum + i)
            endif
        endwhile

        if indent(a:lnum) < nextIndent
            if g:foldMode == 0
                return '>' . nextIndent
            else
                return indent(a:lnum)
            endif
        endif

        " next line is a fold start
        if indent(a:lnum) > indent(a:lnum + 1) && FindFoldLevel(a:lnum + 1) =~ '^>'
            return '<' . indent(a:lnum)
        endif

        return indent(a:lnum)
    endfunction

    function! NeatFoldText()

        let foldchar         = matchstr(&fillchars, 'fold:\zs.')
        let line             = ' ' . substitute(getline(v:foldstart), '^\s*"\?\s*\|\s*"\?\s*{{' . '{\d*\s*', '', 'g') . ' '
        let lines_count      = v:foldend - v:foldstart + 1
        let lines_count_text = printf("┈─ %1s lines ─┈", lines_count) . repeat(foldchar, 10)
        " let lines_count_text = '» ' . printf(%10s", lines_count . ' lines') . repeat(foldchar, v:foldlevel*2)
        " let foldtextstart    = strpart('+' . repeat(foldchar, v:foldlevel*2) . line, 0, (winwidth(0)*2)/3)
        if g:foldMode == 0
            let foldtextstart    = getline(v:foldstart) . " ••• " 
        elseif g:foldMode == 1
            let foldtextstart    = repeat(' ', indent(v:foldstart-1) + 4 ) . " ••• " 
        endif
        let foldtextend      = lines_count_text . repeat(foldchar, 8)
        let foldtextlength   = strlen(substitute(foldtextstart . foldtextend, '.', 'x', 'g')) + &foldcolumn

        return foldtextstart . repeat(foldchar, winwidth(0)-foldtextlength) . foldtextend
    endfunction

    function! EatNChars(num)
        let l:number = a:num
        let l:string = ""

        while l:number > 0
            let l:string .= nr2char(getchar())
            let l:number -= 1
        endwhile

        return ''
    endfunction

    function! SelectSmallestRangePossible(external)
        let lineCopy = getline('.')
        let curPos = col('.')

        let lineCopy = lineCopy[:curPos-2] . '@' . lineCopy[curPos-1] . '@' . lineCopy[curPos:]

        " echo lineCopy
        let lineCopy = substitute(lineCopy, '[^"[\](){}@<>`'."'".']', '', 'g')

        let i=0
        while lineCopy =~ '{}\|\[\]\|()\|""\|<>\|``\|'."''"
            let lineCopy = substitute(lineCopy, '{}\|\[\]\|()\|""\|``\|<>\|'."''", '', 'g')
            if i>10
                break
            endif
        endwhile
        let lineCopy = substitute(lineCopy, '@@', '@', 'g')

        let cara = matchstr(lineCopy, '.\ze@[^@]*$')

        if cara == ''
            return
        endif

        let cmd = "normal! vi" . cara
        if a:external
            let cmd = cmd . 'loho'
        endif
        execute cmd
    endfunction

    function! VimToGrepRegex(str)
        let rx = a:str

        let gargs = ""

        let rx = substitute(rx, '\\<\|\\>','\\b', 'g')

        if rx =~ '^\\c'
            let rx = substitute(rx, '^\\c','', '')
            let gargs .= " -i"
        endif

        return [rx, gargs]
    endfunction

    function! FZFFindFile()
        let ignoredFilesStr = ''
        for f in g:ignoredFiles
            let ignoredFilesStr .= ' ! -name "' . f . '"'
        endfor

        let ignoredDirsStr = ''
        for d in g:ignoredDirs
            let ignoredDirsStr .= ' ! -path "*/' . d . '/*"'
        endfor

        if expand('%:p') != ''
            let ignoredDirsStr .= ' ! -path *'.expand('%:p').'"'
        endif

        let cmd = 'ls --color=never -t $(find . -type f  ' . ignoredFilesStr . ' ' . ignoredDirsStr . ') 2> /dev/null'
        silent! exe fzf#run({'source': cmd, 'sink': 'e', 'options': '-d/ -n-1 --history /home/zorzi/.local/share/fzf-history/FZF --multi --no-sort --preview="git diff {}" --sync', 'down':'40%'})
    endfunction
    function! s:FZFOpenVimOutput(str)
        let thefile = matchstr(a:str, '^.\{-\}\ze:')
        let theline = matchstr(a:str, '^.\{-\}:\zs\d\+\ze:')
        silent! exe 'edit ' . fnameescape(thefile)
        echo cursor(theline,0)
    endfunction
    function! FZFFindWordUnderCursor()
        set hlsearch
        let @/ = expand("<cword>")
        call FZFFind(expand("<cword>"))
    endfunction
    function! FZFFindWord()
        let curline = getline('.')
        call inputsave()
        let str = input('> ')
        call inputrestore()
        call FZFFind(str)
    endfunction
    function! FZFFind(str)
        let [grepStr, grepArgs] = VimToGrepRegex(a:str)

        let previewLines = string(winheight(0) * 0.2)

        let ignoredFilesStr = ''
        for f in g:ignoredFiles
            let ignoredFilesStr .= ' ! -name "' . f . '"'
        endfor

        let ignoredDirsStr = ''
        for d in g:ignoredDirs
            let ignoredDirsStr .= ' ! -path "*/' . d . '/*"'
        endfor

        let cmd = 'grep -Isnr ' . grepArgs . ' --color=always "' . grepStr . '" $(ls --color=never -t $(find . -type f  ' . ignoredFilesStr . ' ' . ignoredDirsStr . ') 2> /dev/null )'
        let preview = '"awk -F: ''{printf(\"sed -n %d,%dp %s\",(\$2>'.previewLines.'?\$2-'.previewLines.':1), \$2+'.previewLines.', \$1)}'' <<< {} | xargs -I% bash -c \"%\" | grep --color=always -C100 \"' . grepStr . '\""'
        " let preview = ''
        let g:cmd = preview
        call fzf#run({'source': cmd, 'sink': function('s:FZFOpenVimOutput'), 'options': '--no-sort --ansi --multi --sync --preview=' . preview , 'down':'40%' })
    endfunction
    function! s:FZFPrintUnicode(line)
        let cara = matchstr( a:line, '\S\ze\s' )
        exe 'silent !grep "^'.cara.'" $HOME/.vim/customFiles/unicode_chars.txt > /tmp/unicode_temp.txt'
        exe 'silent !grep -v "^'.cara.'" $HOME/.vim/customFiles/unicode_chars.txt >> /tmp/unicode_temp.txt'
        exe 'silent !mv /tmp/unicode_temp.txt $HOME/.vim/customFiles/unicode_chars.txt'
        exe "norm!i" . cara
    endfunction
    function! FZFUnicode()
        let cmd = 'cat $HOME/.vim/customFiles/unicode_chars.txt'
        call fzf#run({'source': cmd, 'sink': function('s:FZFPrintUnicode'), 'options': '--no-sort --ansi', 'down':'40%' })
    endfunction

    " Save current view settings on a per-window, per-buffer basis.
    function! AutoSaveWinView()
        if !exists("w:SavedBufView")
            let w:SavedBufView = {}
        endif
        let w:SavedBufView[bufnr("%")] = winsaveview()
    endfunction
    " Restore current view settings.
    function! AutoRestoreWinView()
        let buf = bufnr("%")
        if exists("w:SavedBufView") && has_key(w:SavedBufView, buf)
            let v = winsaveview()
            let atStartOfFile = v.lnum == 1 && v.col == 0
            if atStartOfFile && !&diff
                call winrestview(w:SavedBufView[buf])
            endif
            unlet w:SavedBufView[buf]
        endif
    endfunction

    function! GetHighlightProps(grpName)
        " Saving linting colors, for the function
        let grpID = synIDtrans(hlID(a:grpName))

        let baseProperties = [ "bold", "italic", "reverse", "inverse", "standout", "underline", "undercurl", "strikethrough" ]
        let base = []

        for prop in baseProperties
            if synIDattr(grpID, prop) == '1'
                let base += [prop]
            endif
        endfor
        let base = join(base, ',')

        return {
                    \ 'name': a:grpName,
                    \ 'fg': synIDattr(grpID, "fg"),
                    \ 'bg': synIDattr(grpID, "bg"),
                    \ 'base': base
                    \ }
    endfunction

    function! ALEToggleHighlights(flag)
        if a:flag == 0
            hi clear ALEError
            hi clear ALEWarning
            hi clear ALEInfo
        else
            let grps = [g:AleErrorHI, g:AleWarningHI, g:AleInfoHI]

            for grp in grps
                let cmd = 'hi '.grp['name'].' '
                if len(grp['fg']) > 0
                    let cmd .= 'ctermfg='.grp['fg'].' '
                endif
                if len(grp['bg']) > 0
                    let cmd .= 'ctermbg='.grp['bg'].' '
                endif
                if len(grp['base']) > 0
                    let cmd .= 'cterm='.grp['base'].' '
                endif
                exe cmd
            endfor
        endif
    endfunction

" 
" PLUGINS CONFIG
" 
    " indentLine
        let g:indentLine_char = '┆'

    " CoC

        let g:coc_snippet_next = "<C-x>"
        let g:coc_snippet_prev = "<C-z>"
        function! s:check_back_space() abort
            let col = col('.') - 1
            return !col || getline('.')[col - 1]  =~# '\s'
        endfunction

        " Use <c-space> to trigger completion.
        inoremap <silent><expr> <c-space> coc#refresh()

        " Use <cr> to confirm completion, `<C-g>u` means break undo chain at current
        " position. Coc only does snippet and additional edit on confirm.
        if has('patch8.1.1068')
            " Use `complete_info` if your (Neo)Vim version supports it.
            inoremap <expr> <C-x> complete_info()["selected"] != "-1" ? "\<C-y>" : "\<C-g>u\<CR>"
        else
            imap <expr> <C-x> pumvisible() ? "\<C-y>" : "\<C-g>u\<CR>"
        endif

        " GoTo code navigation.
        " nmap <silent> <C-]> <Plug>(coc-definition)
        " nmap <silent> gd <Plug>(coc-type-definition)
        nmap <silent> <C-]> <Plug>(coc-implementation)
        nmap <silent> <F12> <Plug>(coc-references)

        " Use K to show documentation in preview window.
        nnoremap <silent> <F1> :call <SID>show_documentation()<CR>

        function! s:show_documentation()
            if (index(['vim','help'], &filetype) >= 0)
                execute 'h '.expand('<cword>')
            else
                call CocAction('doHover')
            endif
        endfunction

        " Highlight the symbol and its references when holding the cursor.
        " autocmd CursorHold * silent call CocActionAsync('highlight')

        " Symbol renaming.
        nmap <leader>rn <Plug>(coc-rename)

        " Formatting selected code.
        xmap <leader>f  <Plug>(coc-format-selected)
        nmap <leader>f  <Plug>(coc-format-selected)

        augroup mygroup
            autocmd!
            " Setup formatexpr specified filetype(s).
            autocmd FileType typescript,json setl formatexpr=CocAction('formatSelected')
            " Update signature help on jump placeholder.
            autocmd User CocJumpPlaceholder call CocActionAsync('showSignatureHelp')
        augroup end

        " Remap keys for applying codeAction to the current line.
        " nmap <leader>ac  <Plug>(coc-codeaction)

        " Use <TAB> for selections ranges.
        " NOTE: Requires 'textDocument/selectionRange' support from the language server.
        " coc-tsserver, coc-python are the examples of servers that support it.
        xmap <silent> <TAB> <Plug>(coc-range-select)

        " Add `:Format` command to format current buffer.
        command! -nargs=0 Format :call CocAction('format')

        " Add `:Fold` command to fold current buffer.
        command! -nargs=? Fold :call     CocAction('fold', <f-args>)

        " Add `:OR` command for organize imports of the current buffer.
        command! -nargs=0 OR   :call     CocAction('runCommand', 'editor.action.organizeImport')

        " Add (Neo)Vim's native statusline support.
        " NOTE: Please see `:h coc-status` for integrations with external plugins that
        " provide custom statusline: lightline.vim, vim-airline.
        set statusline^=%{coc#status()}%{get(b:,'coc_current_function','')}

    " Ale Linting
        let b:ale_fixers = ['eslint']
        let b:ale_linters = {
                    \ 'typescript': ['eslint'],
                    \ 'javascript': ['eslint'],
                    \ 'python': []
                    \ }
        let g:ale_enabled = 1
        " let g:ale_sign_error = '✘'
        " let g:ale_sign_warning = '⚠'
        let g:ale_sign_error = ''
        let g:ale_sign_warning = ''
        au! InsertEnter * call ALEToggleHighlights(0)
        au! InsertLeave * call ALEToggleHighlights(1)
        
        let g:AleErrorHI = GetHighlightProps("ALEError")
        let g:AleWarningHI = GetHighlightProps("ALEWarning")
        let g:AleInfoHI = GetHighlightProps("ALEInfo")

    " Vim LightLine

        " use lightline-buffer in lightline
        let g:lightline = {
            \ 'colorscheme': 'powerline',
            \ 'active': {
            \   'left':[ [ 'mode', 'paste' ],
            \            [ 'gitbranch', 'readonly', 'filename', 'modified' ]
            \   ]
            \ },
            \ 'tabline': {
            \   'left': [ [ 'bufferinfo' ],
            \             [ 'separator' ],
            \             [ 'bufferbefore', 'buffercurrent', 'bufferafter' ], ],
            \   'right': [ [ 'close' ], ],
            \ },
            \ 'component_expand': {
            \   'buffercurrent': 'lightline#buffer#buffercurrent',
            \   'bufferbefore': 'lightline#buffer#bufferbefore',
            \   'bufferafter': 'lightline#buffer#bufferafter',
            \ },
            \ 'component_type': {
            \   'buffercurrent': 'tabsel',
            \   'bufferbefore': 'raw',
            \   'bufferafter': 'raw',
            \ },
            \ 'component_function': {
            \   'bufferinfo': 'lightline#buffer#bufferinfo',
            \   'gitbranch': 'fugitive#head',
            \ },
            \ 'component': {
            \   'separator': '',
            \   'lineinfo': ' %3l:%-2v',
            \ },
        \ }

        " lightline-buffer ui settings
        " replace these symbols with ascii characters if your environment does not support unicode
        let g:lightline_buffer_logo = ' '
        let g:lightline_buffer_readonly_icon = ''
        let g:lightline_buffer_modified_icon = '~'
        let g:lightline_buffer_git_icon = ' '
        let g:lightline_buffer_ellipsis_icon = '..'
        let g:lightline_buffer_expand_left_icon = '◀ '
        let g:lightline_buffer_expand_right_icon = ' ▶'
        let g:lightline_buffer_active_buffer_left_icon = ''
        let g:lightline_buffer_active_buffer_right_icon = ''

        " enable devicons, only support utf-8
        " require <https://github.com/ryanoasis/vim-devicons>
        let g:lightline_buffer_enable_devicons = 1

        " lightline-buffer function settings
        let g:lightline_buffer_show_bufnr = 0

        " :help filename-modifiers
        let g:lightline_buffer_fname_mod = ':r'

        " hide buffer list
        let g:lightline_buffer_excludes = ['vimfiler']

        " max file name length
        let g:lightline_buffer_maxflen = 30

        " max file extension length
        let g:lightline_buffer_maxfextlen = 3

        " min file name length
        let g:lightline_buffer_minflen = 16

        " min file extension length
        let g:lightline_buffer_minfextlen = 3

        " reserve length for other component (e.g. info, close)
        let g:lightline_buffer_reservelen = 20

        let g:lightline.separator = {
            \   'left': '', 'right': ''
          \}
        let g:lightline.subseparator = {
            \   'left': '', 'right': '' 
          \}
    " YouCompleteMe
        set completeopt-=preview
        let g:ycm_show_diagnostics_ui=0
    " easy-motion
        let g:EasyMotion_enter_jump_first=1

    " auto-pairs
        let g:AutoPairs={'(':')', '[':']', '{':'}',"'":"'",'"':'"', "`":"`", '```':'```', '"""':'"""', "'''":"'''", "<":">"}
        let g:AutoPairsShortcutFastWrap = '<C-]>'
        let g:AutoPairsFlyMode = 0
        let g:AutoPairsMultilineClose = 0
        let g:AutoPairsShortcutToggle = "<M-l>"

        au FileType php let b:AutoPairs = AutoPairsDefine({'<?' : '?>', '<?php': '?>'})

    " ultisnips
        let g:UltiSnipsSnippetDirectories  = [$HOME.'/.vim/UltiSnips']
        let g:UltiSnipsExpandTrigger       = "<C-l>"
        inoremap <C-SPACE> <C-x>
        inoremap <C-x> <CMD>call UltiSnips#JumpForwards()<CR>
        inoremap <C-z> <CMD>call UltiSnips#JumpBackwards()<CR>
        vnoremap <C-x> <CMD>call UltiSnips#JumpForwards()<CR>
        vnoremap <C-z> <CMD>call UltiSnips#JumpBackwards()<CR>

    " deoplete
        let g:deoplete#enable_at_startup = 1
        autocmd CompleteDone * silent! pclose!

    " easy-motion
        autocmd StdinReadPre * let s:std_in=1
        nmap s <plug>(easymotion-overwin-f2)

    " NerdTree
        let g:NERDTreeIgnore = ['\.class$', '\.log']
        " autocmd VimEnter * if argc() == 0 && !exists("s:std_in") | NERDTree | endif
        autocmd StdinReadPre * let s:std_in=1
        " autocmd VimEnter * if argc() == 1 && isdirectory(argv()[0]) && !exists("s:std_in") | exe 'NERDTree' argv()[0] | wincmd p | ene | exe 'cd '.argv()[0] | endif
        autocmd VimEnter * if argc() == 1 && isdirectory(argv()[0]) && !exists("s:std_in") | exe 'cd '.argv()[0] | endif
        let g:NERDTreeDirArrowExpandable = '▸'
        let g:NERDTreeDirArrowCollapsible = '▾'
        let g:NERDTreeMapQuit = '<ESC>'
        let g:NERDTreeQuitOnOpen = 1
        autocmd bufenter * if (winnr("$") == 1 && exists("b:NERDTree") && b:NERDTree.isTabTree()) | bn | exe 'NERDTree' | endif
        nmap <LEADER>5 :NERDTreeClose<CR>:let @f="<C-r>%"<CR>:NERDTreeVCS<CR>:NERDTreeFind <C-r>f<CR>

        " simple click
        let NERDTreeMouseMode=3

        " NERDTree File highlighting
        function! NERDTreeHighlightFile(extension, fg, bg, guifg, guibg)
            exec 'autocmd filetype nerdtree highlight ' . a:extension .' ctermbg='. a:bg .' ctermfg='. a:fg .' guibg='. a:guibg .' guifg='. a:guifg
            exec 'autocmd filetype nerdtree syn match ' . a:extension .' #^\s\+.*'. a:extension .'$#'
        endfunction
        call NERDTreeHighlightFile('txt', 'green', 'none', 'green', '#151515')
        call NERDTreeHighlightFile('ini', 'yellow', 'none', 'yellow', '#151515')
        call NERDTreeHighlightFile('md', 'blue', 'none', '#3366FF', '#151515')
        call NERDTreeHighlightFile('yaml', 'yellow', 'none', 'yellow', '#151515')
        call NERDTreeHighlightFile('config', 'yellow', 'none', 'yellow', '#151515')
        call NERDTreeHighlightFile('conf', 'yellow', 'none', 'yellow', '#151515')
        call NERDTreeHighlightFile('json', 'yellow', 'none', 'yellow', '#151515')
        call NERDTreeHighlightFile('html', 'yellow', 'none', 'yellow', '#151515')
        call NERDTreeHighlightFile('py', 'cyan', 'none', 'cyan', '#151515')
        call NERDTreeHighlightFile('css', 'cyan', 'none', 'cyan', '#151515')
        call NERDTreeHighlightFile('coffee', 'Red', 'none', 'red', '#151515')
        call NERDTreeHighlightFile('js', 'Red', 'none', '#ffa500', '#151515')
        call NERDTreeHighlightFile('php', 'Magenta', 'none', '#ff00ff', '#151515')

    " FZF
        let g:fzf_history_dir = '~/.local/share/fzf-history'
        let g:fzf_nvim_statusline = 0 " disable statusline overwriting
        let g:fzf_layout = { 'down': '~40%' }

    " GitGutter
        let g:gitgutter_map_keys = 0
        let g:gitgutter_max_signs = 2000
        let g:gitgutter_sign_added = '▎'
        let g:gitgutter_sign_modified = '▎'
        let g:gitgutter_sign_removed = '▎'
        let g:gitgutter_sign_modified_removed = '▎'
        let g:gitgutter_sign_removed_above_and_below = '▎'
        let g:gitgutter_sign_removed_first_line = '▎'

" 
" PLUGINS
" 
    " including Vundle and initialize
    set rtp+=~/.vim/bundle/Vundle.vim
    call vundle#begin()

        " 
        " Gotta go fast!
        " 
            " move lightning fast
            Plugin 'easymotion/vim-easymotion'

            " indent range
            Plugin 'vim-indent-object'

            " fast close pairs
            Plugin 'jiangmiao/auto-pairs'

            " Fast surround shortcuts
            Plugin 'tpope/vim-surround'

            " fast comment
            Plugin 'tpope/vim-commentary'

            " Snippets
            Plugin 'sirver/UltiSnips'

        " 
        " Pretty editor
        " 
            " visual indents
            Plugin 'Yggdroot/indentLine'

            " Pretty icons
            Plugin 'ryanoasis/vim-devicons'

            " Line on the bottom of the screen
            Plugin 'itchyny/lightline.vim'

        " 
        " Language specific
        " 
            " Vue
            Plugin 'darthmall/vim-vue'

        " 
        " Others
        " 
            " Vim Blames
            Plugin 'zivyangll/git-blame.vim'

            " visual GIT modifs
            Plugin 'airblade/vim-gitgutter'

            " align everything!
            Plugin 'godlygeek/tabular'

            " Fuzzy search
            Plugin 'junegunn/fzf'
            Plugin 'junegunn/fzf.vim'

            " tree file explorer
            Plugin 'scrooloose/nerdtree'

            " Buffer stuff
            Plugin 'taohexxx/lightline-buffer'

            " Linting
            Plugin 'dense-analysis/ale' " Requires eslint to work (pacman -S eslint)

            Plugin 'neoclide/coc.nvim', {'branch': 'release'}

        " 
        " My plugins!
        " 
            Plugin 'z0rzi/vim-adaptive-indent'
            Plugin 'z0rzi/vim-super-macro'
            Plugin 'z0rzi/vim-zorzi-smoothie'
            Plugin 'z0rzi/vim-glorious-commentary'

    call vundle#end()

" 
" MAPS
" 
    " Basic Vim Shortcuts
        nnoremap >> i<C-t><ESC>
        nnoremap Y y$
        nnoremap vv v$h
        noremap <CR> %
        nnoremap S ddO
        nnoremap <M-z> <C-w>w
        " nnoremap / /\v
        vnoremap <CR> <CMD>if mode() == 'V' <BAR> call search('\%#.*\zs[{[(][;:.,\\]*$') <BAR> endif<CR>%
        vnoremap $ $h
        nnoremap - 2<C-y><C-g>
        nnoremap + 2<C-e><C-g>
        vnoremap g= c<C-r>=<C-r>+<CR><ESC>
        nnoremap g= Vc<C-r>=<C-r>+<CR><ESC>
        inoremap \'e é
        nnoremap cb xmj<CMD>call search('\<', 'b')<CR>c`j
        nnoremap db xmj<CMD>call search('\<', 'b')<CR>d`j


        " nnoremap <F3> :set hlsearch!<CR>
        nnoremap <F3> <CMD>noh<CR>
        nmap <F5> <CMD>redraw!<CR><CMD>GitGutter<CR><CMD>set foldmethod=expr<CR> " Plugin: GitGutter

        " no yank delete
            nnoremap <leader> p

        " no include newline
            nnoremap 'd ^D
            nnoremap 'D 0D
            nnoremap 'c ^C
            nnoremap 'C 0C
            nnoremap 'y mm^y$`m
            nnoremap 'Y mm0y$`m
            nnoremap 'v ^v$ho
            nnoremap 'V 0v$ho

        " move lines
            nnoremap <C-j> <CMD>m+1<CR>
            nnoremap <C-down> <CMD>m+1<CR>
            nnoremap <C-k> <CMD>m-2<CR>
            nnoremap <C-up> <CMD>m-2<CR>

            vnoremap <C-up> :m-2<CR>gv
            vnoremap <C-down> <ESC>'>jdd'<Pgv
            vnoremap <C-right> dpgvlolo
            vnoremap <C-left> dhPgvhoho


        " Duplicate lines
            nnoremap <silent> Z <CMD>set opfunc=DuplicateLines<CR>g@
            vnoremap <silent> Z :<C-u>call DuplicateLines(visualmode(), 1)<CR>gv
            nnoremap <silent> ZZ mnV:call DuplicateLines(visualmode(), 1)<CR>`n
            nnoremap <silent> zx mnV:call DuplicateLines(visualmode(), 1)<CR>`n

        " Easy search n replace
            nnoremap <C-c> <CMD>let @/="\\<".expand("<cword>")."\\>"<CR>lNcgn

        " Better ranges for XML
            nmap >it vitVkoj>
            nmap <it vitVkoj<

        " Search selection
            vnoremap * y:let @/ = escape("<C-r>0", "/\^$*.[~")<CR>/<CR>
            vnoremap # y:let @/ = escape("<C-r>0", "/\^$*.[~")<CR>?<CR>

        " Init folds
            function! FoldIfMakeSense(offset)
                let line = line('.') + matchstr(a:offset, '-\?\d*$')
                let foldline = foldclosed(line)

                if foldline != -1
                    return
                endif

                exe"".a:offset."foldclose"
            endfunction
            function! FoldAllSameLevel()
                let curpos = getcurpos()
                let saveSearch = @/
                let indent = matchstr(getline(line('.')), '^\s\+')
                exe"%g/^\\(".indent."\\s*\\S\\)\\@!\\s*\\S.*\\(\\n\\s*\\)\\+".indent."\\S/call FoldIfMakeSense('+1')"
                let @/ = saveSearch
                call setpos('.', curpos)
                noh
            endfunction
            nnoremap zff <CMD>call FoldAllSameLevel()<CR>

    " Moving mapping
        " fast exact search
            nnoremap <leader>/ /\<\><LEFT><LEFT>

        " go to next/previous match under cursor
            nnoremap <S-LEFT> <CMD>let @/ = '\<'.expand('<cword>').'\>'<CR>lbN
            nnoremap <S-RIGHT> *

        " Skip word by word with CTRL + direction
            nnoremap <C-LEFT> <CMD>call search('\<\<BAR>\u\l\<BAR>_[a-z]\<BAR>^', 'b')<CR>
            nnoremap <C-RIGHT> <CMD>call search('\w\>\<BAR>\u\l\<BAR>_[a-z]\<BAR>$')<CR>
            inoremap <C-LEFT> <CMD>call search('\<\<BAR>\u\l\<BAR>_[a-z]\<BAR>^', 'b')<CR>
            inoremap <C-RIGHT> <CMD>call search('\>\zs\<BAR>\u\l\<BAR>_[a-z]\<BAR>$')<CR>
            nnoremap <CS-LEFT> B
            nnoremap <CS-RIGHT> E
            inoremap <CS-LEFT> <CMD>norm!B<CR>
            inoremap <CS-RIGHT> <CMD>norm!E<CR><RIGHT>

        " go to end of paragraph
            nnoremap <S-UP> {(
            nnoremap <S-DOWN> })

        " Move seletion area
            vnoremap <S-UP> V<C-v>koko
            vnoremap <S-DOWN> V<C-v>jojo
            vnoremap <S-RIGHT> V<C-v>lolo
            vnoremap <S-LEFT> V<C-v>hoho

        " go to end of paragraph
            nnoremap { [(
            nnoremap } ])

        " Jumb to end/beggining of block
            nnoremap ] ]}
            nnoremap [ [{
            vnoremap ] ]}
            vnoremap [ [{

        " Easy beg/end of line
            nnoremap ^ 0
            nnoremap 0 ^
            nnoremap <S-Insert> $

        " Move between splits
            nmap <A-LEFT> <C-w><LEFT>
            nmap <A-UP> <C-w><UP>
            nmap <A-RIGHT> <C-w><RIGHT>
            nmap <A-DOWN> <C-w><DOWN>

    " Plugin related maps
        " CoC
            nnoremap <C-f> :CocSearch 

            " Tab to go through completion list
            inoremap <silent><expr> <TAB>
                  \ pumvisible() ? "\<C-n>":
                  \ <SID>check_back_space() ? "\<TAB>":
                  \ coc#refresh()
            inoremap <expr><S-TAB> pumvisible() ? "\<C-p>" : "\<C-h>"

            inoremap <expr> <cr> pumvisible() ? "\<C-y>" : "\<C-g>u\<CR>"

            " Close the preview window when completion is done.
            autocmd! CompleteDone * if pumvisible() == 0 | pclose | endif

            " nmap <silent> <C-c> <Plug>(coc-cursors-position)
            " nmap <silent> <C-d> <Plug>(coc-cursors-word)
            " xmap <silent> <C-d> <Plug>(coc-cursors-range)
            " use normal command like `<leader>xi(`
            " nmap <leader>x  <Plug>(coc-cursors-operator)

        " Ale
            nnoremap <LEADER>jn <CMD>ALENext<CR>
            nnoremap <LEADER>jp <CMD>ALEPrevious<CR>

        " Git stuff
            " Plugin: GitGutter
            nnoremap <LEADER>gu <CMD>sil!GitGutterUndoHunk<CR>
            nnoremap <LEADER>gn <CMD>sil!GitGutterNextHunk<CR>
            nnoremap <LEADER>gp <CMD>sil!GitGutterPrevHunk<CR>
            nnoremap <LEADER>gP <CMD>sil!GitGutterPreviewHunk<CR>
            nnoremap <LEADER>gh <CMD>sil!GitGutterLineHighlightsToggle<CR>
            nnoremap <LEADER>gd <CMD>Gdiffsplit<CR>
            nnoremap <LEADER>gb <CMD>GitBlame<CR>

        " Tabular indenting
            nnoremap <leader>t= mm<CMD>Tabular /^[^=]*\zs=<CR>`m
            nnoremap <leader>t: mm<CMD>Tabular /^[^:]*:\zs/l0r1<CR>`m
            nnoremap <leader>t> mm<CMD>Tabular /^[^=]*\zs=>/<CR>`m
            nnoremap <leader>t<SPACE> mm<CMD>Tabular / *\zs /l0<CR>`m
            vnoremap <leader>t= :Tabular /^[^=]*\zs=<CR>
            vnoremap <leader>t: :Tabular /:\zs<CR>
            vnoremap <leader>t<SPACE> :Tabular / *\zs /l0<CR>
            nnoremap <leader>t> mm<CMD>Tabular /^[^=]*\zs=>/<CR>`m

            " nmap <leader>t* mm?/\*\*<CR>kmn:/\/\*\*/,/\*\//s/^\s\+\*\s\+@\S\+\zs\s\+/ /<CR>`n:/\/\*\*/,/\*\//s/^\s\+\*\s\+@\(param\\|return\)\s\+\S\+\zs\s\+/ /<CR>`n:/\/\*\*/,/\*\//s/@param\s\+\S\+\s\+\S\+\zs\s\+/ /<CR>`nO<ESC>0CTabular /^\s\+\*\s\+@\S\+\s*\zs\s/l0\|Tabular /^\s\+\*\s\+@\(param\\|return\)\s\+\S\+\s*\zs\s/l0\|Tabular /^\s\+\*\s\+@param\s\+\S\+\s\+\S\+\s*\zs\s/l0<ESC>:s/[^\\]\zs\|/\r/g<CR>^tDddk^"rDddk^"eDdd`n:/\/\*\*/,/\*\//g/./<C-r>e<CR>`n:/\/\*\*/,/\*\//g/./<C-r>r<CR>`n:/\/\*\*/,/\*\//g/./<C-r>t<CR>`m

            nnoremap <leader>t :Tabular /
            vnoremap <leader>t :Tabular /

        " NerdTree toggle
            map <LEADER>f <CMD>NERDTreeToggle<CR>
            map <F2> <CMD>NERDTreeToggle<CR>

        " FZF
            nnoremap <C-p> <CMD>call FZFFindFile()<CR>
            " nnoremap <CS-f> <CMD>call FZFFindWordUnderCursor()<CR>
            nnoremap <C-s> <CMD>call FZFFindWord()<CR>
            nnoremap <LEADER>u <CMD>call FZFUnicode()<CR>


        " Commentary
            nnoremap  <CMD>Commentary<CR>
            inoremap  <CMD>Commentary<CR>
            vnoremap  :Commentary<CR>gv

    " Buffer related maps
        " Buffers navigation 
            nnoremap <Tab> <CMD>bnext<CR>
            nnoremap <S-Tab> <CMD>bprev<CR>

        " Buffer management
            nnoremap <LEADER>q <CMD>b#<BAR>bd#<CR>

    " New Ideas
        " Fast insert mode
            nnoremap <LEADER>b bi
            nnoremap <LEADER>i bi
            nnoremap <LEADER>B Bi
            nnoremap <LEADER>I Bi
            nnoremap <LEADER>e ea
            nnoremap <LEADER>a ea
            nnoremap <LEADER>E Ea
            nnoremap <LEADER>A Ea
            nnoremap <LEADER>= f=a
            nnoremap <LEADER>. f.a

        " Double Tap shortcut
            inoremap )) (<CMD>call SmartJumpToEnd()<CR><RIGHT>)
            inoremap ]] [<CMD>call SmartJumpToEnd()<CR><RIGHT>]
            inoremap }} {<CMD>call SmartJumpToEnd()<CR><RIGHT>}
            inoremap )<TAB> (<CMD>call SmartJumpToEnd()<CR><RIGHT>)
            inoremap ]<TAB> [<CMD>call SmartJumpToEnd()<CR><RIGHT>]
            inoremap }<TAB> {<CMD>call SmartJumpToEnd()<CR><RIGHT>}

        " Backspace selector
            nnoremap d<BS> mm^<CMD>call search('[{\[(]$')<CR>%d'm
            nnoremap c<BS> mm^<CMD>call search('[{\[(]$')<CR>%c'm
            nnoremap c<BS> mm^<CMD>call search('[{\[(]$')<CR>%y'm
            nnoremap v<BS> mm^<CMD>call search('[{\[(]$')<CR>v'mo%Vo
            nnoremap <<BS> mm^<CMD>call search('[{\[(]$')<CR>%<'m
            nnoremap ><BS> mm^<CMD>call search('[{\[(]$')<CR>%>'m

        " Paste selector
            nnoremap >p mm`[>`]`m
            nnoremap <p mm`[<`]`m
            nnoremap dp '[d']
            nnoremap =p mm`[=`]`m

        " Easy delete until...
            nnoremap v; vt;
            nnoremap v: vt:
            nnoremap v) vt)
            nnoremap v} vt}
            nnoremap v> vt>
            nnoremap v] vt]
            nnoremap v. vt.
            nnoremap v" vt"
            nnoremap v' vt'
            nnoremap v, vt,
            onoremap ; t;
            onoremap : t:
            onoremap ) t)
            onoremap ( t(
            onoremap } t}
            onoremap > t>
            onoremap ] t]
            onoremap . t.
            onoremap " t"
            onoremap ' t'
            onoremap , t,
            nnoremap c= ^<CMD>call search('= \?\zs\\|$')<CR>mm<CMD>call search('[;,]\?$')<CR>mn`mc`n
            nnoremap d= ^<CMD>call search('= \?\zs\\|$')<CR>mm<CMD>call search('[;,]\?$')<CR>mn`md`n

        " Until MAJ or underscore
            nnoremap dq mm<CMD>call search('\u\\|\>\\|_')<CR>d`m
            nnoremap cq mm<CMD>call search('\u\\|\>\\|_')<CR>c`m
            inoremap <C-q> <SPACE><LEFT><CMD>exe "norm!mm" <BAR> call search('\u\<BAR>\<\<BAR>_\zs\w', 'b') <BAR> exe "norm!d`m"<CR><DEL>

        " Delete after cursor in insert
            inoremap <C-e> <CMD>norm!de<CR>

        " semi-column things
            inoremap ;; <CMD>call setline('.', getline('.') . ';')<CR>
            inoremap ;a <C-o>A
            inoremap ;. <CMD>norm!$<CR><RIGHT>.
            inoremap ;, <C-o>A,
            inoremap <C-SPACE> <RIGHT>

        " select multiple lines in a VSCode Style
            nnoremap <CS-DOWN> <C-v>j
            nnoremap <CS-UP> <C-v>k
            vnoremap <CS-DOWN> j
            vnoremap <CS-UP> k
            vnoremap <LEADER>i I
            vnoremap <LEADER>a A
            vnoremap <LEADER>I ^I
            vnoremap <LEADER>A $A

        " Around selection, completes the vim-surround plugin
            vmap m S
            vnoremap m/ c//<ESC>P
            vnoremap m_ c__<ESC>P
            vnoremap m+ c++<ESC>P
            vnoremap m. c..<ESC>P
            vnoremap m<SPACE> c<SPACE><SPACE><ESC>P
            vnoremap m<BS> dvhpgv

        " Smallest range possible
            onoremap io <CMD>call SelectSmallestRangePossible(0)<CR>
            onoremap ao <CMD>call SelectSmallestRangePossible(1)<CR>
            vnoremap io <ESC>:call SelectSmallestRangePossible(0)<CR>
            vnoremap ao <ESC>:call SelectSmallestRangePossible(1)<CR>

" 
" AUTOCMD
" 
    " taking back position at buffer open
        autocmd BufReadPost * silent!norm!g;
        autocmd BufLeave * call AutoSaveWinView()
        autocmd BufEnter * call AutoRestoreWinView()

    " Correcting bad commenting for specific languages | Plugin: Commentary
        autocmd! BufEnter *.php :let b:commentary_format="// %s"
        autocmd! BufEnter *.vue :let b:commentary_format="// %s"
        autocmd! BufEnter *.ts :let b:commentary_format="// %s"
        autocmd! BufEnter *.coffee :let b:commentary_format="# %s"
        autocmd! BufEnter *.conf :let b:commentary_format="# %s"

    " Faaast language specific iab
        autocmd FileType javascript,typescript iab <buffer> c const<CMD>sil!s/const\zs\s*// <BAR> call search('const\zs') <BAR> noh<CR>
        autocmd FileType javascript,typescript iab <buffer> aw await<CMD>sil!s/await\zs\s*// <BAR> call search('await\zs') <BAR> noh<CR>
        autocmd FileType javascript,typescript iab <buffer> l let<CMD>sil!s/let\zs\s*// <BAR> call search('let\zs') <BAR> noh<CR>
        autocmd FileType javascript,typescript iab <buffer> r return<CMD>sil!s/let\zs\s*// <BAR> call search('return\zs') <BAR> noh<CR>
        autocmd FileType javascript,typescript iab <buffer> ff <CMD>if match(getline(line('.')), ')$') != -1 <BAR> call setline('.', getline('.') . ';') <BAR> endif<CR>() => {<CR><SPACE><BS><C-o>g
        autocmd FileType javascript,typescript inoreab <buffer> ii if<SPACE>()<LEFT><C-o>g
        autocmd FileType javascript,typescript inoreab <buffer> tryc try {<CMD>call SmartJumpToEnd()<CR>} catch (err) {<CR>}<C-o>O<SPACE><BS><C-o>z

    " Language specific maps
        autocmd FileType html,php inoremap >> <ESC>ya>Pf<a <ESC>wyiwvi>pT<i/<C-o>T>

    " Correcting FZF buffer | Plugin: FZF
        autocmd! FileType fzf
        autocmd  FileType fzf set laststatus=0 noshowmode noruler
          \| autocmd BufLeave <buffer> set laststatus=2 showmode ruler

    " refreshing file when modified outside of vim
        autocmd BufEnter * checktime
        autocmd FocusGained * checktime
        " autocmd InsertLeave * GitGutter
        " autocmd TextChanged * GitGutter
        autocmd BufWritePost * GitGutter

    " Unsupported files formats
        autocmd BufEnter *.abnf set filetype=abnf
        autocmd BufEnter *.fish set filetype=fish
        autocmd BufNewFile,BufRead *.vue set filetype=vue
        autocmd BufNewFile,BufRead *.coffee set filetype=coffee

" 
" ABREVS
" 
    " Comments shortcut
        iab /// //<ENTER><C-o>O
        iab /** /**<CR><CR>/<UP>

    " 
    " Mistypes
    " 
        iab cnosole console
        iab cnosoel console
        iab cnsole console
        iab loaction location
        iab loaciton location 

    " French Accents
        iab etre être
        iab occupee occupée
        iab entete entête
        iab entetes entêtes
        iab requete requête
        iab etudiant étudiant
        iab etudiants étudiants
        iab ecole école
        iab ecoles écoles
        iab etais étais
        iab etait était
        iab implemente implémente
        iab implementation implémentation

    " Unicode
        iab \> ➤
        iab \\> ⤷
        iab \! ⚠
        iab \--- ――――――――――――――――――――
