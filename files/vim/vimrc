"
" GENERAL NATIVE VIM SETTINGS
"
    syn on
    filetype on
    set nu
    set wrap
    set ruler
    set hidden
    set showtabline=2  " always show tabline
    set noshowmode

    set ve=block
    set hlsearch
    set incsearch

    set smartindent
    set autoindent

    set wildmenu
    set showcmd
    set scrolloff=5
    " set relativenumber
    set conceallevel=2
    set nostartofline
    set mouse=a

    set formatoptions=cro
    set clipboard=unnamedplus

    set swapfile
    set dir=/tmp
    set modeline

    " to refresh file on git checkout
        set autoread

    set tabstop=4 shiftwidth=4 expandtab

    " Considering '-' as part of a word
        " set iskeyword+=-

    " change the leader key to <space>
        let g:mapleader = "\<Space>"
    " Don't conceal markdown
        let g:vim_markdown_conceal_code_blocks=0
        let g:vim_markdown_conceal=0
    " Ignored files ( formated in bash style, like in the `ls` command )
        let g:ignoredDirs = [ '__pycache__', '.git', 'cache', 'node_modules', 'coverage', 'dist' ]
        let g:ignoredFiles = [ '*.log', '*.class' ]


"
" LOOKS AND FEEL
"
    " General
        colorscheme gruvbox
        set fillchars=stl:\ ,stlnc:=,vert:│,fold:\ ,diff:-
        set listchars=tab:.\ , list

    " Folding
        let g:foldMode=1
        set foldmethod=indent
        set foldlevelstart=99
        set foldmethod=expr
        set foldexpr=FindFoldLevel(v:lnum)
        set foldtext=NeatFoldText()

    " GruvBox config
        let g:gruvbox_italic = 1
        let g:gruvbox_termcolors = 256
        let g:gruvbox_contrast_dark = "medium"
        let g:gruvbox_invert_selection = 1
        let g:gruvbox_invert_signs = 0  " for GitGutter signs
        let g:gruvbox_guisp_fallback = 'bg'

    " GVim
        set guioptions-=m  "remove menu bar
        set guioptions-=T  "remove toolbar
        set guioptions-=r  "remove right-hand scroll bar
        set guioptions-=L  "remove left-hand scroll bar
        set background=dark

    " language specific
        " python
            " let g:python_highlight_all
            let g:python_highlight_builtin_funcs=1
            let g:python_highlight_builtin_objs=1
            let g:python_highlight_builtins=1
            let g:python_highlight_doctests=1
            let g:python_highlight_exceptions=1
            let g:python_highlight_file_headers_as_comments=1
            let g:python_highlight_indent_errors=0
            let g:python_highlight_space_errors=0
            let g:python_highlight_string_format=1
            let g:python_highlight_string_formatting=1
            let g:python_highlight_string_templates=1
            let g:python_print_as_function=1
            let g:python_slow_sync=0
            let g:python_version_2=0

"
" FUNCTIONS
"
    function! GetGroupName()
        if !exists("*synstack" )
            return
        endif
        echo map(synstack(line('.'), col('.')), 'synIDattr(v:val, "name" )')
    endfunction

    function! FindFoldLevel(lnum)
        if getline(a:lnum)=~'^$'
            let i = 0
            while 1
                if ! (getline(a:lnum + i) =~ '^$')
                    return indent(a:lnum + i)
                endif
                let i += 1
                if i > 10
                    return -1
                endif
            endwhile
        endif
        
        let nextIndent = 0
        let i = 0
        while nextIndent == 0
            let i += 1
            if i > 10
                break
            endif
            if ! (getline(a:lnum + i) =~ '^$')
                let nextIndent = indent(a:lnum + i)
            endif
        endwhile

        if indent(a:lnum) < nextIndent
            if g:foldMode == 0
                return '>' . nextIndent
            elseif g:foldMode == 0
                return indent(a:lnum)
            endif
        endif
        
        " next line is a fold start
        if indent(a:lnum) > indent(a:lnum + 1) && FindFoldLevel(a:lnum + 1) =~ '^>'
            return '<' . indent(a:lnum)
        endif

        return indent(a:lnum)
    endfunction

    function! FoldIfMakesSense()
        let lnum = line('.')

        let nextIndent = 0
        let i = 0
        while nextIndent == 0
            let i += 1
            if i > 10
                break
            endif
            if ! (getline(lnum + i) =~ '^$')
                let nextIndent = indent(lnum + i)
            endif
        endwhile

        let condition = 0
        if g:foldMode == 0
            let condition = foldlevel(lnum) <= foldlevel(lnum+1) && indent(lnum) < nextIndent
        elseif g:foldMode == 1
            let condition = foldlevel(lnum-1) < foldlevel(lnum) && indent(lnum-1) < nextIndent
        endif

        if condition
            foldclose
        endif
    endfunction

    function! NeatFoldText()

        let foldchar         = matchstr(&fillchars, 'fold:\zs.')
        let line             = ' ' . substitute(getline(v:foldstart), '^\s*"\?\s*\|\s*"\?\s*{{' . '{\d*\s*', '', 'g') . ' '
        let lines_count      = v:foldend - v:foldstart + 1
        let lines_count_text = '» ' . printf("%10s", lines_count . ' lines') . repeat(foldchar, v:foldlevel*2)
        " let foldtextstart    = strpart('+' . repeat(foldchar, v:foldlevel*2) . line, 0, (winwidth(0)*2)/3)
        if g:foldMode == 0
            let foldtextstart    = getline(v:foldstart) . " ••• " 
        elseif g:foldMode == 1
            let foldtextstart    = repeat(' ', indent(v:foldstart-1) + 4 ) . " ••• " 
        endif
        let foldtextend      = lines_count_text . repeat(foldchar, 8)
        let foldtextlength   = strlen(substitute(foldtextstart . foldtextend, '.', 'x', 'g')) + &foldcolumn
        return foldtextstart . repeat(foldchar, winwidth(0)-foldtextlength) . foldtextend
    endfunction

    function! CssMinify()
        %s/\n//g
        %s/\s\+\([:;{,><}]\)/\1/g
        %s/\([:;{,><}]\)\s\+/\1/g
        set filetype=css
    endfunction

    function! CssMaxify()
        %s/\([^;}]\)}/\1;}/g
        %s/}/\r}\r/g
        %s/;/;\r/g
        %s/{/\r{\r/g
        %s/{/\r{\r/g
        %s/^\s*\n//
        %s/\t//g
        %s/[><,]/ & /g
        norm! gg<G
        norm! gg<G
        norm! gg<G
        %g/{/norm!>i{
        %s/^\(#.*\)\n\(\t\+\)/\2\1\r\2/
        g/@keyframes/norm!J
        %s/ \+/ /g
        set filetype=css
    endfunction

    function! JsonMinify()
        %s/\n//
        %s/\s\+\([:{,\[\]}]\)/\1/g
        %s/\([:{,\[\]}]\)\s\+/\1/g
        set filetype=json
    endfunction

    function! GetOneChar()
        let l:number = 1
        let l:string = ""

        while l:number > 0
            let l:string .= nr2char(getchar())
            let l:number -= 1
        endwhile

        return l:string
    endfunction

    function! SelectSmallestRangePossible(external)
        let lineCopy = getline('.')
        let curPos = col('.')
        
        let lineCopy = lineCopy[:curPos-2] . '@' . lineCopy[curPos-1] . '@' . lineCopy[curPos:]

        " echo lineCopy
        let lineCopy = substitute(lineCopy, '[^"[\](){}@<>`'."'".']', '', 'g')

        let i=0
        while lineCopy =~ '{}\|\[\]\|()\|""\|<>\|``\|'."''"
            let lineCopy = substitute(lineCopy, '{}\|\[\]\|()\|""\|``\|<>\|'."''", '', 'g')
            if i>10
                break
            endif
        endwhile
        let lineCopy = substitute(lineCopy, '@@', '@', 'g')

        let cara = matchstr(lineCopy, '.\ze@[^@]*$')

        if cara == ''
            return
        endif
        
        let cmd = "normal! vi" . cara
        if a:external
            let cmd = cmd . 'loho'
        endif
        execute cmd
    endfunction

    function! VimToGrepRegex(str)
        let rx = a:str

        let gargs = ""

        let rx = substitute(rx, '\\<\|\\>','\\b', 'g')

        if rx =~ '^\\c'
            let rx = substitute(rx, '^\\c','', '')
            let gargs .= " -i"
        endif

        return [rx, gargs]
    endfunction

    function! FZFFindFile()
        let ignoredFilesStr = ''
        for f in g:ignoredFiles
            let ignoredFilesStr .= ' ! -name "' . f . '"'
        endfor

        let ignoredDirsStr = ''
        for d in g:ignoredDirs
            let ignoredDirsStr .= ' ! -path "*/' . d . '/*"'
        endfor

        let cmd = 'ls --color=never -t $(find . -type f  ' . ignoredFilesStr . ' ' . ignoredDirsStr . ') 2> /dev/null'
        silent! exe fzf#run({'source': cmd, 'sink': 'e', 'options': '-d/ -n-1 --history /home/zorzi/.local/share/fzf-history/FZF --multi --no-sort --preview="git diff {}" --sync', 'down':'40%'})
    endfunction
    function! s:FZFOpenVimOutput(str)
        let thefile = matchstr(a:str, '^.\{-\}\ze:')
        let theline = matchstr(a:str, '^.\{-\}:\zs\d\+\ze:')
        silent! exe 'edit ' . fnameescape(thefile)
        echo cursor(theline,0)
    endfunction
    function! FZFFindWordUnderCursor()
        set hlsearch
        let @/ = expand("<cword>")
        call FZFFind(expand("<cword>"))
    endfunction
    function! FZFFindWord()
        let curline = getline('.')
        call inputsave()
        let str = input('> ')
        call inputrestore()
        call FZFFind(str)
    endfunction
    function! FZFFind(str)
        let [grepStr, grepArgs] = VimToGrepRegex(a:str)

        let previewLines = string(winheight(0) * 0.2)
        
        let ignoredFilesStr = ''
        for f in g:ignoredFiles
            let ignoredFilesStr .= ' ! -name "' . f . '"'
        endfor

        let ignoredDirsStr = ''
        for d in g:ignoredDirs
            let ignoredDirsStr .= ' ! -path "*/' . d . '/*"'
        endfor

        let cmd = 'grep -Isnr ' . grepArgs . ' --color=always "' . grepStr . '" $(ls --color=never -t $(find . -type f  ' . ignoredFilesStr . ' ' . ignoredDirsStr . ') 2> /dev/null )'
        let preview = '"awk -F: ''{printf(\"sed -n %d,%dp %s\",(\$2>'.previewLines.'?\$2-'.previewLines.':1), \$2+'.previewLines.', \$1)}'' <<< {} | xargs -I% bash -c \"%\" | grep --color=always -C100 \"' . grepStr . '\""'
        " let preview = ''
        let g:cmd = preview
        call fzf#run({'source': cmd, 'sink': function('s:FZFOpenVimOutput'), 'options': '--no-sort --ansi --multi --sync --preview=' . preview , 'down':'40%' })
    endfunction
    function! s:FZFPrintUnicode(line)
        let cara = matchstr( a:line, '\S\ze\s' )
        exe 'silent !grep "^'.cara.'" $HOME/.vim/customFiles/unicode_chars.txt > /tmp/unicode_temp.txt'
        exe 'silent !grep -v "^'.cara.'" $HOME/.vim/customFiles/unicode_chars.txt >> /tmp/unicode_temp.txt'
        exe 'silent !mv /tmp/unicode_temp.txt $HOME/.vim/customFiles/unicode_chars.txt'
        exe "norm!i" . cara
    endfunction
    function! FZFUnicode()
        let cmd = 'cat $HOME/.vim/customFiles/unicode_chars.txt'
        call fzf#run({'source': cmd, 'sink': function('s:FZFPrintUnicode'), 'options': '--no-sort --ansi', 'down':'40%' })
    endfunction

    " Save current view settings on a per-window, per-buffer basis.
    function! AutoSaveWinView()
        if !exists("w:SavedBufView")
            let w:SavedBufView = {}
        endif
        let w:SavedBufView[bufnr("%")] = winsaveview()
    endfunction
    " Restore current view settings.
    function! AutoRestoreWinView()
        let buf = bufnr("%")
        if exists("w:SavedBufView") && has_key(w:SavedBufView, buf)
            let v = winsaveview()
            let atStartOfFile = v.lnum == 1 && v.col == 0
            if atStartOfFile && !&diff
                call winrestview(w:SavedBufView[buf])
            endif
            unlet w:SavedBufView[buf]
        endif
    endfunction


"
" PLUGINS CONFIG
"
    " Ale Linting
        let b:ale_fixers = ['eslint']
        let b:ale_linters = ['eslint']
        let g:ale_enabled = 1
        let g:ale_sign_error = '✘'
        let g:ale_sign_warning = '⚠️'

    " Vim LightLine

        " use lightline-buffer in lightline
        let g:lightline = {
            \ 'colorscheme': 'powerline',
            \ 'active': {
            \   'left':[ [ 'mode', 'paste' ],
            \            [ 'gitbranch', 'readonly', 'filename', 'modified' ]
            \   ]
            \ },
            \ 'tabline': {
            \   'left': [ [ 'bufferinfo' ],
            \             [ 'separator' ],
            \             [ 'bufferbefore', 'buffercurrent', 'bufferafter' ], ],
            \   'right': [ [ 'close' ], ],
            \ },
            \ 'component_expand': {
            \   'buffercurrent': 'lightline#buffer#buffercurrent',
            \   'bufferbefore': 'lightline#buffer#bufferbefore',
            \   'bufferafter': 'lightline#buffer#bufferafter',
            \ },
            \ 'component_type': {
            \   'buffercurrent': 'tabsel',
            \   'bufferbefore': 'raw',
            \   'bufferafter': 'raw',
            \ },
            \ 'component_function': {
            \   'bufferinfo': 'lightline#buffer#bufferinfo',
            \   'gitbranch': 'fugitive#head',
            \ },
            \ 'component': {
            \   'separator': '',
            \   'lineinfo': ' %3l:%-2v',
            \ },
        \ }

        " lightline-buffer ui settings
        " replace these symbols with ascii characters if your environment does not support unicode
        let g:lightline_buffer_logo = ' '
        let g:lightline_buffer_readonly_icon = ''
        let g:lightline_buffer_modified_icon = '~'
        let g:lightline_buffer_git_icon = ' '
        let g:lightline_buffer_ellipsis_icon = '..'
        let g:lightline_buffer_expand_left_icon = '◀ '
        let g:lightline_buffer_expand_right_icon = ' ▶'
        let g:lightline_buffer_active_buffer_left_icon = ''
        let g:lightline_buffer_active_buffer_right_icon = ''
        " let g:lightline_buffer_separator_icon = '  '
        " let g:lightline_buffer_separator_right_icon = ' '
        " let g:lightline_buffer_separator_left_icon = ' '

        " enable devicons, only support utf-8
        " require <https://github.com/ryanoasis/vim-devicons>
        let g:lightline_buffer_enable_devicons = 1

        " lightline-buffer function settings
        let g:lightline_buffer_show_bufnr = 0

        " :help filename-modifiers
        let g:lightline_buffer_fname_mod = ':t'

        " hide buffer list
        let g:lightline_buffer_excludes = ['vimfiler']

        " max file name length
        let g:lightline_buffer_maxflen = 30

        " max file extension length
        let g:lightline_buffer_maxfextlen = 3

        " min file name length
        let g:lightline_buffer_minflen = 16

        " min file extension length
        let g:lightline_buffer_minfextlen = 3

        " reserve length for other component (e.g. info, close)
        let g:lightline_buffer_reservelen = 20

        let g:lightline.separator = {
            \   'left': '', 'right': ''
          \}
        let g:lightline.subseparator = {
            \   'left': '', 'right': '' 
          \}
    " YouCompleteMe
        set completeopt-=preview
    " easy-motion
        let g:EasyMotion_enter_jump_first=1

    " auto-pairs
        let g:AutoPairs={'(':')', '[':']', '{':'}',"'":"'",'"':'"', "`":"`", '```':'```', '"""':'"""', "'''":"'''", "<":">"}
        let g:AutoPairsShortcutFastWrap = '<C-]>'
        let g:AutoPairsFlyMode = 0
        let g:AutoPairsMultilineClose = 0
        let g:AutoPairsShortcutToggle = "<M-l>"

        au FileType php let b:AutoPairs = AutoPairsDefine({'<?' : '?>', '<?php': '?>'})

    " ultisnips
        let g:UltiSnipsSnippetDirectories  = [$HOME.'/.vim/UltiSnips']
        let g:UltiSnipsExpandTrigger       = "<C-l>"
        let g:UltiSnipsJumpForwardTrigger  = "<C-x>"
        let g:UltiSnipsJumpBackwardTrigger = "<C-z>"

    " deoplete
        let g:deoplete#enable_at_startup = 1
        autocmd CompleteDone * silent! pclose!

    " easy-motion
        autocmd StdinReadPre * let s:std_in=1
        nmap s <plug>(easymotion-overwin-f2)
    
    " NerdTree
        let g:NERDTreeIgnore = ['\.class$', '\.log']
        " autocmd VimEnter * if argc() == 0 && !exists("s:std_in") | NERDTree | endif
        autocmd StdinReadPre * let s:std_in=1
        autocmd VimEnter * if argc() == 1 && isdirectory(argv()[0]) && !exists("s:std_in") | exe 'NERDTree' argv()[0] | wincmd p | ene | exe 'cd '.argv()[0] | endif
        let g:NERDTreeDirArrowExpandable = '▸'
        let g:NERDTreeDirArrowCollapsible = '▾'
        let g:NERDTreeMapQuit = '<ESC>'
        let g:NERDTreeQuitOnOpen = 1
        autocmd bufenter * if (winnr("$") == 1 && exists("b:NERDTree") && b:NERDTree.isTabTree()) | bn | exe 'NERDTree' | endif
        nmap <LEADER>5 :NERDTreeClose<CR>:let @f="<C-r>%"<CR>:NERDTreeVCS<CR>:NERDTreeFind <C-r>f<CR>

        " simple click
        let NERDTreeMouseMode=3

        " NERDTree File highlighting
        function! NERDTreeHighlightFile(extension, fg, bg, guifg, guibg)
            exec 'autocmd filetype nerdtree highlight ' . a:extension .' ctermbg='. a:bg .' ctermfg='. a:fg .' guibg='. a:guibg .' guifg='. a:guifg
            exec 'autocmd filetype nerdtree syn match ' . a:extension .' #^\s\+.*'. a:extension .'$#'
        endfunction
        call NERDTreeHighlightFile('txt', 'green', 'none', 'green', '#151515')
        call NERDTreeHighlightFile('ini', 'yellow', 'none', 'yellow', '#151515')
        call NERDTreeHighlightFile('md', 'blue', 'none', '#3366FF', '#151515')
        call NERDTreeHighlightFile('yaml', 'yellow', 'none', 'yellow', '#151515')
        call NERDTreeHighlightFile('config', 'yellow', 'none', 'yellow', '#151515')
        call NERDTreeHighlightFile('conf', 'yellow', 'none', 'yellow', '#151515')
        call NERDTreeHighlightFile('json', 'yellow', 'none', 'yellow', '#151515')
        call NERDTreeHighlightFile('html', 'yellow', 'none', 'yellow', '#151515')
        call NERDTreeHighlightFile('py', 'cyan', 'none', 'cyan', '#151515')
        call NERDTreeHighlightFile('css', 'cyan', 'none', 'cyan', '#151515')
        call NERDTreeHighlightFile('coffee', 'Red', 'none', 'red', '#151515')
        call NERDTreeHighlightFile('js', 'Red', 'none', '#ffa500', '#151515')
        call NERDTreeHighlightFile('php', 'Magenta', 'none', '#ff00ff', '#151515')

    " FZF
        let g:fzf_history_dir = '~/.local/share/fzf-history'
        let g:fzf_nvim_statusline = 0 " disable statusline overwriting
        let g:fzf_layout = { 'down': '~40%' }

    " GitGutter
        let g:gitgutter_max_signs = 2000

"
" PLUGINS
"
    " including Vundle and initialize
    set rtp+=~/.vim/bundle/Vundle.vim
    call vundle#begin()

        " 
        " Gotta go fast!
        "
            " move lightning fast
            Plugin 'easymotion/vim-easymotion'

            " indent range
            Plugin 'vim-indent-object'

            " fast close pairs
            Plugin 'jiangmiao/auto-pairs'

            " Fast surround shortcuts
            Plugin 'tpope/vim-surround'

            " fast comment
            Plugin 'tpope/vim-commentary'

            " Autocomplete
            " Plugin 'Shougo/deoplete.nvim'
            Plugin 'ycm-core/YouCompleteMe'

            " Snippets
            Plugin 'sirver/UltiSnips'

        "
        " Pretty editor
        "
            " Pretty CSV files
            Plugin 'mechatroner/rainbow_csv'

            " visual indents
            Plugin 'Yggdroot/indentLine'

            " Pretty icons
            Plugin 'ryanoasis/vim-devicons'

            " " Line on top of screen
            " Plugin 'vim-airline/vim-airline'

            " Line on the bottom of the screen
            Plugin 'itchyny/lightline.vim'

        "
        " Language specific
        "
            " NodeJS
            Plugin 'viruschidai/vim-as-nodejs-ide'
            Plugin 'myhere/vim-nodejs-complete'

        "
        " Others
        "
            " Vim Blames
            Plugin 'zivyangll/git-blame.vim'

            " visual GIT modifs
            Plugin 'airblade/vim-gitgutter'

            " align everything!
            Plugin 'godlygeek/tabular'

            " Fuzzy search
            Plugin 'junegunn/fzf'
            Plugin 'junegunn/fzf.vim'

            " tree file explorer
            Plugin 'scrooloose/nerdtree'

            " Buffer stuff
            " Plugin 'mildred/vim-bufmru'
            Plugin 'taohexxx/lightline-buffer'

            " Linting
            Plugin 'dense-analysis/ale' " Requires eslint to work (pacman -S eslint)

        "
        " My plugins!
        "
            Plugin 'z0rzi/vim-adaptive-indent'
            Plugin 'z0rzi/vim-super-macro'
            Plugin 'z0rzi/vim-zorzi-smoothie'
            Plugin 'z0rzi/vim-glorious-commentary'

    call vundle#end()

"
" MAPS
"
    " Basic Vim Shortcuts
        nnoremap >> i<C-t><ESC>
        nnoremap Y y$
        noremap <ENTER> %
        nnoremap - 2<C-y><C-g>
        nnoremap + 2<C-e><C-g>
        vnoremap g= c<C-r>=<C-r>+<CR><ESC>
        nnoremap g= Vc<C-r>=<C-r>+<CR><ESC>
        inoremap \'e é
        nnoremap cb xmj:call search('\<', 'b')<CR>c`j
        nnoremap db xmj:call search('\<', 'b')<CR>d`j


        " nnoremap <F3> :set hlsearch!<CR>
        nnoremap <F3> :noh<CR>
        nmap <F5> :redraw!<CR>:GitGutter<CR>:set foldmethod=expr<CR> " Plugin: GitGutter

        " no yank delete
            nnoremap <leader> "p

        " no include newline
            nnoremap 'd ^D
            nnoremap 'D 0D
            nnoremap 'c ^C
            nnoremap 'C 0C
            nnoremap 'y mm^y$`m
            nnoremap 'Y mm0y$`m
            nnoremap 'v ^v$ho
            nnoremap 'V 0v$ho

        " move lines
            nnoremap <C-j> :m+1<CR>
            nnoremap <C-down> :m+1<CR>
            nnoremap <C-k> :m-2<CR>
            nnoremap <C-up> :m-2<CR>

            vnoremap <C-up> :m-2<CR>gv
            vnoremap <C-down> <ESC>'>jdd'<Pgv
            vnoremap <C-right> dpgvlolo
            vnoremap <C-left> dhPgvhoho

        " Easy access macro
            nmap Z @
            nmap ZZ @@

        " Easy search n replace
            nnoremap <C-c> :let @/="\\<".expand("<cword>")."\\>"<CR>lNcgn

        " Better ranges for XML
            nmap >it vitVkoj>
            nmap <it vitVkoj<

        " Search selection
            vnoremap * y/<C-r>0<CR>
            vnoremap # y?<C-r>0<CR>

        " Init folds
            " nnoremap zff mm0"syw:%g/^<C-r>s[^[:blank:]#].*\ze\n/call FoldIfMakesSense()<CR>`m
            nnoremap zff mm0"syw:%g/^<C-r>s[^[:blank:]#].*\n*<C-r>s\zs\s/+1call FoldIfMakesSense()<CR>`m

    " Moving mapping
        " fast exact search
            nnoremap <leader>/ /\<\><LEFT><LEFT>

        " go to next/previous match under cursor
            nnoremap <S-LEFT> #
            nnoremap <S-RIGHT> *

        " Skip word by word with CTRL + direction
            nnoremap <C-RIGHT> w
            nnoremap <C-LEFT> b

        " go through position history
            nnoremap <S-UP> <C-i>
            nnoremap <S-DOWN> <C-o>

        " Move seletion area
            vnoremap <S-UP> V<C-v>koko
            vnoremap <S-DOWN> V<C-v>jojo
            vnoremap <S-RIGHT> V<C-v>lolo
            vnoremap <S-LEFT> V<C-v>hoho

        " go to end of paragraph
            nnoremap { [(
            nnoremap } ])

        " Jumb to end/beggining of block
            nnoremap ] ]}
            nnoremap [ [{
            vnoremap ] ]}
            vnoremap [ [{
        
        " Easy beg/end of line
            nnoremap ^ 0
            nnoremap 0 ^
            nnoremap <S-Insert> $

        " Move between splits
            nmap <A-LEFT> <C-w><LEFT>
            nmap <A-UP> <C-w><UP>
            nmap <A-RIGHT> <C-w><RIGHT>
            nmap <A-DOWN> <C-w><DOWN>

    " Plugin related maps
        " Ale
            nnoremap <LEADER>hn :ALENext<CR>
            nnoremap <LEADER>hp :ALEPrevious<CR>

        " Git stuff
            " Plugin: GitGutter, fugitive
            nnoremap <LEADER>gu :GitGutterUndoHunk<CR>
            nnoremap <LEADER>gn :GitGutterNextHunk<CR>
            nnoremap <LEADER>gp :GitGutterPrevHunk<CR>
            nnoremap <LEADER>gP :GitGutterPreviewHunk<CR>
            nnoremap <LEADER>gh :GitGutterLineHighlightsToggle<CR>
            nnoremap <LEADER>gd :Gdiffsplit<CR>
            nnoremap <LEADER>gb :GitBlame<CR>

        " Tabular indenting
            nnoremap <leader>t= mm:Tabular /^[^=]*\zs=<CR>`m
            nnoremap <leader>t: mm:Tabular /^[^:]*:\zs/l0r1<CR>`m
            nnoremap <leader>t> mm:Tabular /^[^=]*\zs=>/<CR>`m
            nnoremap <leader>t<SPACE> mm:Tabular / *\zs /l0<CR>`m
            vnoremap <leader>t= :Tabular /^[^=]*\zs=<CR>
            vnoremap <leader>t: :Tabular /:\zs<CR>
            vnoremap <leader>t<SPACE> :Tabular / *\zs /l0<CR>
            nnoremap <leader>t> mm:Tabular /^[^=]*\zs=>/<CR>`m

            nmap <leader>t* mm?/\*\*<CR>kmn:/\/\*\*/,/\*\//s/^\s\+\*\s\+@\S\+\zs\s\+/ /<CR>`n:/\/\*\*/,/\*\//s/^\s\+\*\s\+@\(param\\|return\)\s\+\S\+\zs\s\+/ /<CR>`n:/\/\*\*/,/\*\//s/@param\s\+\S\+\s\+\S\+\zs\s\+/ /<CR>`nO<ESC>0CTabular /^\s\+\*\s\+@\S\+\s*\zs\s/l0\|Tabular /^\s\+\*\s\+@\(param\\|return\)\s\+\S\+\s*\zs\s/l0\|Tabular /^\s\+\*\s\+@param\s\+\S\+\s\+\S\+\s*\zs\s/l0<ESC>:s/[^\\]\zs\|/\r/g<CR>^"tDddk^"rDddk^"eDdd`n:/\/\*\*/,/\*\//g/./<C-r>e<CR>`n:/\/\*\*/,/\*\//g/./<C-r>r<CR>`n:/\/\*\*/,/\*\//g/./<C-r>t<CR>`m

            nnoremap <leader>t :Tabular /
            vnoremap <leader>t :Tabular /

        " NerdTree toggle
            map <LEADER>f :NERDTreeToggle<CR>
            map <F2> :NERDTreeToggle<CR>

        " FZF
            nnoremap <C-p> :call FZFFindFile()<CR>
            nnoremap <F12> :call FZFFindWordUnderCursor()<CR>
            nnoremap <C-f> :call FZFFindWord()<CR>
            nnoremap <LEADER>u :call FZFUnicode()<CR>


        " Commentary
            nnoremap  :Commentary<CR>
            inoremap  <C-o>:Commentary<CR>
            vnoremap  :Commentary<CR>gv

    " Buffer related maps
        " Buffers navigation 
            nnoremap <Tab> :bnext<CR>
            nnoremap <S-Tab> :bprev<CR>

        " Buffer management
            nnoremap <LEADER>q :bd<CR>

    " Language specific  maps
        " Easy HTML tag change
            nnoremap ch vito<ESC>T<msvit<ESC>f/lmecwTMP<ESC>`scwTMP<ESC>F</TMP<CR>cgn

    " New Ideas
        " Fast insert mode
            nnoremap <LEADER>b bi
            nnoremap <LEADER>i bi
            nnoremap <LEADER>B Bi
            nnoremap <LEADER>I Bi
            nnoremap <LEADER>e ea
            nnoremap <LEADER>a ea
            nnoremap <LEADER>E Ea
            nnoremap <LEADER>A Ea
            nnoremap <LEADER>= f=a
            nnoremap <LEADER>. f.a

        " Double Tap shortcut
            " inoremap << <><LEFT>
            " inoremap (( ()<LEFT>
            " inoremap [[ []<LEFT>
            " inoremap {{ {}<LEFT>
            " inoremap '' ''<LEFT>
            " inoremap __ __<LEFT>
            " inoremap `` ``<LEFT>
            " inoremap "" ""<LEFT>
            inoremap >> <ESC>ya>Pf<a <ESC>wyiwvi>pT<i/<C-o>T>
            inoremap )) (<C-o>:echo search('[\.,;]\?$')<CR>)
            inoremap ]] [<C-o>:echo search('[\.,;]\?$')<CR>]
            inoremap }} {<C-o>:echo search('[\.,;]\?$')<CR>}

        " Backspace selector
            nnoremap d<BS> mm:call search('{')<CR>d%d'm
            nnoremap c<BS> mm:call search('{')<CR>d%c'm
            nnoremap y<BS> mm:call search('{')<CR>%y'm
            nnoremap v<BS> mm:call search('{')<CR>V%o'm
            nnoremap <<BS> mm:call search('{')<CR><%k<'m
            nnoremap ><BS> mm:call search('{')<CR>>%k>'m

        " Paste selector
            nnoremap >p mm`[>`]`m
            nnoremap <p mm`[<`]`m
            nnoremap dp '[d']
            nnoremap =p mm`[=`]`m

        " Easy delete until...
            onoremap ; t;
            onoremap : t:
            onoremap ) t)
            onoremap } t}
            onoremap > t>
            onoremap ] t]
            onoremap . t.
            onoremap " t"
            onoremap ' t'
            onoremap , t,
            nnoremap c= ^:call search('= \?\zs\\|$')<CR>mm:call search('[;,]\?$')<CR>mn`mc`n
            nnoremap d= ^:call search('= \?\zs\\|$')<CR>mm:call search('[;,]\?$')<CR>mn`md`n
            nnoremap dq mm:call search('\u\\|\>\\|_')<CR>d`m
            nnoremap cq mm:call search('\u\\|\>\\|_')<CR>c`m

        " semi-column things
            inoremap ;; <C-o>:call setline('.', getline('.') . ';')<CR>
            inoremap ;a <C-o>A
            inoremap ;. <C-o>A.
            inoremap ;, <C-o>A,
            inoremap <C-l> <RIGHT>
            inoremap <C-SPACE> <RIGHT>

        " select multiple lines in a VSCode Style
            " nmap <CS-LEFT>
            " nmap <CS-RIGHT>
            nnoremap <CS-DOWN> <C-v>j
            nnoremap <CS-UP> <C-v>k
            vnoremap <CS-DOWN> j
            vnoremap <CS-UP> k
            vnoremap <LEADER>i I
            vnoremap <LEADER>a A
            vnoremap <LEADER>I ^I
            vnoremap <LEADER>A $A

        " Delete corresponding brace and similar
            " To Fix!
            " nmap d% v%<ESC>r@gvo<ESC>x:s/^\s*\n//<CR>gv:s/@//g<CR>:s/^\s*\n//<CR>gv<ESC>:noh<CR>

        " Around selection, completes the vim-surround plugin
            vmap m S
            vnoremap m/ c//<ESC>P
            vnoremap m_ c__<ESC>P
            vnoremap m+ c++<ESC>P
            vnoremap m. c..<ESC>P
            vnoremap m<SPACE> c<SPACE><SPACE><ESC>P
            vnoremap m<BS> dvhpgv
        
        " TAB shortcut to send to end of line
            inoremap .<TAB> <C-o>h<C-o>:echo search('[\.,;]\?$')<CR>.
            inoremap ,<TAB> <C-o>h<C-o>:echo search('[\.,;]\?$')<CR>,

        " Smallest range possible
            onoremap io :call SelectSmallestRangePossible(0)<CR>
            onoremap ao :call SelectSmallestRangePossible(1)<CR>
            vnoremap io <ESC>:call SelectSmallestRangePossible(0)<CR>
            vnoremap ao <ESC>:call SelectSmallestRangePossible(1)<CR>


"
" AUTOCMD
"
    " taking back position at buffer open
        autocmd BufReadPost * silent!norm!g;
        autocmd BufLeave * call AutoSaveWinView()
        autocmd BufEnter * call AutoRestoreWinView()
    " Correcting bad commenting for specific languages | Plugin: Commentary
        autocmd! BufEnter *.php :let b:commentary_format="// %s"
        autocmd! BufEnter *.vue :let b:commentary_format="// %s"
        autocmd! BufEnter *.ts :let b:commentary_format="// %s"
        autocmd! BufEnter *.coffee :let b:commentary_format="# %s"

    " Faaast language specific iab
        autocmd FileType typescript iab <buffer> c const<SPACE><C-o>ge<RIGHT><C-o>dw
        autocmd FileType typescript iab <buffer> l let<SPACE><C-o>ge<RIGHT><C-o>dw

    " Correcting FZF buffer | Plugin: FZF
        autocmd! FileType fzf
        autocmd  FileType fzf set laststatus=0 noshowmode noruler
          \| autocmd BufLeave <buffer> set laststatus=2 showmode ruler

    " refreshing file when modified outside of vim
        autocmd BufEnter * checktime
        autocmd FocusGained * checktime
        " autocmd InsertLeave * GitGutter
        " autocmd TextChanged * GitGutter
        autocmd BufWritePost * GitGutter
    
    " Unsupported files formats
        autocmd BufEnter *.abnf set filetype=abnf
        autocmd BufNewFile,BufRead *.vue set filetype=vue
        autocmd BufNewFile,BufRead *.coffee set filetype=coffee


"
" ABREVS
"
    " Comments shortcut
        iab /// //<ENTER><C-o>O
        iab /** /**<CR><CR>/<UP>

    "
    " Mistypes
    "
        iab cnosole console
        iab cnosoel console
        iab cnsole console
        iab loaction location
        iab loaciton location 

    " French Accents
        iab etre être
        iab occupee occupée
        iab entete entête
        iab entetes entêtes
        iab requete requête
        iab etudiant étudiant
        iab etudiants étudiants
        iab ecole école
        iab ecoles écoles
        iab etais étais
        iab etait était
        iab implemente implémente
        iab implementation implémentation

    " Unicode
        iab \> ➤
        iab \\> ⤷
        iab \! ⚠
