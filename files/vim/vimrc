" 
" GENERAL NATIVE VIM SETTINGS
" 
    " filetype plugin indent off
    syn on
    filetype on
    set nu
    set wrap
    set linebreak
    set breakindent
    set ruler
    set hidden
    " set updatetime=1000
    set showtabline=2  " always show tabline
    set noshowmode
    set nobackup
    set nowritebackup
    " set updatetime=130
    set shortmess+=c
    set signcolumn=yes
    " set termguicolors  " Increases the saturation
    set previewheight=5

    " different cursors in different modes
        let &t_SI = "\<Esc>[6 q"
        let &t_SR = "\<Esc>[4 q"
        let &t_EI = "\<Esc>[2 q"
        set timeoutlen=1000 ttimeoutlen=0

    set ve=block
    set hlsearch
    set incsearch

    set smartindent
    set autoindent

    set wildmenu
    set showcmd
    set scrolloff=5
    " set relativenumber
    set conceallevel=2
    set nostartofline
    set mouse=a

    set formatoptions=cro
    set clipboard=unnamedplus

    set swapfile
    set dir=/tmp
    set modeline

    " to refresh file on git checkout
        set autoread

    set tabstop=4 shiftwidth=4 expandtab

    " Considering '-' as part of a word
        set iskeyword+=-

    " Disable freaking sql completion
        let g:omni_sql_no_default_maps = 1

    " change the leader key to <space>
        let g:mapleader = "\<Space>"
    " Don't conceal markdown
        let g:vim_markdown_conceal_code_blocks=0
        let g:vim_markdown_conceal=0
    " Ignored files ( formated in bash style, like in the `ls` command )
        let g:ignoredDirs = [ 'target', '__pycache__', '.git', 'cache', 'node_modules', 'coverage', 'dist' ]
        let g:ignoredFiles = [ '*.log', '*.class', 'tags', '*.lock' ]

" 
" LOOKS AND FEEL
" 
    " General
        colorscheme gruvbox
        set fillchars=stl:\ ,stlnc:=,vert:│,fold:\ ,diff:-
        set listchars=tab:.\ , list

    " Folding
        let g:foldMode=1
        set foldlevelstart=99
        set foldmethod=expr
        set foldexpr=FoldLevel(v:lnum)
        set foldtext=NeatFoldText()

    " GruvBox config
        let g:gruvbox_italic = 1
        let g:gruvbox_undercurl = 1
        let g:gruvbox_termcolors = 256
        let g:gruvbox_contrast_dark = "medium"
        let g:gruvbox_italicize_strings = 1
        let g:gruvbox_invert_selection = 0
        let g:gruvbox_invert_signs = 0  " for GitGutter signs
        let g:gruvbox_guisp_fallback = 'bg'

    " GVim
        set guioptions-=m  "remove menu bar
        set guioptions-=T  "remove toolbar
        set guioptions-=r  "remove right-hand scroll bar
        set guioptions-=L  "remove left-hand scroll bar
        set background=dark

    " language specific
        " python
            " let g:python_highlight_all
            let g:python_highlight_builtin_funcs=1
            let g:python_highlight_builtin_objs=1
            let g:python_highlight_builtins=1
            let g:python_highlight_doctests=1
            let g:python_highlight_exceptions=1
            let g:python_highlight_file_headers_as_comments=1
            let g:python_highlight_indent_errors=0
            let g:python_highlight_space_errors=0
            let g:python_highlight_string_format=1
            let g:python_highlight_string_formatting=1
            let g:python_highlight_string_templates=1
            let g:python_print_as_function=1
            let g:python_slow_sync=0
            let g:python_version_2=0

" 
" FUNCTIONS
" 

    function! RestrictSearch(flag)
        let cursearch = @/
        let save = winsaveview()

        " let cara = matchstr( a:line, '\S\ze\s' )
        let start = matchstr(cursearch, '\\%>\zs\d\+\zel')
        let end = matchstr(cursearch, '\\%<\zs\d\+\zel')
        let search = substitute(cursearch, '\\%[<>]\d\+l', '', 'g')

        if a:flag == 0
            let @/ = search
            return
        endif

        if a:flag < 0
            if !end
                let end = line('.') + 1
            endif
            if start
                call setpos('.', [0, start + 1, 0, 0])
            endif
            call search(search, 'bW')
            let start = line('.') - 1
        else
            if !start
                let start = line('.') - 1
            endif
            if end
                call setpos('.', [0, end, 0, 0])
            endif
            call search(search, 'W')
            let end = line('.') + 1
        endif

        call winrestview(save)

        let @/ = '\%>'.start.'l\%<'.end.'l'.search
        call histadd('/', @/)
    endfunction
    function! DoAtEach(macro, range)
        echom a:macro
        let save = winsaveview()
        let count = 0
        let searchSave = @/
        let selSave = [ getpos("'<"), getpos("'>") ]
        if a:range < 0
            call setpos('.', [0, 1, 1, 0])
            while search(@/, 'W')
                let count += 1

                exe "exe \"norm! " . substitute(substitute(a:macro, '<>', '\<ESC>', 'g'), '<[a-zA-Z-]\+>\|"', '\\&', 'gi') . '"'

                let @/ = searchSave
                call setpos("'<", selSave[0])
                call setpos("'>", selSave[1])

                if count > 200
                    break
                endif
            endwhile
        else
            call setpos('.', getpos("'<"))
            let botline = line("'>")
            while line('.') <= botline

                let col = col('.')
                exe "exe \"norm! " . substitute(substitute(a:macro, '<>', '\<ESC>', 'g'), '<[a-zA-Z-]\+>\|"', '\\&', 'gi') . '"'
                if line('.') == line('$')
                    break
                endif
                call setpos('.', [0, line('.')+1, col, 0])
                " norm!j

                let @/ = searchSave
                call setpos("'<", selSave[0])
                call setpos("'>", selSave[1])

                let count += 1
                if count > 10000
                    break
                endif
            endwhile
            " norm!gv
        endif

        call winrestview(save)
    endfunction
    command! -range -nargs=+  MacroToAll call DoAtEach(<q-args>, '<count>')
    command! -range -nargs=+  M call DoAtEach(<q-args>, '<count>')

    function! ParseErrorLine(errLine)
        let data = split(a:errLine, ':')
        let filename = remove(data, 0)
        if len(data) > 0
            let line = remove(data, 0)
        else
            let line = 1
        endif
        if len(data) > 0
            let column = remove(data, 0)
        else
            let column = 1
        endif
        exe "edit ".filename
        call cursor(line, column)
        filetype detect
        redraw!
    endfunction
    command! -nargs=+  Err call ParseErrorLine('<args>')

    function! HandleSignal()
        let message = readfile('/tmp/vim_sig.txt')
        call ParseErrorLine(message[0])
    endfunction

    autocmd Signal SIGUSR1 call HandleSignal()

    function! ComparePositions(pos1, pos2)
        if a:pos1[0] < a:pos2[0]
            return 1
        endif
        if a:pos1[0] > a:pos2[0]
            return -1
        endif
        if a:pos1[1] < a:pos2[1]
            return 1
        endif
        if a:pos1[1] > a:pos2[1]
            return -1
        endif
        return 0
    endfunction

    function! CursorOnMatch(searchPattern)
        let position = getcurpos()[1:2]
        let curpos = getpos('.')
        call setpos('.', [0] + position + [0])

        let pos = searchpos(a:searchPattern, 'ec')

        if pos == [0,0] || ComparePositions(position, pos) < 0
            call setpos('.', curpos)
            return 0
        endif


        let pos = searchpos(a:searchPattern, 'bnc')

        if pos == [0,0] || ComparePositions(pos, position) < 0
            call setpos('.', curpos)
            return 0
        endif

        call setpos('.', curpos)
        return 1
    endfunction
    function! MoveFaster(num, count)
        let g:num = a:num
        let g:count = a:count
        if a:count > 0
            if a:num < 0
                let curline = line('.')
                call setpos('.', [0, 2*curline - a:count, col('.'), 0])
            elseif a:num > 0
                call setpos('.', [0, a:count, col('.'), 0])
            endif
        endif
        let b:tap = getbufvar(bufnr(), 'tap', 0)
        let lastTap = b:tap
        if a:num > 0
            let out = "\<DOWN>"
        elseif a:num < 0
            let out = "\<UP>"
        endif

        if a:num > 0 && lastTap > 0 || a:num < 0 && lastTap < 0
            let out = repeat(out, abs(lastTap))

            if abs(b:tap) < 2
                let b:tap = lastTap + a:num
            endif
        elseif b:tap != 0
            let b:tap = 0
        else
            let b:tap = lastTap + a:num
        endif

        exe "norm!".out
    endfunction

    function! EOL()
        call setpos('.', [0, line('.'), col('$'), 0, col('$')])
    endfunction

    function! CursorInFileWindow()
        let notFile = {
            \   'filetype' : [
            \     'qf'      , 'vimpager', 'undotree', 'tagbar',
            \     'nerdtree', 'vimshell', 'vimfiler', 'voom'  ,
            \     'tabman'  , 'unite'   , 'quickrun', 'Decho',
            \     'fzf'
            \   ],
            \   'bufname' : [
            \     'GoToFile'                  , 'diffpanel_\d\+'      ,
            \     '__Gundo_Preview__'         , '__Gundo__'           ,
            \     '\[LustyExplorer-Buffers\]' , '\-MiniBufExplorer\-' ,
            \     '_VOOM\d\+$'                , '__Urannotate_\d\+__' ,
            \     '__MRU_Files__', '.*FZF'
            \   ]
            \ }

        if index(notFile.filetype, &ft) != -1 ||
                    \ len(&buftype)
            return 0
        endif
        let bufname = buffer_name()
        for rx in notFile.bufname
            if len(matchstr(bufname, rx))
                return 0
            endif
        endfor
        return 1
    endfunction

    function! SmartJumpToEnd()
        if search('\%#.\?$', 'n') != 0
            call setpos("'m", getpos('.'))
            call search('^\(\s\+\).*\%#.*\n\(\1.*\n\)*\zs\1')
            call append('.', repeat(' ', indent('.')))
            norm!j
            call setpos("'n", getpos('.'))
            norm!=`m`n
            call EOL()
        else
            let pos = search('\%#.\{-}\zs[\[\](){}]')

            if pos == 0
                call search('.;\?$')
            elseif search('\%#[[({]') != 0
                " Opening tag
                norm!%
            else
                " Closing tag
                norm!h
            endif
        endif
    endfunction

    function! MapToNextMove(cmd)
        let cmd = escape(a:cmd, '\\"')
        sil!exe "aug nextmove \<BAR>" .
                    \ "autocmd CursorMoved * :sil!exe \"" . cmd . "\\<BAR> aug nextmove \\<BAR> au! \\<BAR> aug END \\<BAR> aug! nextmove\" \<BAR>"
                    \ "aug END"
    endfunction

    function! DuplicateLines(type, ...)
        if a:0
            " We're in visual mode
            if visualmode() == 'v'
                exe 'normal! "my"mPgv'
            else
                exe "normal! :co '<-1\<CR>gv"
            endif
        else
            '[,'] copy '[-1
            call setpos('.', [0, line("']")+1, 1000, 0])
        endif
    endfunction

    function! GetGroupName()
        if !exists("*synstack" )
            return
        endif
        echo map(synstack(line('.'), col('.')), 'synIDattr(v:val, "name" )')
    endfunction

    function! FoldLevel(lnum)
        return indent(nextnonblank(a:lnum)) / getbufvar('.', '&tabstop', 1)
        " return ( max([
        "     \     indent(prevnonblank(a:lnum)),
        "     \     indent(nextnonblank(a:lnum))
        "     \ ]) / getbufvar('.', '&tabstop', 1) )
    endfunction

    function! NeatFoldText()
        let foldchar         = matchstr(&fillchars, 'fold:\zs.')
        let lines_count      = v:foldend - v:foldstart + 1
        let lines_count_text = printf("┈─ %1s lines ─┈", lines_count) . repeat(foldchar, 10)
        let foldtextstart    = repeat(' ', indent(nextnonblank(v:foldstart))) . " ••• " 
        let foldtextend      = lines_count_text . repeat(foldchar, 8)
        let foldtextlength   = strlen(substitute(foldtextstart . foldtextend, '.', 'x', 'g')) + &foldcolumn

        return foldtextstart . repeat(foldchar, winwidth(0) - foldtextlength) . foldtextend
    endfunction

    function! EatNChars(num)
        let l:number = a:num
        let l:string = ""

        while l:number > 0
            let l:string .= nr2char(getchar())
            let l:number -= 1
        endwhile

        return ''
    endfunction

    function! CountBefore(rx, until_pos)
        let save = winsaveview()
        let count=0
        while search(a:rx, 'Wb', a:until_pos[0])
            if col('.') > a:until_pos[1]
                let count += 1
            else
                break
            endif
        endwhile
        call winrestview(save)
        return count
    endfunction

    function! FindNextCouple(couple, reverse)
        if a:reverse && CursorOnMatch(a:couple[0]) || ! a:reverse && CursorOnMatch(a:couple[1])
            let pos = getpos('.')[1:2]
            return pos
        endif
        let save = winsaveview()
        let stack = 0
        if a:reverse
            let flags = 'Wb'
        else
            let flags = 'W'
        endif
        while search(a:couple[0].'\|'.a:couple[1], flags)
            if CursorOnMatch(a:couple[0])
                let stack += 1
            else
                let stack -= 1
            endif
            if a:reverse && stack > 0 || !a:reverse && stack < 0
                break
            endif
        endwhile
        let pos = getpos('.')[1:2]
        call winrestview(save)
        return pos
    endfunction

    function! FindSmallestRangePossible(in)
        let couples = [
                    \   ['['         , ']'         , 1],
                    \   ['<'         , '>'         , 1],
                    \   ['{'         , '}'         , 1],
                    \   ['('         , ')'         , 1],
                    \   ['\/\*'      , '\*\/'      , 1],
                    \   ['"'         , '"'         , 0],
                    \   ["'"         , "'"         , 0],
                    \   ['[^`]`[^`]' , '[^`]`[^`]' , 1],
                    \   ['`'         , '`'         , 1],
                    \ ]
        let best_before = [0, 0]
        let best_after = [0, 0]
        let best_couple = []

        let save = winsaveview()
        for couple in couples
            let [start, end, wraps] = couple
            let before = searchpos(start, 'Wbnc')
            let after = searchpos(end, 'Wnce')
            
            if before == [0, 0] || after == [0, 0]
                continue
            endif

            if before == after
                let limit_line = 0
                if !wraps | let limit_line = line('.') | endif
                if CountBefore(start, [limit_line, 0]) % 2 == 0
                    call setpos('.', [0, line('.'), col('.')+1, 0])
                else
                    call setpos('.', [0, line('.'), col('.')-1, 0])
                endif
                let before = searchpos(start, 'Wbnc')
                let after = searchpos(end, 'Wnce')
            endif

            if best_before == [0, 0] || best_after == [0, 0] || ( 
                \   ComparePositions(best_before, before)>0
                \   && ComparePositions(after, best_after)>0
                \ )
                if start == end
                    let limit_line = 0
                    if !wraps | let limit_line = line('.') | endif
                    if CountBefore(start, [limit_line, 0]) % 2 == 0
                        continue
                    endif
                else
                    let _before = FindNextCouple(couple, 1)
                    let _after = FindNextCouple(couple, 0)
                    if _before == before
                        let after = _after
                    elseif _after == after
                        let before = _before
                    else
                        continue
                    endif
                endif
                let best_before = before
                let best_after = after
                let best_couple = couple
            endif
            call winrestview(save)
        endfor

        if best_before == [0, 0] || best_after == [0, 0]
            return [0]
        endif

        if (a:in)
            call setpos('.', [0] + best_before + [0])
            call search(best_couple[0], 'ecW')
            call search('\s*[^[:blank:]]\|^')
            let best_before = getpos('.')[1:2]

            call setpos('.', [0] + best_after + [0])
            call search(best_couple[1], 'bcW')
            call search('[^[:blank:]]\s*\|$', 'be')
            let best_after = getpos('.')[1:2]
            call winrestview(save)
        endif

        return [best_before, best_after, best_couple]
    endfunction

    function! SelectSmallestRangePossible(external)
        let res = FindSmallestRangePossible(! a:external )
        if res == [0]
            return
        endif
        call setpos("'<", [0] + res[0] + [0])
        call setpos("'>", [0] + res[1] + [0])
        norm!gv
        if mode() == 'V'
            norm!v
        end
    endfunction

    function! VimToGrepRegex(str)
        let rx = a:str

        let gargs = ""

        let rx = substitute(rx, '\\<\|\\>','\\b', 'g')

        if rx =~ '^\\c'
            let rx = substitute(rx, '^\\c','', '')
            let gargs .= " -i"
        endif

        return [rx, gargs]
    endfunction

    function! FZFFindFile()
        " let cmd = 'ls --color=never -t $(find . -type f  ' . ignoredFilesStr . ' ' . ignoredDirsStr . ') 2> /dev/null'
        let cmd = 'ls --color=never -t $(find-file .) 2> /dev/null'
        " silent! exe fzf#run({'source': cmd, 'sink': 'e', 'options': '-e -d/ -n-1 --history /home/zorzi/.local/share/fzf-history/FZF --multi --no-sort --preview="git diff --color=always {}" --sync', 'down':'40%'})
        silent! exe fzf#run({'source': cmd, 'sink': 'e', 'options': '-e --history /home/zorzi/.local/share/fzf-history/FZF --multi --no-sort --preview="git diff --color=always {}" --sync', 'down':'40%'})
    endfunction
    function! s:FZFOpenVimOutput(str)
        let thefile = matchstr(a:str, '^.\{-\}\ze:')
        let theline = matchstr(a:str, '^.\{-\}:\zs\d\+\ze:')
        silent! exe 'edit ' . fnameescape(thefile)
        echo cursor(theline,0)
    endfunction
    function! FZFFindWordUnderCursor()
        set hlsearch
        let @/ = expand("<cword>")
        call FZFFind(expand("<cword>"))
    endfunction
    function! FZFFindWord()
        call inputsave()
        let str = input('> ')
        call inputrestore()
        call FZFFind(str)
    endfunction
    function! FZFFind(str)
        let [grepStr, grepArgs] = VimToGrepRegex(a:str)

        let previewLines = string(float2nr(&lines * 0.4))

        " let ignoredFilesStr = ''
        " for f in g:ignoredFiles
        "     let ignoredFilesStr .= ' ! -name "' . f . '"'
        " endfor

        " let ignoredDirsStr = ''
        " for d in g:ignoredDirs
        "     let ignoredDirsStr .= ' ! -path "*/' . d . '/*"'
        " endfor

        " let preview = '"echo {} | awk -F: ''{printf(\"sed -n %d,%dp %s\",(\$2>'.previewLines.'?\$2-'.previewLines.':1), \$2+'.previewLines.', \$1)}'' | xargs -I% bash -c \"%\" | highlight --syntax (echo \"{}\" | sed -e \"s/:.*\\$//g\") -O ansi | grep -C 100 --color=always \"' . grepStr . '\" "'
        let cmd = 'grep-r "' . grepStr . '" ' . grepArgs
        let preview = '"preview.sh {} '.previewLines.' | grep -C 100 --color=always \"'.grepStr.'\""'
        call fzf#run({'source': cmd, 'sink': function('s:FZFOpenVimOutput'), 'options': '-e --no-sort --ansi --multi --sync --preview=' . preview , 'down':'40%' })
    endfunction
    function! s:FZFPrintUnicode(line)
        let cara = matchstr( a:line, '\S\ze\s' )
        exe 'silent !grep "^'.cara.'" $HOME/.vim/customFiles/unicode_chars.txt > /tmp/unicode_temp.txt'
        exe 'silent !grep -v "^'.cara.'" $HOME/.vim/customFiles/unicode_chars.txt >> /tmp/unicode_temp.txt'
        exe 'silent !mv /tmp/unicode_temp.txt $HOME/.vim/customFiles/unicode_chars.txt'
        exe "norm!i" . cara
    endfunction
    function! FZFUnicode()
        let cmd = 'cat $HOME/.vim/customFiles/unicode_chars.txt'
        call fzf#run({'source': cmd, 'sink': function('s:FZFPrintUnicode'), 'options': '-e --no-sort --ansi', 'down':'40%' })
    endfunction

    " Save current view settings on a per-window, per-buffer basis.
    function! AutoSaveWinView()
        if !exists("w:SavedBufView")
            let w:SavedBufView = {}
        endif
        let w:SavedBufView[bufnr("%")] = winsaveview()
    endfunction
    " Restore current view settings.
    function! AutoRestoreWinView()
        let buf = bufnr("%")
        if exists("w:SavedBufView") && has_key(w:SavedBufView, buf)
            let v = winsaveview()
            let atStartOfFile = v.lnum == 1 && v.col == 0
            if atStartOfFile && !&diff
                call winrestview(w:SavedBufView[buf])
            endif
            unlet w:SavedBufView[buf]
        endif
    endfunction

    function! GetHighlightProps(grpName)
        " Saving linting colors, for the function
        let grpID = synIDtrans(hlID(a:grpName))

        let baseProperties = [ "bold", "italic", "reverse", "inverse", "standout", "underline", "undercurl", "strikethrough" ]
        let base = []

        for prop in baseProperties
            if synIDattr(grpID, prop) == '1'
                let base += [prop]
            endif
        endfor
        let base = join(base, ',')

        return {
                    \ 'name': a:grpName,
                    \ 'fg': synIDattr(grpID, "fg"),
                    \ 'bg': synIDattr(grpID, "bg"),
                    \ 'base': base
                    \ }
    endfunction

    function! ALEToggleHighlights(flag)
        if a:flag == 0
            hi clear ALEError
            hi clear ALEWarning
            hi clear ALEInfo
        else
            let grps = [g:AleErrorHI, g:AleWarningHI, g:AleInfoHI]

            for grp in grps
                let cmd = 'hi '.grp['name'].' '
                if len(grp['fg']) > 0
                    let cmd .= 'ctermfg='.grp['fg'].' '
                endif
                if len(grp['bg']) > 0
                    let cmd .= 'ctermbg='.grp['bg'].' '
                endif
                if len(grp['base']) > 0
                    let cmd .= 'cterm='.grp['base'].' '
                endif
                exe cmd
            endfor
        endif
    endfunction

    function! FloatingMessage(message)
        let bufnr = nvim_create_buf(v:false, v:true)
        call setbufvar(bufnr, '&signcolumn', 'no')

        let message = ' -- ' . a:message

        let winheight = 1
        let winwidth = len(message)

        let width = float2nr(winwidth - (winwidth*2/10))

        let opts = {
                    \ 'relative': 'cursor',
                    \ 'row': 0,
                    \ 'col': col('$') - col('.') + 4,
                    \ 'focusable': 0,
                    \ 'width': winwidth,
                    \ 'height': 1,
                    \ 'style': 'minimal'
                    \ }

        call appendbufline(bufnr, 0, message)

        let winnr = nvim_open_win(bufnr, v:false, opts)

        let props = GetHighlightProps('Normal')

        exe "hi Pop cterm=italic ctermbg=" . props.bg . " ctermfg=245"
        call setwinvar(winnr, '&winhighlight', 'NormalFloat:Pop')

        call MapToNextMove('exe "norm!:bd!' . bufnr . '\<CR>"')
    endfunction

    function! GitBlame()
        let line=line('.')
        let truefile = system('readlink -f ' . expand('%'))
        let truepath = matchstr(truefile, '^.*/', '')
        let cmd = 'cd '.truepath.' && git blame -p -L '.line.','.line.' '.truefile
        let res = systemlist(cmd)

        let author = ''
        let summary = ''
        let time = ''
        for line in res
            if match(line, 'author ') == 0
                let author = substitute(line, '^\S*\s*', '', '')
            endif
            if match(line, 'summary ') == 0
                let summary = substitute(line, '^\S*\s*', '', '')
            endif
            if match(line, 'author-time ') == 0
                let time = substitute(line, '^\S*\s*', '', '')
            endif
        endfor

        let time = EpochToRelative(time)

        call FloatingMessage(author . ' ) ' . time . ' | ' . summary)
    endfunction

    function! EpochToRelative(epoch)
        let now = system('date +"%s"')
        let diff = now - a:epoch

        let units = ['year', 'month', 'day', 'hour', 'minute', 'second']
        let values = [1] " second
        call insert(values, values[0] * 60) " minute
        call insert(values, values[0] * 60) " hour
        call insert(values, values[0] * 24) " day
        call insert(values, values[0] * 31) " month
        call insert(values, values[1] * 365) " year

        let out = ''
        let cnt = 0
        let yes = 0
        while cnt < len(values)
            let nb = diff / values[cnt]
            let diff -= nb * values[cnt]
            if nb > 0
                let plural = ''
                if nb > 1 | let plural = 's' | endif
                let out .= nb.' '.units[cnt].plural.', '

                " Max 2 units displayed
                if yes | break
                else | let yes = 1
                endif
            endif
            let cnt += 1
        endwhile

        let out = substitute(out, '[[:blank:],]\+$', '', '') . ' ago'

        return out
    endfunction

" 
" PLUGINS CONFIG
" 
    " Ale Linting
        let g:ale_fixers = {
                    \ 'typescript': ['prettier'],
                    \ 'javascript': ['prettier'],
                    \ 'python': ['autopep8']
                    \ }

        let g:ale_linters = {
                    \ 'python': ['pyls']
                    \ }
                    " \ 'typescript': ['eslint'],
                    " \ 'javascript': ['eslint'],
                    " \ 'rust': ['rust-analyzer'],

        let g:ale_enabled = 0
        autocmd! BufNewFile,BufRead *.py let g:ale_enabled = 1
        " let g:ale_sign_error = '✘'
        " let g:ale_sign_warning = '⚠'
        let g:ale_sign_error = ''
        let g:ale_sign_warning = ''
        au! InsertEnter * call ALEToggleHighlights(0)
        au! InsertLeave * call ALEToggleHighlights(1)

        let g:ale_lint_on_text_changed = 'never'
        let g:ale_lint_on_insert_leave = 1
        let g:ale_lint_on_enter = 1
        let g:ale_completion_enabled = 1
        
        let g:AleErrorHI = GetHighlightProps("ALEError")
        let g:AleWarningHI = GetHighlightProps("ALEWarning")
        let g:AleInfoHI = GetHighlightProps("ALEInfo")

    " Goyo
        nnoremap <LEADER><BS> <CMD>Goyo<CR>

    " smartHits
        let g:smartHits_pairs = [
            \ ['(', ')'],
            \ ['[', ']'],
            \ ['{', '}'],
            \ ['<', '>'],
            \ ['/**', '*/'],
            \ ['''', ''''],
            \ ['"', '"'],
            \ ['```', '```'],
            \ ]

        " ^ at start of lhs to only work if match at start of line
        " $ at end of lhs to only work if match at end of line
        " \(...\) in lhs, and $1 in rhs to repeat capture or $& to repeat full match
        let g:smartHits_abbrevs = {
            \   'vim': {
            \     '^l': "let",
            \   },
            \   'html': {
            \     '^\%(div\|span\|table\|h\d\)$': "<$&></$&>\<C-o>F<!",
            \     '^\.\.\([[:alnum:]-]\+\)$': "<div class=\"$1\"></div>\<C-o>F<!",
            \   },
            \   'javascript': {
            \     'l': "let",
            \     'c': "const",
            \     'prom': "new Promise((resolve, reject) => {})\<LEFT>\<LEFT>!",
            \     '^ret$': "return",
            \     'req$': "require('')\<LEFT>\<LEFT>!",
            \     'aw': "await",
            \     '^ii': "if(  )\<LEFT>\<LEFT>!",
            \     'ff': "\<ESC>:if match(getline(line('.')), ')$') != -1 \<BAR> call setline('.', getline('.') . ';') \<BAR> endif\<CR>a() => {\<CR>}\<C-o>O!",
            \     '^tryc$': "try {\<ESC>:call SmartJumpToEnd()\<CR>a} catch (err) {\<CR>}\<C-o>O\<SPACE>\<BS>\<C-o>z"
            \   },
            \   'javascriptreact': {
            \     '@inherit': 'javascript',
            \   },
            \   'typescriptreact': {
            \     '@inherit': 'javascriptreact typescript',
            \   },
            \   'typescript': {
            \     '@inherit': 'javascript',
            \     'ro': "readonly",
            \     'pub': "public",
            \     'pri': "private",
            \   },
            \   'vue': {
            \     '@inherit': 'typescript',
            \   },
            \   'sql': {
            \     'sel': 'SELECT * FROM',
            \     'upd': 'UPDATE tbl SET row = ""',
            \     'del': 'DELETE FROM',
            \   },
            \ }

    " indentLine
        let g:indentLine_char = '┆'

    " CoC
        let g:coc_snippet_next = "<C-x>"
        let g:coc_snippet_prev = "<C-z>"
        function! s:check_back_space() abort
            let col = col('.') - 1
            return !col || getline('.')[col - 1]  =~# '\s'
        endfunction

        " Use <c-l> to trigger completion.
        inoremap <silent><expr> <c-l> coc#refresh()

        " Use <cr> to confirm completion, `<C-g>u` means break undo chain at current
        " position. Coc only does snippet and additional edit on confirm.
        if has('patch8.1.1068')
            " Use `complete_info` if your (Neo)Vim version supports it.
            inoremap <expr> <C-x> complete_info()["selected"] != "-1" ? "\<C-y>" : "\<C-g>u\<CR>"
        else
            imap <expr> <C-x> pumvisible() ? "\<C-y>" : "\<C-g>u\<CR>"
        endif

        " GoTo code navigation.
        " nmap <silent> <C-]> <Plug>(coc-definition)
        " nmap <silent> gd <Plug>(coc-type-definition)
        nmap <silent> <C-]> <Plug>(coc-implementation)
        nmap <silent> <F12> <Plug>(coc-references)

        " Use K to show documentation in preview window.
        nnoremap <silent> <F1> :call <SID>show_documentation()<CR>
        inoremap <silent> <F1> <CMD>call CocActionAsync('showSignatureHelp')<CR>

        function! s:show_documentation()
            if (index(['vim','help'], &filetype) >= 0)
                execute 'h '.expand('<cword>')
            else
                call CocAction('doHover')
            endif
        endfunction

        " Symbol renaming.
        nmap <leader>rn <Plug>(coc-rename)

        " Formatting selected code.
        xmap <leader>f  <Plug>(coc-format-selected)
        nmap <leader>f  <Plug>(coc-format-selected)

        augroup mygroup
            autocmd!
            " Setup formatexpr specified filetype(s).
            autocmd FileType typescript,json setl formatexpr=CocAction('formatSelected')
            " Update signature help on jump placeholder.
            autocmd User CocJumpPlaceholder call CocActionAsync('showSignatureHelp')
        augroup end

        " Remap keys for applying codeAction to the current line.
        " nmap <leader>ac  <Plug>(coc-codeaction)

        " Use <TAB> for selections ranges.
        " NOTE: Requires 'textDocument/selectionRange' support from the language server.
        " coc-tsserver, coc-python are the examples of servers that support it.
        xmap <silent> <TAB> <Plug>(coc-range-select)

        " Add `:Format` command to format current buffer.
        command! -nargs=0 Format :call CocAction('format')

        " Add `:Fold` command to fold current buffer.
        command! -nargs=? Fold :call     CocAction('fold', <f-args>)

        " Add `:OR` command for organize imports of the current buffer.
        command! -nargs=0 OR   :call     CocAction('runCommand', 'editor.action.organizeImport')

        " Add (Neo)Vim's native statusline support.
        " NOTE: Please see `:h coc-status` for integrations with external plugins that
        " provide custom statusline: lightline.vim, vim-airline.
        set statusline^=%{coc#status()}%{get(b:,'coc_current_function','')}

    " Coc Tree
        let g:coc_explorer_global_presets = {
                    \   '.vim': {
                    \      'root-uri': '~/.vim',
                    \   },
                    \   'floating': {
                    \      'position': 'floating',
                    \   },
                    \   'floatingTop': {
                    \     'position': 'floating',
                    \     'floating-position': 'center-top',
                    \   },
                    \   'floatingLeftside': {
                    \      'position': 'floating',
                    \      'floating-position': 'left-center',
                    \      'floating-width': 50,
                    \   },
                    \   'floatingRightside': {
                    \      'position': 'floating',
                    \      'floating-position': 'left-center',
                    \      'floating-width': 50,
                    \   },
                    \   'simplify': {
                    \     'file-child-template': '[selection | clip | 1] [indent][icon | 1] [filename omitCenter 1]'
                    \   }
                    \ }

        autocmd! FileType coc-explorer set conceallevel=0

    " Typescript-vim
        let g:typescript_indent_disable = 1

    " Vim LightLine
        let g:lightline = {
            \ 'colorscheme': 'powerline',
            \ 'active': {
            \   'left':[ [ 'mode', 'paste' ],
            \            [ 'gitbranch', 'readonly', 'filename', 'modified' ]
            \   ]
            \ },
            \ 'tabline': {
            \   'left': [ ['buffers'] ],
            \   'right': [ [ 'close' ], ],
            \ },
            \ 'component_expand': {
            \   'buffers': 'lightline#bufferline#buffers'
            \ },
            \ 'component_type': {
            \   'buffers': 'tabsel'
            \ },
            \ 'component': {
            \   'separator': '',
            \   'lineinfo': ' %3l:%-2v',
            \ },
        \ }

        " NERDTree File highlighting
        function! ExplorerHighlight(extension, link, all)
            exec 'autocmd filetype coc-explorer highlight link ' . a:extension .' '.a:link
            if a:all
                exec 'autocmd filetype coc-explorer syn match ' . a:extension .' #^\W*\zs\w.*'. a:extension .'\>\s\+#'
            else
                exec 'autocmd filetype coc-explorer syn match ' . a:extension .' #^\W*\w.*\zs'. a:extension .'\>\ze\s\+#'
            endif
        endfunction

        call ExplorerHighlight('txt', 'GruvboxBlue', 0)
        call ExplorerHighlight('md',  'GruvboxBlue', 0)
        " call ExplorerHighlight('css', 'GruvboxBlue', 0)

        call ExplorerHighlight('lock',    'GruvboxBlackItalic', 1)
        call ExplorerHighlight('conf',    'GruvboxBlackItalic', 1)
        call ExplorerHighlight('config',  'GruvboxBlackItalic', 1)
        call ExplorerHighlight('gql',     'GruvboxBlackItalic', 1)
        call ExplorerHighlight('ini',     'GruvboxBlackItalic', 1)
        call ExplorerHighlight('css',     'GruvboxBlackItalic', 1)
        call ExplorerHighlight('json',    'GruvboxBlackItalic', 1)
        call ExplorerHighlight('spec.ts', 'GruvboxBlackItalic', 1)
        call ExplorerHighlight('ico',     'GruvboxBlackItalic', 1)

        call ExplorerHighlight('csv',  'GruvboxYellow', 0)

        call ExplorerHighlight('yaml',       'GruvboxAqua', 0)
        call ExplorerHighlight('yml',        'GruvboxAqua', 0)
        call ExplorerHighlight('Dockerfile', 'GruvboxAqua', 0)

        call ExplorerHighlight('html', 'GruvboxPurple', 0)
        call ExplorerHighlight('php',  'GruvboxPurple', 0)

        call ExplorerHighlight('py',     'GruvboxRed', 0)
        call ExplorerHighlight('coffee', 'GruvboxRed', 0)
        call ExplorerHighlight('js',     'GruvboxRed', 0)
        call ExplorerHighlight('ts',     'GruvboxRed', 0)

        let g:lightline.component_raw = {'buffers': 1}
        let g:lightline#bufferline#enable_devicons = 1
        let g:lightline#bufferline#clickable = 1
        " let g:lightline#bufferline#reverse_buffers = 1

        let g:lightline.separator = {
            \   'left': '', 'right': ''
          \}
        let g:lightline.subseparator = {
            \   'left': '', 'right': '' 
          \}

    " Git blame line
        let g:blameLineVirtualTextHighlight = 'GruvboxBlackItalic'
        let g:blameLineVirtualTextPrefix = '  '
        let g:blameLineGitFormat = '%an - %ar - %s | %h'

    " ultisnips
        let g:UltiSnipsSnippetDirectories  = [$HOME.'/.vim/UltiSnips']
        let g:UltiSnipsExpandTrigger       = "<C-l>"
        inoremap <C-SPACE> <C-x>
        inoremap <C-x> <CMD>call UltiSnips#JumpForwards()<CR>
        inoremap <C-z> <CMD>call UltiSnips#JumpBackwards()<CR>
        vnoremap <C-x> <CMD>call UltiSnips#JumpForwards()<CR>
        vnoremap <C-z> <CMD>call UltiSnips#JumpBackwards()<CR>

    " easy-motion
        let g:EasyMotion_enter_jump_first=1
        autocmd StdinReadPre * let s:std_in=1
        nmap s <plug>(easymotion-overwin-f2)

    " FZF
        let g:fzf_history_dir = '~/.local/share/fzf-history'
        let g:fzf_nvim_statusline = 0 " disable statusline overwriting

    " GitGutter
        let g:gitgutter_map_keys = 0
        let g:gitgutter_max_signs = 2000
        let g:gitgutter_sign_added = '▎'
        let g:gitgutter_sign_modified = '▎'
        let g:gitgutter_sign_removed = '▎'
        let g:gitgutter_sign_modified_removed = '▎'
        let g:gitgutter_sign_removed_above_and_below = '▎'
        let g:gitgutter_sign_removed_first_line = '▎'

" 
" PLUGINS
" 
    " including Vundle and initialize
    set rtp+=~/.vim/bundle/Vundle.vim
    call vundle#begin()

        " 
        " Gotta go fast!
        " 
            " move lightning fast
            " Plugin 'easymotion/vim-easymotion'

            " indent range
            Plugin 'vim-indent-object'

            " fast close pairs
            " Plugin 'jiangmiao/auto-pairs'

            " Fast surround shortcuts
            Plugin 'tpope/vim-surround'

            " fast comment
            Plugin 'tpope/vim-commentary'

            if has('nvim')
                " Snippets
                Plugin 'sirver/UltiSnips'
            endif

        " 
        " Pretty editor
        " 
            " visual indents
            Plugin 'Yggdroot/indentLine'

            " Pretty icons
            Plugin 'ryanoasis/vim-devicons'

            " Line on the bottom of the screen
            Plugin 'itchyny/lightline.vim'

            " Distraction free
            Plugin 'junegunn/goyo.vim'

        " 
        " Language specific
        " 
            " Vue
            " Plugin 'darthmall/vim-vue'
            " Plugin 'leafOfTree/vim-vue-plugin'

            " React
            Plugin 'pangloss/vim-javascript'
            Plugin 'peitalin/vim-jsx-typescript'
            Plugin 'styled-components/vim-styled-components', { 'branch': 'main' }

            " Angular
            Plugin 'burnettk/vim-angular'
            " Plugin 'othree/javascript-libraries-syntax.vim'

            " Typescript
            Plugin 'leafgarland/typescript-vim'

            " Rust
            Plugin 'rust-lang/rust.vim'

            " nim
            Plugin 'alaviss/nim.nvim'

            " python
            Plugin 'dense-analysis/ale'

        " 
        " Others
        " 
            " visual GIT modifs
            Plugin 'airblade/vim-gitgutter'

            " align everything!
            Plugin 'godlygeek/tabular'

            " Fuzzy search
            Plugin 'junegunn/fzf'
            Plugin 'junegunn/fzf.vim'

            " React
            Plugin 'MaxMEllon/vim-jsx-pretty'

            " Buffer stuff
            " Plugin 'taohexxx/lightline-buffer'
            Plugin 'z0rzi/lightline-bufferline'

            Plugin 'neoclide/coc.nvim', {'branch': 'release'}

        " 
        " My plugins!
        " 
            Plugin 'z0rzi/vim-adaptive-indent'
            " Plugin 'z0rzi/vim-super-macro'
            Plugin 'z0rzi/vim-zorzi-smoothie'
            Plugin 'z0rzi/vim-glorious-commentary'
            Plugin 'z0rzi/vim-auto-regex'
            Plugin 'z0rzi/vim-smart-hits'
            Plugin 'z0rzi/vim-detect-style'

    call vundle#end()

" 
" MAPS
" 
    " Basic Vim Shortcuts
        nnoremap >> i<C-t><ESC>
        nnoremap Y y$
        nnoremap YY <CMD>let v = winsaveview()<CR>ggyG<CMD>call winrestview(v)<CR>
        nnoremap vv v$h
        noremap <CR> %
        inoremap <F2> <ESC>
        inoremap <C-x><C-l> <C-x><C-l>
        inoremap <silent> <C-r>/ <C-r>=substitute(@/, '\\.', '', 'g')<CR>
        inoremap <LEFT> <C-G>U<LEFT>
        inoremap <RIGHT> <C-G>U<RIGHT>
        inoremap <DOWN> <C-G>U<DOWN>
        inoremap <UP> <C-G>U<UP>



        nnoremap <M-z> <C-w>w
        " nnoremap / /\v
        vnoremap <CR> <CMD>if mode() == 'V' <BAR> call search('\%#.*\zs\([{[(][;:.,\\]*\<BAR>\/\*\+\)$') <BAR> endif<CR>%

        vnoremap p <CMD>let save=@0<CR>p<CMD>let [@0, @", @+] = [save, save, save]<CR>
        vnoremap $ $h
        nnoremap - 2<C-y><C-g>
        nnoremap + 2<C-e><C-g>
        vnoremap g= c<C-r>=<C-r>+<CR><ESC>
        nnoremap g= Vc<C-r>=<C-r>+<CR><ESC>
        inoremap \'e é
        nnoremap cb xmj<CMD>call search('\<', 'b')<CR>c`j
        nnoremap db xmj<CMD>call search('\<', 'b')<CR>d`j


        " nnoremap <F3> :set hlsearch!<CR>
        nnoremap <F3> <CMD>noh<CR>
        " Plugin: GitGutter
        nmap <F5> <CMD>redraw!<CR><CMD>GitGutter<CR><CMD>set foldmethod=expr<CR>

        " Fast selection wrap
            vnoremap "" c""<ESC>Pgvlolo
            vnoremap '' c''<ESC>Pgvlolo
            vnoremap `` c``<ESC>Pgvlolo
            vnoremap {{ c{  }<ESC>hPgvllollo
            vnoremap }} c{}<ESC>Pgvlolo
            vnoremap [[ c[  ]<ESC>hPgvllollo
            vnoremap ]] c[]<ESC>Pgvlolo
            vnoremap (( c(  )<ESC>hPgvllollo
            vnoremap )) c()<ESC>Pgvlolo
            " vnoremap << c<  ><ESC>hP
            " vnoremap >> c<><ESC>P

        " no yank delete
            nnoremap <leader> "_

        " no include newline
            nnoremap 'd ^D
            nnoremap 'D 0D
            nnoremap 'c ^C
            nnoremap 'C 0C
            nnoremap 'y mm^y$`m
            nnoremap 'Y mm0y$`m
            nnoremap 'v ^v$ho
            nnoremap 'V 0v$ho

        " move lines
            nnoremap <C-j> <CMD>m+1<CR>
            nnoremap <C-down> <CMD>m+1<CR>
            nnoremap <C-k> <CMD>m-2<CR>
            nnoremap <C-up> <CMD>m-2<CR>
            vnoremap <C-up> :<C-u>exe (line("'<")-1) . " m " . line("'>")<CR>gv
            vnoremap <C-down> :<C-u>exe (line("'>")+1) . " m " . (line("'<") - 1)<CR>gv
            vnoremap <C-right> dpgvlolo
            vnoremap <C-left> dhPgvhoho


        " Duplicate lines
            nnoremap <silent> Z <CMD>set opfunc=DuplicateLines<CR>g@
            vnoremap <silent> Z  <CMD>call DuplicateLines(visualmode(), 1)<CR>
            nnoremap <silent> ZZ <CMD>co +0<CR>
            nnoremap <silent> zx <CMD>co +0<CR>

        " Easy search n replace
            " nnoremap <C-c> <CMD>let @/="\\<".expand("<cword>")."\\>"<CR>lNcgn
            nnoremap <C-c> <CMD>if CursorOnMatch(@/) <BAR> exe "norm!lN" <BAR> else <BAR> let @/="\\<".expand("<cword>")."\\>" <BAR> endif<CR>cgn

        " Better ranges for XML
            nmap >it vitVkoj>
            nmap <it vitVkoj<


        " Cool selection stuff
            vnoremap <C-c> "ay:let @/ = SelectionToRx(@a) <BAR> call histadd('/', @/) <BAR> set hlsearch <CR>cgn
            vnoremap <S-LEFT> "ay:let @/ = SelectionToRx(@a) <BAR> call histadd('/', @/)<CR>?<CR>
            vnoremap <S-RIGHT> "ay:let @/ = SelectionToRx(@a) <BAR> call histadd('/', @/)<CR>/<CR>
            vnoremap # "ay:let @/ = SelectionToRx(@a) <BAR> call histadd('/', @/)<CR>?<CR>
            vnoremap * "ay:let @/ = SelectionToRx(@a) <BAR> call histadd('/', @/)<CR>/<CR>
            nmap <CS-Right> <CMD>call RestrictSearch(1)<CR>
            nmap <CS-Left> <CMD>call RestrictSearch(-1)<CR>

        " Init folds
            function! FoldIfMakeSense(offset)
                let line = line('.') + matchstr(a:offset, '-\?\d*$')
                let foldline = foldclosed(line)

                if foldline != -1
                    return
                endif

                exe"".a:offset."foldclose"
            endfunction
            function! FoldAllSameLevel()
                let curpos = getcurpos()
                let saveSearch = @/
                let indent = matchstr(getline(line('.')), '^\s\+')
                exe"%g/^\\(".indent."\\s*\\S\\)\\@!\\s*\\S.*\\(\\n\\s*\\)\\+".indent."\\S/call FoldIfMakeSense('+1')"
                let @/ = saveSearch
                call setpos('.', curpos)
                noh
            endfunction
            nnoremap zff <CMD>call FoldAllSameLevel()<CR>

    " Moving mapping
        " fast exact search
            nnoremap <leader>/ /\<\><LEFT><LEFT>

        " go to next/previous match under cursor
            function! NextOccurence(way)
                call RestrictSearch(0)
                if ! CursorOnMatch(@/)
                    let @/ = '\<'.expand('<cword>').'\>'
                else
                    let @/ = @/
                endif
                call histadd('/', @/)
                call search(@/, 'bc')
                if a:way > 0
                    norm!n
                else
                    norm!N
                endif
            endfunction
            nnoremap <silent> <S-LEFT> <CMD>call NextOccurence(-1) <BAR> set hlsearch <CR>
            nnoremap <silent> <S-RIGHT> <CMD>call NextOccurence(1) <BAR> set hlsearch <CR>

        " Skip word by word with CTRL + direction
            nnoremap <C-LEFT> <CMD>call search('\<\<BAR>\u\l\<BAR>_[a-z]\<BAR>\s\zs\S\<BAR>^', 'bW')<CR>
            nnoremap <C-RIGHT> <CMD>call search('\w\>\<BAR>\u\l\<BAR>_[a-z]\<BAR>\S\s\<BAR>$', 'W')<CR>
            inoremap <C-LEFT> <CMD>call search('\<\<BAR>\u\l\<BAR>_[a-z]\<BAR>\s\zs\S\<BAR>^', 'bW')<CR>
            inoremap <C-RIGHT> <CMD>call search('\>\zs\<BAR>\u\l\<BAR>_[a-z]\<BAR>\S\zs\s\<BAR>$', 'W')<CR>

        " go to end of paragraph
            function! IndentJump(direction)
                let curline = line('.')
                " let indent = matchstr(getline(curline), '^\s*')
                let indent = indent(curline)
                if a:direction >= 0
                    " let nextLineNum = search('^.*\S.*$', 'n')
                    let nextLineNum = nextnonblank(line('.')+1)
                else
                    " let nextLineNum = search('^.*\S.*\n\_.*\%#', 'nb')
                    let nextLineNum = prevnonblank(line('.')-1)
                endif
                " let nextIndent = matchstr(getline(nextLineNum), '^\s*')
                let nextIndent = indent(nextLineNum)

                if nextIndent < indent || indent == 0
                    if a:direction >= 0
                        let flag = ''
                    else
                        let flag = 'b'
                    endif
                    call search('^.*\S.*\zs$', flag)
                else
                    if a:direction >= 0
                        " call search('^\('.indent.'\).*\n\(\1.*\n\|\s*\n\)*\1.*\zs')
                        call search('[\n[:blank:]]*\n\%\( \)\{,'.(indent-1).'}\S')
                    else
                        " call search('^\('.indent.'\)\S.*\zs\ze\n\(\1.*\n\|\s*\n\)*.*\%#')
                        call search('^\%\( \)\{,'.(indent-1).'}\S.*\n[\n[:blank:]]*.*\zs', 'b')
                    endif
                endif
            endfunction
            noremap <S-UP> <CMD>call IndentJump(-1)<CR>
            noremap <S-DOWN> <CMD>call IndentJump(1)<CR>

        " go to end of paragraph
            nnoremap { [(
            nnoremap } ])

        " Easy beg/end of line
            nnoremap ^ 0
            nnoremap 0 ^
            nnoremap <S-Insert> $

        " Move between splits
            nmap <A-LEFT> <C-w><LEFT>
            nmap <A-UP> <C-w><UP>
            nmap <A-RIGHT> <C-w><RIGHT>
            nmap <A-DOWN> <C-w><DOWN>
            nmap <A-h> <C-w>h
            nmap <A-k> <C-w>k
            nmap <A-h> <C-w>h
            nmap <A-l> <C-w>l

    " Plugin related maps
        " CoC
            " nnoremap <C-f> :CocSearch 
            " nnoremap <C-f><C-f> :CocSearch \b<C-r>=expand('<cword>')<CR>\b

            nnoremap <C-q> :CocAction<CR>
            nnoremap <S-q> :CocCommand<CR>

            nnoremap <LEADER>= <CMD>call CocAction('format')<CR>

            " Tab to go through completion list
            inoremap <silent><expr> <TAB>
                  \ pumvisible() ? "\<C-n>":
                  \ <SID>check_back_space() ? "\<TAB>":
                  \ coc#refresh()
            inoremap <expr><S-TAB> pumvisible() ? "\<C-p>" : "\<C-h>"

            inoremap <expr> <cr> pumvisible() ? "\<C-y>" : "\<C-g>u\<CR>"

            nnoremap <F2> :CocCommand explorer<CR>

            " Close the preview window when completion is done.
            autocmd! CompleteDone * if pumvisible() == 0 | pclose | endif

            " nmap <silent> <C-c> <Plug>(coc-cursors-position)
            " nmap <silent> <C-d> <Plug>(coc-cursors-word)
            " xmap <silent> <C-d> <Plug>(coc-cursors-range)
            " use normal command like `<leader>xi(`
            " nmap <leader>x  <Plug>(coc-cursors-operator)

        " Git stuff
            " Plugin: GitGutter
            nnoremap <LEADER>gu <CMD>sil!GitGutterUndoHunk<CR>
            nnoremap <LEADER>gn <CMD>sil!GitGutterNextHunk<CR>
            nnoremap <LEADER>gp <CMD>sil!GitGutterPrevHunk<CR>
            nnoremap <LEADER>gP <CMD>sil!GitGutterPreviewHunk<CR>
            nnoremap <LEADER>gh <CMD>sil!GitGutterLineHighlightsToggle<CR>
            nnoremap <LEADER>gb <CMD>call GitBlame()<CR>

        " Tabular indenting
            nnoremap <leader>t= mm<CMD>Tabular /^[^=]*\zs=<CR>`m
            nnoremap <leader>t: mm<CMD>Tabular /^[^:]*:\zs/l0r1<CR>`m
            nnoremap <leader>t> mm<CMD>Tabular /^[^=]*\zs=>/<CR>`m
            nnoremap <leader>t<SPACE> mm<CMD>Tabular / *\zs /l0<CR>`m
            vnoremap <leader>t= :Tabular /^[^=]*\zs=<CR>
            vnoremap <leader>t: :Tabular /:\zs<CR>
            vnoremap <leader>t<SPACE> :Tabular / *\zs /l0<CR>
            nnoremap <leader>t> mm<CMD>Tabular /^[^=]*\zs=>/<CR>`m

            " nmap <leader>t* mm?/\*\*<CR>kmn:/\/\*\*/,/\*\//s/^\s\+\*\s\+@\S\+\zs\s\+/ /<CR>`n:/\/\*\*/,/\*\//s/^\s\+\*\s\+@\(param\\|return\)\s\+\S\+\zs\s\+/ /<CR>`n:/\/\*\*/,/\*\//s/@param\s\+\S\+\s\+\S\+\zs\s\+/ /<CR>`nO<ESC>0CTabular /^\s\+\*\s\+@\S\+\s*\zs\s/l0\|Tabular /^\s\+\*\s\+@\(param\\|return\)\s\+\S\+\s*\zs\s/l0\|Tabular /^\s\+\*\s\+@param\s\+\S\+\s\+\S\+\s*\zs\s/l0<ESC>:s/[^\\]\zs\|/\r/g<CR>^tDddk^"rDddk^"eDdd`n:/\/\*\*/,/\*\//g/./<C-r>e<CR>`n:/\/\*\*/,/\*\//g/./<C-r>r<CR>`n:/\/\*\*/,/\*\//g/./<C-r>t<CR>`m

            nnoremap <leader>t :Tabular /
            vnoremap <leader>t :Tabular /

        " FZF
            nnoremap <C-p> <CMD>call FZFFindFile()<CR>
            " nnoremap <CS-f> <CMD>call FZFFindWordUnderCursor()<CR>
            nnoremap <C-s> <CMD>call FZFFindWordUnderCursor()<CR>
            nnoremap <C-f> <CMD>call FZFFindWord()<CR>
            nnoremap <LEADER>u <CMD>call FZFUnicode()<CR>


        " Commentary
            nnoremap  <CMD>Commentary<CR>
            inoremap  <CMD>Commentary<CR>
            vnoremap  :Commentary<CR>gv

    " Buffer related maps
        " Buffers navigation 
            " nnoremap <Tab> <CMD>bnext<CR>
            " nnoremap <S-Tab> <CMD>bprev<CR>
            nnoremap <Tab> <CMD>call lightline#bufferline#next()<CR>
            nnoremap <S-Tab> <CMD>call lightline#bufferline#prev()<CR>
            " nnoremap <Tab> <CMD>b#<CR>
            " nnoremap <S-Tab> <CMD>:Buffers<CR>

        " Buffer management
            nnoremap <LEADER>q <CMD>call lightline#bufferline#remove()<CR>
            " nnoremap <LEADER>q <CMD>bprev<BAR>bd#<CR>
            nnoremap <LEADER>Q <CMD>bd<CR>

    " New Ideas
        " Fast insert mode
            nnoremap <LEADER>b bi
            nnoremap <LEADER>i bi
            nnoremap <LEADER>B Bi
            nnoremap <LEADER>I Bi
            nnoremap <LEADER>e ea
            nnoremap <LEADER>a ea
            nnoremap <LEADER>E Ea
            nnoremap <LEADER>A Ea
            nnoremap <LEADER>. f.a

        " Double Tap shortcut
            " inoremap )) (<CMD>call SmartJumpToEnd()<CR><RIGHT>)
            " inoremap ]] [<CMD>call SmartJumpToEnd()<CR><RIGHT>]
            " inoremap }} {<CMD>call SmartJumpToEnd()<CR><RIGHT>}
            inoremap )<TAB> (<CMD>call SmartJumpToEnd()<CR><RIGHT>)
            inoremap ]<TAB> [<CMD>call SmartJumpToEnd()<CR><RIGHT>]
            inoremap }<TAB> {<CMD>call SmartJumpToEnd()<CR><RIGHT>}

        " Backspace selector
            function! BSOperator()
                exe"norm!V\<ESC>"
                call setpos("'<", getpos('.'))
                call search('[{\[(]$', 'W')
                norm!%
                call setpos("'>", getpos('.'))
                norm!gv
            endfunction
            onoremap <BS> <CMD>call BSOperator()<CR>
            vnoremap <BS> <CMD>call BSOperator()<CR>

        " Paste selector
            nnoremap >p mm`[>`]`m
            nnoremap <p mm`[<`]`m
            nnoremap dp '[d']
            nnoremap =p mm`[=`]`m

        " Easy delete until...
            nnoremap v; vt;
            nnoremap v: vt:
            nnoremap v) vt)
            nnoremap v} vt}
            nnoremap v> vt>
            nnoremap v] vt]
            nnoremap v. vt.
            nnoremap v" vt"
            nnoremap v' vt'
            nnoremap v, vt,
            onoremap ; t;
            onoremap : t:
            onoremap ) t)
            onoremap ( t(
            onoremap } t}
            onoremap { t{
            onoremap > t>
            onoremap ] t]
            onoremap . t.
            onoremap " t"
            onoremap ' t'
            onoremap , t,
            nnoremap c= ^<CMD>call search('= \?\zs\\|$')<CR>mm<CMD>call search('[;,]\?$')<CR>mn`mc`n
            nnoremap d= ^<CMD>call search('= \?\zs\\|$')<CR>mm<CMD>call search('[;,]\?$')<CR>mn`md`n

        " Until MAJ or underscore
            nnoremap dq mm<CMD>call search('\u\\|\>\\|_')<CR>d`m
            nnoremap cq mm<CMD>call search('\u\\|\>\\|_')<CR>c`m
            " inoremap <C-q> <SPACE><LEFT><CMD>exe "norm!mm" <BAR> call search('\u\<BAR>\<\<BAR>_\zs\w', 'b') <BAR> exe "norm!d`m"<CR><DEL>

        " Delete after cursor in insert
            inoremap <C-e> <CMD>norm!de<CR>

        " semi-column things
            inoremap ;; <CMD>call setline('.', getline('.') . ';')<CR>
            inoremap ;a <C-o>A
            inoremap ;. <CMD>norm!$<CR><RIGHT>.
            inoremap ;, <C-o>A,

        " select multiple lines in a VSCode Style
            nnoremap <CS-DOWN> <C-v>j
            nnoremap <CS-UP> <C-v>k
            vnoremap <CS-DOWN> j
            vnoremap <CS-UP> k
            vnoremap <LEADER>i I
            vnoremap <LEADER>a A
            vnoremap <LEADER>I ^I
            vnoremap <LEADER>A $A

        " Around selection, completes the vim-surround plugin
            vmap m S
            vnoremap m/ c//<ESC>P
            vnoremap m_ c__<ESC>P
            vnoremap m+ c++<ESC>P
            vnoremap m. c..<ESC>P
            vnoremap m<SPACE> c<SPACE><SPACE><ESC>P
            vnoremap m<BS> dvhpgv

        " Smallest range possible
            onoremap io <CMD>call SelectSmallestRangePossible(0)<CR>
            onoremap ao <CMD>call SelectSmallestRangePossible(1)<CR>
            vnoremap io <ESC>:call SelectSmallestRangePossible(0)<CR>
            vnoremap ao <ESC>:call SelectSmallestRangePossible(1)<CR>

" 
" AUTOCMD
" 
    " auto delete empty lines on insert leave
        " autocmd InsertLeave * sil!s/^\s*$//

    " taking back position at buffer open
        autocmd BufReadPost * silent!norm!g;
        autocmd BufLeave * call AutoSaveWinView()
        autocmd BufEnter * call AutoRestoreWinView()

    " Correcting bad commenting for specific languages | Plugin: Commentary
        autocmd! FileType php let b:commentary_format="// %s"
        autocmd! FileType python let b:commentary_format="# %s"
        autocmd! FileType sh let b:commentary_format="# %s"
        autocmd! FileType dockerfile let b:commentary_format="# %s"
        autocmd! FileType vue let b:commentary_format="// %s"
        autocmd! FileType typescript let b:commentary_format="// %s"
        autocmd! FileType sql let b:commentary_format="-- %s"
        autocmd! FileType coffee let b:commentary_format="# %s"
        autocmd! FileType conf let b:commentary_format="# %s"
        autocmd! FileType vim let b:commentary_format="\" %s"

    " Auto detecting indent on entering a file! | Plugin: vim-adaptive-indent
        autocmd BufReadPost * AdaptIndent

    " Language specific maps
        function! CloseXmlTag()
            call search('<', 'b')
            let col = col('.')
            let tag = matchstr(getline('.'), '\%'.col.'c<\zs.\{-}\ze\%(\s\|>\|$\)')
            call search('>', '')
            let col = col('.')
            let line = getline('.')
            call setline(line('.'), getline('.')[:col-1] . '</'.tag.'>' . getline('.')[col:])
            call setpos('.', [0, line('.'), col + 1, 0])
        endfunction
        autocmd FileType html,php,javascript,javascriptreact inoremap >> <CMD>call CloseXmlTag()<CR>

    " Correcting FZF buffer | Plugin: FZF
        autocmd! FileType fzf
        autocmd  FileType fzf set laststatus=0 noshowmode noruler
          \| autocmd BufLeave <buffer> set laststatus=2 showmode ruler

    " refreshing file when modified outside of vim
        autocmd BufEnter * checktime
        autocmd FocusGained * checktime
        " autocmd InsertLeave * GitGutter
        " autocmd TextChanged * GitGutter
        autocmd BufWritePost * GitGutter

    " Unsupported files formats
        autocmd BufEnter *.abnf set filetype=abnf
        autocmd BufEnter *.fish set filetype=fish
        autocmd BufNewFile,BufRead *.vue set filetype=vue
        autocmd BufNewFile,BufRead *.coffee set filetype=coffee
        autocmd BufNewFile,BufRead *.jrl set filetype=journal
        autocmd BufNewFile,BufRead *.txt set filetype=txt
        autocmd BufNewFile,BufRead *.snippets set filetype=snippets
        autocmd BufNewFile,BufRead *.nim set filetype=nim
        autocmd BufNewFile,BufRead Jenkinsfile set filetype=groovy

    " SQL watch
        autocmd BufWritePost *.sql sil!exe "exe '!echo ' . line('.') .' > /tmp/.vim-line'"

    " Highlight current selection
        let g:selMatches = ''
        hi SelectionOthers cterm=bold,underline ctermbg=NONE ctermfg=none
        function! SelectionToRx(selText)
            return substitute(escape(a:selText, '/\\^$*.[~'), '\%(\s\|\n\)\+', '\\%(\\s\\|\\n\\)\\+', 'g')
        endfunction
        function! HighlightSel()
            sil!call matchdelete(g:selMatches)
            sil!exe "norm!\"aygv"
            let g:selMatches = matchadd('SelectionOthers', SelectionToRx(@a))
        endfunction
        autocmd CursorMoved * if mode() == 'v' | call HighlightSel() | else | sil!call matchdelete(g:selMatches) | endif

" 
" ABREVS
" 
    " Comments shortcut
        iab /// //<ENTER><C-o>O

    " Mistypes
        iab cnosole console
        iab cnosoel console
        iab cnsole console
        iab loaction location
        iab loaciton location 

    " French Accents
        iab etre être
        iab occupee occupée
        iab entete entête
        iab entetes entêtes
        iab requete requête
        iab etudiant étudiant
        iab etudiants étudiants
        iab ecole école
        iab ecoles écoles
        iab etais étais
        iab etait était
        iab implemente implémente
        iab implementation implémentation

    " Unicode
        iab \> ➤
        iab \\> ⤷
        iab \! ⚠



function! WrapLine(num)
    while len(getline('.')) > 81
        norm! ^
        let pos = col('.')
        call setpos('.', [0, line('.'), pos+a:num, 0])
        call search('\S\s', 'bW')
        if pos > col('.')
            break
        endif
        exe "norm! a\<CR>\<ESC>"
    endwhile
endfunction

nnoremap gqq <CMD>call WrapLine(81)<CR>


function! CopyWord(lnum, full_line)
    let lnum = line('.') + a:lnum

    if lnum > line('$') | let lnum = line('$') | endif
    if lnum < 0 | let lnum = 0 | endif

    if a:lnum < 0
        let lnum = prevnonblank(lnum)
    else
        let lnum = nextnonblank(lnum)
    endif
    let cnum = col('.')

    let line = getline(lnum)

    if a:full_line
        call setline('.', getline(lnum))
        call setpos('.', [0, line('.'), col('$'), 0])
        return ''
    endif

    let cara = matchstr(line, '\%'.cnum.'c.')

    if match(cara, '[a-zA-Z0-9_]') >= 0
        return matchstr(line, '\%([^a-zA-Z0-9_]\|^\)[a-zA-Z0-9_]\{-}\zs\%'.cnum.'c[a-zA-Z0-9_]\{-}\ze\%([^a-zA-Z0-9_]\|$\)')
    endif

    return cara
endfunction

inoremap <silent> <S-UP> <C-r>=CopyWord(-1, 0)<CR>
inoremap <silent> <S-DOWN> <C-r>=CopyWord(1, 0)<CR>
inoremap <silent> <CS-UP> <C-r>=CopyWord(-1, 1)<CR>
inoremap <silent> <CS-DOWN> <C-r>=CopyWord(1, 1)<CR>
